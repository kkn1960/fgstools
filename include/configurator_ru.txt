<h1>Руководство конфигуратора FGS Configurator</h1>

<p>Данный документ описывает порядок использования конфигуратора FGS Configurator для создания и экспорта спецификаций компонент. </p>

<p>Конфигуратор – это специальное веб-приложение для создания спецификаций компонент. </p>

<p>Конфигуратор создан на основе фреймворка и предоставляет веб-интерфейс пользователя к своим таблицам, именуемыми в дальнейшем как системные таблицы. Вообще в этом документе слово «системный» означает только принадлежность к Конфигуратору. У него есть свое меню, свой контроллер Configurator и свой управляющий скрипт configurator.php. Вместе со стандартными компонентами фреймворка конфигуратор использует и некоторые специальные компоненты, которые можно использовать только в конфигураторе. Экземпляры компонент, используемые в конфигураторе, также создаются на основе спецификаций, созданных в самом конфигураторе. Спецификации таких компонент имеют признак «system», установленный в «да». </p>

<p>Категорически запрещается удалять или изменять спецификации компонент с признаком «system», установленный в «да». </p>

<p>Спецификации, используемые конфигуратором, хранятся в каталоге system/specification. Все файлы, относящиеся к конфигуратору, хранятся в каталоге system/configurator.</p>

<p>Спецификации конфигуратора можно рассматривать также в качестве примера конфигурирования нужного функционала компонент.</p>

<p>Спецификации компонент хранятся в следующих системных таблицах:</p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>таблица</p></td>
<td valign="top" ><p>Что содержит</p></td>
<td valign="top" ><p>примечание</p></td>
</tr>

<tr>
<td valign="top" ><p>fgs_column</p></td>
<td valign="top" ><p>Спецификации элементов для <b>Grid</b></p></td>
<td valign="top" ><p>Таблица detail для fgs_grid</p></td>
</tr>

<tr>
<td valign="top" ><p>fgs_component</p></td>
<td valign="top" ><p>Справочник экспортируемых компонент</p></td>
<td valign="top" > </td>
</tr>

<tr>
<td valign="top" ><p>fgs_condition</p></td>
<td valign="top" ><p>Спецификации условий</p></td>
<td valign="top" > </td>
</tr>

<tr>
<td valign="top" ><p>fgs_controller</p></td>
<td valign="top" ><p>Спецификации контроллеров</p></td>
<td valign="top" > </td>
</tr>

<tr>
<td valign="top" ><p>fgs_converter</p></td>
<td valign="top" ><p>Спецификации конверторов данных</p></td>
<td valign="top" > </td>
</tr>

<tr>
<td valign="top" ><p>fgs_dataset</p></td>
<td valign="top" ><p>Спецификации наборов данных</p></td>
<td valign="top" > </td>
</tr>

<tr>
<td valign="top" ><p>fgs_debug</p></td>
<td valign="top" ><p>отладочная информация</p></td>
<td valign="top" > </td>
</tr>

<tr>
<td valign="top" ><p>fgs_element</p></td>
<td valign="top" ><p>Спецификации элементов форм ввода и поиска</p></td>
<td valign="top" ><p>Таблица detail для fgs_form</p></td>
</tr>

<tr>
<td valign="top" ><p>fgs_export</p></td>
<td valign="top" ><p>Спецификации экспорта компонент</p></td>
<td valign="top" ><p>Таблица detail для fgs_component</p></td>
</tr>

<tr>
<td valign="top" ><p>fgs_field</p></td>
<td valign="top" ><p>Спецификации полей таблиц</p></td>
<td valign="top" ><p>Таблица detail для fgs_table</p></td>
</tr>

<tr>
<td valign="top" ><p>fgs_filter</p></td>
<td valign="top" ><p>Спецификации фильтров форм ввода и поиска</p></td>
<td valign="top" ><p>Таблица detail для fgs_form</p></td>
</tr>

<tr>
<td valign="top" ><p>fgs_form</p></td>
<td valign="top" ><p>Спецификации форм ввода и поиска</p></td>
<td valign="top" > </td>
</tr>

<tr>
<td valign="top" ><p>fgs_grid</p></td>
<td valign="top" ><p>Спецификации гридов</p></td>
<td valign="top" > </td>
</tr>

<tr>
<td valign="top" ><p>fgs_item</p></td>
<td valign="top" ><p>Спецификации опций меню</p></td>
<td valign="top" ><p>Таблица detail для fgs_menu</p></td>
</tr>

<tr>
<td valign="top" ><p>fgs_list</p></td>
<td valign="top" ><p>Спецификации списков</p></td>
<td valign="top" > </td>
</tr>

<tr>
<td valign="top" ><p>fgs_menu</p></td>
<td valign="top" ><p>Спецификации меню</p></td>
<td valign="top" > </td>
</tr>

<tr>
<td valign="top" ><p>fgs_message</p></td>
<td valign="top" ><p>Языковые варианты сообщений</p></td>
<td valign="top" > </td>
</tr>

<tr>
<td valign="top" ><p>fgs_option</p></td>
<td valign="top" ><p>Спецификации опций списков</p></td>
<td valign="top" ><p>Таблица detail для fgs_list</p></td>
</tr>

<tr>
<td valign="top" ><p>fgs_parameter</p></td>
<td valign="top" ><p>Справочник экспортируемых параметров компонент</p></td>
<td valign="top" > </td>
</tr>

<tr>
<td valign="top" ><p>fgs_predicate</p></td>
<td valign="top" ><p>Спецификации предикатов наборов данных</p></td>
<td valign="top" ><p>Таблица detail для fgs_dataset</p></td>
</tr>

<tr>
<td valign="top" ><p>fgs_role</p></td>
<td valign="top" ><p>Справочник ролей пользователей</p></td>
<td valign="top" > </td>
</tr>

<tr>
<td valign="top" ><p>fgs_statement</p></td>
<td valign="top" ><p>Спецификации утверждений </p></td>
<td valign="top" ><p>Таблица detail для fgs_condition</p></td>
</tr>

<tr>
<td valign="top" ><p>fgs_table</p></td>
<td valign="top" ><p>Спецификации таблиц</p></td>
<td valign="top" > </td>
</tr>

<tr>
<td valign="top" ><p>fgs_unit</p></td>
<td valign="top" ><p>Спецификации Unit для контроллеров</p></td>
<td valign="top" ><p>Таблица detail для fgs_controller</p></td>
</tr>

<tr>
<td valign="top" ><p>fgs_user</p></td>
<td valign="top" ><p>Справочник пользователей</p></td>
<td valign="top" > </td>
</tr>

<tr>
<td valign="top" ><p>fgs_validator</p></td>
<td valign="top" ><p>Спецификации валидаторов форм ввода и поиска</p></td>
<td valign="top" ><p>Таблица detail для fgs_form</p></td>
</tr>

</tbody>
</table>

<p>Конфигуратор предоставляет веб- интерфейс к этим таблицам и экспортирует данные этих таблиц в специальные файлы спецификаций. Файлы спецификаций содержат, в основном, обычные массивы PHP. Для каждого языка интерфейса создается свой набор спецификаций, хранящийся в отдельном каталоге. Спецификации для каждого вида компонент хранятся в отдельных каталогах. Пути к этим каталогам должны быть определены в конфигурационном файле приложения.</p>

<p>Все спецификации, создаваемые программистом, должны иметь признак «system», установленный в «нет». Для всех таблиц, не являющихся системными таблицами конфигуратора, признак «system» должен быть установлен в «нет». Все прикладные спецификации хранятся в каталоге application/specification.</p>

<p>Для рендеринга компонент <b>Form</b>, <b>Grid</b> и <b>Search</b> конфигуратор использует стандартные классы <b>FgsFormView</b>, <b>FgsGridView</b> и <b>FgsSearchView</b>, входящие в состав фреймворка. При определенных условиях компоненты <b>FgsFormView</b>, <b>FgsGridView</b> и <b>FgsSearchView</b> позволяют быстро перейти к конфигурированию как самих компонентов <b>Form</b>, <b>Grid</b> и <b>Search</b>, так и отдельных элементов ввода, вывода или поиска. Это достигается путем формирования специальных ссылок, которые формируются только для пользователя с ролью «programmer» и установке значения конфигурационной переменной $FGSVersion в «development». При этом конфигуратор открывает новую вкладку с кодом окна «instant_edit», в котором и происходит конфигурирование выбранного компонента. </p>

<p>Например, при двойном клике на названии формы или грида открывается дополнительная вкладка для конфигурирования этой формы или грида. При двойном клике на ярлыке элемента ввода открывается вкладка для редактирования атрибутов этого элемента ввода. При клике на заголовке колонки открывается вкладка для редактирования атрибутов этой колонки.</p>

<p>С помощью конфигуратора можно сформировать иерархическое меню для разрабатываемого приложения. Спецификации меню также экспортируются. </p>

<p>Конфигуратор использует меню с идентификатором, равным «configurator». Опции меню сконфигурированы таким образом, что ввод спецификаций каждого компонента осуществляется в своем окне. Благодаря этому ввод спецификации всегда можно возобновить с места останова. </p>

<p>Удобство такого подхода видно на следующем примере. Например, при вводе спецификации элемента формы ввода оказалось, что нет нужного списка. Программист выбирает пункт меню для ввода спецификаций списков и вводит спецификацию нужного списка. Затем выбирает пункт меню для ввода форм ввода и продолжает ввод спецификации элемента формы ввода с того места, с которого переключился на ввод спецификации списка.</p>

<p>Категорически запрещается удалять или изменять спецификации меню с идентификатором, равным «configurator»!</p>

<p>Конфигуратор имеет двухуровневое ниспадающее меню: </p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>Меню 1-го уровня</p></td>
<td valign="top" ><p>Меню 2-го уровня</p></td>
<td valign="top" ><p>назначение</p></td>
</tr>

<tr>
<td valign="top" ><p>Спецификация</p></td>
<td valign="top" ><p>Форма ввода</p></td>
<td valign="top" ><p>Ввод спецификаций форм ввода</p></td>
</tr>

<tr>
<td valign="top" > </td>
<td valign="top" ><p>Грид</p></td>
<td valign="top" ><p>Ввод спецификаций гридов</p></td>
</tr>

<tr>
<td valign="top" > </td>
<td valign="top" ><p>Форма поиска</p></td>
<td valign="top" ><p>Ввод спецификаций форм поиска</p></td>
</tr>

<tr>
<td valign="top" > </td>
<td valign="top" ><p>Контроллер</p></td>
<td valign="top" ><p>Ввод спецификаций контроллеров</p></td>
</tr>

<tr>
<td valign="top" > </td>
<td valign="top" ><p>Набор данных</p></td>
<td valign="top" ><p>Ввод спецификаций наборов данных</p></td>
</tr>

<tr>
<td valign="top" > </td>
<td valign="top" ><p>Список</p></td>
<td valign="top" ><p>Ввод спецификаций списков</p></td>
</tr>

<tr>
<td valign="top" > </td>
<td valign="top" ><p>Опция списка</p></td>
<td valign="top" ><p>Ввод спецификаций опций списков</p></td>
</tr>

<tr>
<td valign="top" > </td>
<td valign="top" ><p>Условие </p></td>
<td valign="top" ><p>Ввод спецификаций условий</p></td>
</tr>

<tr>
<td valign="top" > </td>
<td valign="top" ><p>Конвертер</p></td>
<td valign="top" ><p>Ввод спецификаций конвертеров</p></td>
</tr>

<tr>
<td valign="top" > </td>
<td valign="top" ><p>Поле таблицы</p></td>
<td valign="top" ><p>Ввод спецификаций полей таблиц</p></td>
</tr>

<tr>
<td valign="top" > </td>
<td valign="top" ><p>Меню</p></td>
<td valign="top" ><p>Ввод спецификаций меню</p></td>
</tr>

<tr>
<td valign="top" > </td>
<td valign="top" ><p>Импорт схемы БД </p></td>
<td valign="top" ><p>Импорт структуры таблиц</p></td>
</tr>

<tr>
<td valign="top" ><p>Системная таблица</p></td>
<td valign="top" ><p>Сообщение</p></td>
<td valign="top" ><p>Ввод языковых вариантов сообщений</p></td>
</tr>

<tr>
<td valign="top" > </td>
<td valign="top" ><p>Таблица</p></td>
<td valign="top" ><p>Создание спецификаций таблиц и полей</p></td>
</tr>

<tr>
<td valign="top" > </td>
<td valign="top" ><p>Параметр экспорта</p></td>
<td valign="top" ><p>Ввод параметров экспорта</p></td>
</tr>

<tr>
<td valign="top" > </td>
<td valign="top" ><p>Экспорт</p></td>
<td valign="top" ><p>Ввод спецификаций экспорта</p></td>
</tr>

<tr>
<td valign="top" ><p>Экспорт</p></td>
<td valign="top" ><p>Список</p></td>
<td valign="top" ><p>Экспорт спецификаций списков</p></td>
</tr>

<tr>
<td valign="top" > </td>
<td valign="top" ><p>Форма ввода</p></td>
<td valign="top" ><p>Экспорт спецификаций форм ввода</p></td>
</tr>

<tr>
<td valign="top" > </td>
<td valign="top" ><p>Форма поиска</p></td>
<td valign="top" ><p>Экспорт спецификаций форм поиска</p></td>
</tr>

<tr>
<td valign="top" > </td>
<td valign="top" ><p>Грид</p></td>
<td valign="top" ><p>Экспорт спецификаций гридов</p></td>
</tr>

<tr>
<td valign="top" > </td>
<td valign="top" ><p>Набор данных</p></td>
<td valign="top" ><p>Экспорт спецификаций наборов данных</p></td>
</tr>

<tr>
<td valign="top" > </td>
<td valign="top" ><p>Контроллер</p></td>
<td valign="top" ><p>Экспорт спецификаций контроллеров</p></td>
</tr>

<tr>
<td valign="top" > </td>
<td valign="top" ><p>Меню</p></td>
<td valign="top" ><p>Экспорт спецификаций меню</p></td>
</tr>

<tr>
<td valign="top" > </td>
<td valign="top" ><p>Сообщение</p></td>
<td valign="top" ><p>Экспорт языковых вариантов сообщений</p></td>
</tr>

</tbody>
</table>


<p>Для формирования меню используются класс <b>ddm</b>.</p>

<p>Кроме ниспадающего меню конфигуратор имеет вспомогательную панель для скрытия/показа компонент, установки нужного языка интерфейса и включения/отключения показа отладочной информации. </p>

<h1>Процесс создания веб-приложения</h1>

<p>Создание веб-приложений на основе пакета заключается во вводе спецификаций компонент в конфигураторе и разработке расширений стандартных компонент.</p>

<p>Последовательность создания спецификаций компонент:</p>
<ul>
<li>Импорт структуры таблиц</li>
<li>Конфигурирование полей таблиц</li>
<li>Конфигурирование таблиц</li>
<li>Конфигурирование списков</li>
<li>Конфигурирование наборов данных </li>
<li>Конфигурирование условий</li>
<li>Конфигурирование конвертеров</li>
<li>Конфигурирование текстовых сообщений</li>
<li>Конфигурирование форм ввода</li>
<li>Конфигурирование форм поиска</li>
<li>Конфигурирование гридов</li>
<li>Конфигурирование контроллеров</li>
<li>Конфигурирование меню</li>
<li>Экспорт спецификаций</li>
</ul>

<p>Создание таблиц базы данных не входит в сферу компетенции данного пакета, так что разработчик должен создавать таблицы, используя другие программы.</p>

<h1>Импорт структуры таблиц</h1>

<p>Первым шагом нужно импортировать структуру таблиц в системные таблицы. Для считывания структуры таблиц в системные таблицы предназначен пункт меню конфигуратора Спецификация-&gt;Импорт схемы БД</p>

<p>Во время импорта данные о таблицах заносятся в таблицу fgs_table, а данные полей - в fgs_field. Если некая таблица была удалена из базы данных, то все спецификации компонент, основанные на этой таблице, удаляются из соответствующих таблиц. При удалении полей из таблиц, удаляются все спецификации компонент, относящихся к этим полям.</p>

<p>В процессе импорта на основе данных о типе поля выбираются компоненты для ввода, вывода и поиска данных по данному полю, а также условия сравнения. Например, если тип поля date, то в качестве компонента ввода выбирается InputDate,в качестве компонента вывода ColumnDate, в качестве компонента ввода аргумента для поиска InputDate, в качестве условия сравнения «Тест диапазон».</p>

<p>Каждый раз при изменении структуры таблиц нужно выполнять импорт структуры таблиц и экспорт всех спецификаций .</p>

<h1>Конфигурирование полей</h1>

<p>Для ускорения создания спецификаций и минимизации вводимых данных нужно ввести атрибуты полей таблиц для ввода, вывода и поиска. Для этой операции нужно выбрать пункт меню Спецификация-&gt;Поле таблицы для конфигурирования только полей или Системная таблица-&gt;Table для конфигурирования полей и таблиц одновременно.</p>

<p>Поля таблиц хранятся в таблице fgs_field.</p>

<p>Конфигурирование полей заключается в выборе компонент ввода, вывода, поиска, условия сравнения, значения по умолчанию и т.п. Поле ввода «ярлык» определяет текст ярлыка при вводе и заголовка колонки при выводе в гриде. Если для ввода элемента используется список, то нужно ввести этот список. Если поле является внешним ключом, то нужно ввести ссылочную таблицу, первичный ключ этой таблицы и тип ссылочной таблицы. Тип ссылочной таблицы может быть двух типов «таблица мастер» и «таблица справочник».</p>

<p>Если поле будет вводиться с помощью компонент типа «select multple» (SelectManyCheckbox, SelectManyListbox или SelectManyMenu), то тип поля нужно установить в значение «set», а поле «Dbtype ?» в значение «нет».</p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>поле</p></td>
<td valign="top" ><p>ярлык</p></td>
<td valign="top" ><p>назначение</p></td>
</tr>

<tr>
<td valign="top" ><p>field_table</p></td>
<td valign="top" ><p>Таблица</p></td>
<td valign="top" ><p>Таблица поля </p></td>
</tr>

<tr>
<td valign="top" ><p>field_name</p></td>
<td valign="top" ><p>Имя</p></td>
<td valign="top" ><p>Название поля</p></td>
</tr>

<tr>
<td valign="top" ><p>field_type</p></td>
<td valign="top" ><p>Тип</p></td>
<td valign="top" ><p>Тип поля.</p></td>
</tr>

<tr>
<td valign="top" ><p>field_dbtype</p></td>
<td valign="top" ><p>Dbtype ?</p></td>
<td valign="top" ><p>Поле признака, что значение поля «field_type» получено при импорте структуры таблицы. Для полей вводимых с помощью компонент типа «select multple» нужно установить значение «нет»</p></td>
</tr>

<tr>
<td valign="top" ><p>field_default</p></td>
<td valign="top" ><p>По умолчанию</p></td>
<td valign="top" ><p>Значение поля по умолчанию, устанавливаемое при вводе новой записи</p></td>
</tr>

<tr>
<td valign="top" ><p>field_element</p></td>
<td valign="top" ><p>Компонент ввода</p></td>
<td valign="top" ><p>Компонент, используемый при вводе поля</p></td>
</tr>

<tr>
<td valign="top" ><p>field_label</p></td>
<td valign="top" ><p>Ярлык</p></td>
<td valign="top" ><p>Ярлык, выводимый в формах ввода и поиска, а также как заголовок колонки вывода поля в гриде</p></td>
</tr>

<tr>
<td valign="top" ><p>field_list</p></td>
<td valign="top" ><p>Список</p></td>
<td valign="top" ><p>Список, используемый при вводе, поиске и выводе поля в гриде</p></td>
</tr>

<tr>
<td valign="top" ><p>field_column</p></td>
<td valign="top" ><p>Компонент колонки</p></td>
<td valign="top" ><p>Компонент колонки, используемый при выводе поля в гриде</p></td>
</tr>

<tr>
<td valign="top" ><p>field_argument</p></td>
<td valign="top" ><p>Компонент аргумента</p></td>
<td valign="top" ><p>Компонент, используемый при вводе аргумента поиска поля</p></td>
</tr>

<tr>
<td valign="top" ><p>field_predicate</p></td>
<td valign="top" ><p>Условие сравнения</p></td>
<td valign="top" ><p>Условие сравнения, используемое при поиске поля</p></td>
</tr>

<tr>
<td valign="top" ><p>field_lookup</p></td>
<td valign="top" ><p>Ссылочная таблица</p></td>
<td valign="top" ><p>Таблица, на которую ссылается поле, являющееся внешним ключом</p></td>
</tr>

<tr>
<td valign="top" ><p>field_primary_key</p></td>
<td valign="top" ><p>Первичный ключ ссылочной таблицы</p></td>
<td valign="top" ><p>Первичный ключ таблицы, на которую ссылается поле, являющееся внешним ключом</p></td>
</tr>

<tr>
<td valign="top" ><p>field_relation</p></td>
<td valign="top" ><p>Тип ссылочной таблицы</p></td>
<td valign="top" ><p>Тип таблицы, на которую ссылается поле - внешний ключ может быть двух типов:</p>

<ul>
<li>Таблица – мастер</li>
<li>Таблица - справочник</li>
</ul>

</td>
</tr>

<tr>
<td valign="top" ><p>field_align</p></td>
<td valign="top" ><p>Align</p></td>
<td valign="top" ><p>Выравнивание колонки вывода</p></td>
</tr>

<tr>
<td valign="top" ><p>field_size</p></td>
<td valign="top" ><p>Size</p></td>
<td valign="top" ><p>Атрибут «Size» при вводе поля с помощью компонента InputText </p></td>
</tr>

<tr>
<td valign="top" ><p>field_maxlength</p></td>
<td valign="top" ><p>Maxlength</p></td>
<td valign="top" ><p>Атрибут «Maxlength» при вводе поля с помощью компонента InputText </p></td>
</tr>

<tr>
<td valign="top" ><p>field_rows</p></td>
<td valign="top" ><p>Строк</p></td>
<td valign="top" ><p>Атрибут «rows» при вводе поля с помощью компонента InputTextarea</p></td>
</tr>

<tr>
<td valign="top" ><p>field_cols</p></td>
<td valign="top" ><p>Колонок</p></td>
<td valign="top" ><p>Атрибут «cols» при вводе поля с помощью компонента InputTextarea </p></td>
</tr>

</tbody>
</table>

<p>В режиме <b>inline editing</b> можно отредактировать компонент ввода, компонент вывода, компонент ввода аргумента предиката, условие сравнения при поиске, ярлык элемента ввода и список для ввода или вывода. Для этого нужно дважды кликнуть мышкой на нужном поле нужной записи в таблице записей. </p>

<h1>Конфигурирование таблиц</h1>

<p>Для конфигурирования таблиц нужно выбрать пункт меню Системная таблица-&gt;Таблица</p>

<p>Конфигурирование таблиц заключается в установке признака «system» и установке мастер таблицы, если это необходимо.</p>

<p>Для всех таблиц, относящихся к разрабатываемому приложению, поле «table_system» должно быть установлено в «нет»</p>

<p>Для таблиц, являющихся таблицей типа detail, нужно ввести соответствующую ей мастер таблицу.</p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>поле</p></td>
<td valign="top" ><p>ярлык</p></td>
<td valign="top" ><p>назначение</p></td>
</tr>

<tr>
<td valign="top" ><p>table_system</p></td>
<td valign="top" ><p>System?</p></td>
<td valign="top" ><p>Признак принадлежности таблицы к конфигуратору</p></td>
</tr>

<tr>
<td valign="top" ><p>table_name</p></td>
<td valign="top" ><p>Имя</p></td>
<td valign="top" ><p>Название таблицы</p></td>
</tr>

<tr>
<td valign="top" ><p>table_primary_key</p></td>
<td valign="top" ><p>Первичный ключ</p></td>
<td valign="top" ><p>Первичный ключ таблицы</p></td>
</tr>

<tr>
<td valign="top" ><p>table_unique_key</p></td>
<td valign="top" ><p>Уникальный ключ</p></td>
<td valign="top" ><p>Уникальные ключи таблицы</p></td>
</tr>

<tr>
<td valign="top" ><p>table_master</p></td>
<td valign="top" ><p>Таблица master</p></td>
<td valign="top" > </td>
</tr>

</tbody>
</table>

<p>Для конфигурирования полей таблицы нужно кликнуть на иконке detail этой таблицы. </p>

<h1>Конфигурирование списков</h1>

<p>Для создания списков нужно выбрать пункт меню Спецификация-&gt;Список.</p>

<p>Списки используются при конфигурировании форм ввода, гридов и форм поиска.</p>

<p>Спецификации списков хранятся в двух таблицах «fgs_list» и «fgs_option», связанных отношением «мастер-деталь». </p>

<p>Списки бывают постоянными и переменными. Опции постоянных списков хранятся в системной таблице «fgs_option». Переменные списки формируются из записей таблиц. </p>

<p>Поля «list_table_alias» и « list_field_alias» должны быть введены и быть различными в случае использования переменных списков, основанных на одной и той же таблице и в одном и том же компоненте типа Form или <b>Grid</b>.</p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>поле</p></td>
<td valign="top" ><p>ярлык</p></td>
<td valign="top" ><p>назначение</p></td>
</tr>

<tr>
<td valign="top" ><p>list_system</p></td>
<td valign="top" ><p>System ?</p></td>
<td valign="top" ><p>Признак отношения списка к конфигуратору. Для списков разрабатываемого приложения должен быть установлен в «нет»</p></td>
</tr>

<tr>
<td valign="top" ><p>list_sid</p></td>
<td valign="top" ><p>Sid</p></td>
<td valign="top" ><p>Код списка</p></td>
</tr>

<tr>
<td valign="top" ><p>list_table</p></td>
<td valign="top" ><p>Таблица</p></td>
<td valign="top" ><p>Таблица списка. Для постоянных списков значение равно «fgs_option»</p></td>
</tr>

<tr>
<td valign="top" ><p>list_table_alias</p></td>
<td valign="top" ><p>Алиас таблицы</p></td>
<td valign="top" ><p>Алиас таблицы. </p></td>
</tr>

<tr>
<td valign="top" ><p>list_primary_key</p></td>
<td valign="top" ><p>Поле - ключ</p></td>
<td valign="top" ><p>Поле, используемое в качестве атрибута «value» опций. Для постоянных списков значение равно «option_sid»</p></td>
</tr>

<tr>
<td valign="top" ><p>list_numeric</p></td>
<td valign="top" ><p>Ключ - числовой? (только для таблицы fgs_option)</p></td>
<td valign="top" ><p>Нужно вводить только для постоянных списков. Значение зависит от типа атрибута «value» опций</p></td>
</tr>

<tr>
<td valign="top" ><p>list_display_field</p></td>
<td valign="top" ><p>Видимое поле</p></td>
<td valign="top" ><p>Поле, используемое в качестве описания опции списка. Для постоянных списков значение равно «option_xxx». Если поле разное для разных языков, то нужно часть названия поля, соответствующее коду языка заменить на xxx. При экспорте списка конфигуратор заменит xxx на код соответствующего языка</p></td>
</tr>

<tr>
<td valign="top" ><p>list_field_alias</p></td>
<td valign="top" ><p>Алиас поля</p></td>
<td valign="top" ><p>Алиас поля</p></td>
</tr>

<tr>
<td valign="top" ><p>list_null_option</p></td>
<td valign="top" ><p>Нулевая опция списка</p></td>
<td valign="top" ><p>Описание нулевого опции списка. Если не указано, то будет использоваться 4 пробела. Выбор нулевой опции списка означает что не было выбора опции списка.</p></td>
</tr>

<tr>
<td valign="top" ><p>list_order</p></td>
<td valign="top" ><p>Предложение order by в SQL запросе</p></td>
<td valign="top" ><p>Порядок сортировки списка. Для постоянных списков значение равно «option_index ASC»</p></td>
</tr>

<tr>
<td valign="top" ><p>list_where</p></td>
<td valign="top" ><p>Предложение where в SQL запросе</p></td>
<td valign="top" ><p>Условие на выборку записей из таблицы</p></td>
</tr>

<tr>
<td valign="top" ><p>list_export</p></td>
<td valign="top" ><p>Экспорт?</p></td>
<td valign="top" ><p>Признак экспорта списка</p></td>
</tr>

<tr>
<td valign="top" ><p>list_class</p></td>
<td valign="top" ><p>класс загрузчика</p></td>
<td valign="top" ><p>Пользовательский класс загрузчика опций списка</p></td>
</tr>

<tr>
<td valign="top" ><p>list_dataset</p></td>
<td valign="top" ><p>Набор данных</p></td>
<td valign="top" ><p>Набор данных, используемый для формирования списка</p></td>
</tr>

</tbody>
</table>

<p>Для конфигурирования опций постоянного списка нужно выбрать действие «detail» для нужного списка и ввести опции списка.</p>

<p><b>Конфигурирование опций постоянных списков</b></p>
<br>
<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>поле</p></td>
<td valign="top" ><p>ярлык</p></td>
<td valign="top" ><p>назначение</p></td>
</tr>

<tr>
<td valign="top" ><p>option_sid</p></td>
<td valign="top" ><p>Sid</p></td>
<td valign="top" ><p>Код опции</p></td>
</tr>

<tr>
<td valign="top" ><p>option_en</p></td>
<td valign="top" ><p>Опция на английском</p></td>
<td valign="top" ><p>Описание опции на английском языке</p></td>
</tr>

<tr>
<td valign="top" ><p>option_ru</p></td>
<td valign="top" ><p>Опция на русском</p></td>
<td valign="top" ><p>Описание опции на русском языке</p></td>
</tr>

<tr>
<td valign="top" ><p>option_index</p></td>
<td valign="top" ><p>Index</p></td>
<td valign="top" ><p>Индекс опции при выводе</p></td>
</tr>

</tbody>
</table>

<p>Если нужен доступ к опциям всех постоянных списков, то нужно выбрать пункт меню Спецификация-&gt;Опция списка. В отличие от предыдущего варианта, нужно будет вводить код (идентификатор) самого списка:</p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>поле</p></td>
<td valign="top" ><p>ярлык</p></td>
<td valign="top" ><p>назначение</p></td>
</tr>

<tr>
<td valign="top" ><p>option_list</p></td>
<td valign="top" ><p>Список</p></td>
<td valign="top" ><p>Код списка</p></td>
</tr>

<tr>
<td valign="top" ><p>option_sid</p></td>
<td valign="top" ><p>Sid</p></td>
<td valign="top" ><p>Код опции</p></td>
</tr>

<tr>
<td valign="top" ><p>option_en</p></td>
<td valign="top" ><p>Опция на английском</p></td>
<td valign="top" ><p>Описание опции на английском языке</p></td>
</tr>

<tr>
<td valign="top" ><p>option_ru</p></td>
<td valign="top" ><p>Опция на русском</p></td>
<td valign="top" ><p>Описание опции на русском языке</p></td>
</tr>

<tr>
<td valign="top" ><p>option_index</p></td>
<td valign="top" ><p>Index</p></td>
<td valign="top" ><p>Индекс опции при выводе</p></td>
</tr>

</tbody>
</table>
<br>
<h1>Конфигурирование наборов данных (datasets)</h1>

<p>Для конфигурирования наборов данных нужно выбрать пункт меню Спецификация-&gt;Набор данных.</p>

<p>Наборы данных используются при конфигурировании списков и контроллеров.</p>

<p>Спецификации наборов данных хранятся в двух таблицах «fgs_dataset» и «fgs_predicate», связанных отношением «мастер-деталь». </p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>поле</p></td>
<td valign="top" ><p>ярлык</p></td>
<td valign="top" ><p>назначение</p></td>
</tr>

<tr>
<td valign="top" ><p>dataset_system</p></td>
<td valign="top" ><p>System ?</p></td>
<td valign="top" ><p>Признак отношения набора данных к конфигуратору. Для наборов данных разрабатываемого приложения должен быть установлен в «нет»</p></td>
</tr>

<tr>
<td valign="top" ><p>dataset_sid</p></td>
<td valign="top" ><p>Sid</p></td>
<td valign="top" ><p>Код набора данных </p></td>
</tr>

<tr>
<td valign="top" ><p>dataset_table</p></td>
<td valign="top" ><p>Таблица</p></td>
<td valign="top" ><p>Таблица набора данных. </p></td>
</tr>

</tbody>
</table>

<p>Для конфигурирования предикатов нужно выбрать действие «detail» для нужного набора данных и ввести данные предикатов. Предикат представляет собой условие, накладываемое на одно или несколько полей таблицы. </p>

<p>Примеры предикатов:</p>

<ul>
<li>Поле таблицы равно некоторому значению</li>
<li>Поле таблицы не равно null (здесь аргумент не нужен)</li>
<li>Сумма двух поле таблицы не превышает некоторого значения (здесь условие накладывается на несколько полей таблицы)</li>
<li>Длина значения поля не превышает некоторого значения (здесь используется SQL функция для проверяемого поля)</li>
</ul>

<p>Предикат обычно состоит из аргумента, оператора и соединителя (коннектора) предиката с предыдущим предикатом. Предикаты могут объединяться в группы. Если набор данных состоит только из одного предиката, то коннектор не используется.</p>

<p>Во время создания SQL кода предиката значение аргумента вычисляется компонентом Evaluator. Поэтому при вводе значения аргумента нужно знать алгоритм работы Evaluator, подробно описанный в Руководстве фреймворка. </p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>поле</p></td>
<td valign="top" ><p>ярлык</p></td>
<td valign="top" ><p>назначение</p></td>
</tr>

<tr>
<td valign="top" ><p>predicate_table</p></td>
<td valign="top" ><p>Таблица</p></td>
<td valign="top" ><p>Таблица поля, на которое накладывается условие</p></td>
</tr>

<tr>
<td valign="top" ><p>predicate_table_alias</p></td>
<td valign="top" ><p>Алиас таблицы</p></td>
<td valign="top" ><p>Алиас поля, на которое накладывается условие</p></td>
</tr>

<tr>
<td valign="top" ><p>predicate_field</p></td>
<td valign="top" ><p>Поле</p></td>
<td valign="top" ><p>поле, на которое накладывается условие</p></td>
</tr>

<tr>
<td valign="top" ><p>predicate_field_alias</p></td>
<td valign="top" ><p>Алиас поля</p></td>
<td valign="top" ><p>Алиас поля, поля, на которое накладывается условие </p></td>
</tr>

<tr>
<td valign="top" ><p>predicate_function</p></td>
<td valign="top" ><p>Функция</p></td>
<td valign="top" ><p>SQL функция, используемая для полей условия</p></td>
</tr>

<tr>
<td valign="top" ><p>predicate_argument</p></td>
<td valign="top" ><p>Значение</p></td>
<td valign="top" ><p>значение аргумента условия</p></td>
</tr>

<tr>
<td valign="top" ><p>predicate_operator</p></td>
<td valign="top" ><p>Оператор</p></td>
<td valign="top" ><p>Оператор условия</p></td>
</tr>

<tr>
<td valign="top" ><p>predicate_connector</p></td>
<td valign="top" ><p>Коннектор</p></td>
<td valign="top" ><p>Коннектор условия с предыдущим условием</p></td>
</tr>

<tr>
<td valign="top" ><p>predicate_fieldset</p></td>
<td valign="top" ><p>Группа</p></td>
<td valign="top" ><p>Группа, к которому относится условие</p></td>
</tr>

<tr>
<td valign="top" ><p>predicate_custom</p></td>
<td valign="top" ><p>Custom</p></td>
<td valign="top" ><p>Класс? создающий SQL кода условия</p></td>
</tr>

<tr>
<td valign="top" ><p>predicate_required</p></td>
<td valign="top" ><p>Необходимый?</p></td>
<td valign="top" ><p>Признак необходимости условия если значение аргумента не задано или равно null</p></td>
</tr>

<tr>
<td valign="top" ><p>predicate_index</p></td>
<td valign="top" ><p>Index</p></td>
<td valign="top" ><p>Индекс условия, определяющий порядок создания SQL кода предикатов</p></td>
</tr>

</tbody>
</table>
<br>
<h1>Конфигурирование условий (conditions)</h1>

<p>Для конфигурирования условий нужно выбрать пункт меню Спецификация-&gt;Условие.</p>

<p>Условия используются при конфигурировании валидаторов и фильтров форм ввода и форм поиска и валидации операций над записями таблиц. Условия состоят из одного или нескольких так называемых утверждений (statements).</p>

<p>Спецификации условий хранятся в двух таблицах «fgs_condition» и «fgs_statement», связанных отношением «мастер-деталь». </p>

<p>Для условия нужно ввести:</p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>поле</p></td>
<td valign="top" ><p>ярлык</p></td>
<td valign="top" ><p>назначение</p></td>
</tr>

<tr>
<td valign="top" ><p>condition_sid</p></td>
<td valign="top" ><p>Sid</p></td>
<td valign="top" ><p>Идентификатор условия</p></td>
</tr>

<tr>
<td valign="top" ><p>condition_type</p></td>
<td valign="top" ><p>Тип</p></td>
<td valign="top" ><p>Тип условия</p></td>
</tr>

<tr>
<td valign="top" ><p>condition_error</p></td>
<td valign="top" ><p>Ошибка</p></td>
<td valign="top" ><p>Аббревиатура ошибки условия</p></td>
</tr>

</tbody>
</table>

<p>Для конфигурирования утверждений нужно выбрать действие «detail» для нужного условия и ввести данные утверждений. Утверждения являются развитием идеи предикатов, применительно к валидации форм и действий над записями таблиц. Также как и для предикатов есть операторы сравнения и коннекторы. Утверждения также можно группировать в группы.</p>

<p>Примеры утверждений</p>

<ul>
<li>Значение сессионной переменной равно некоторому значению</li>
<li>Значение введенного поля лежит в некотором диапазоне</li>
<li>Значение введенного поля равно значению другого введенного поля</li>
<li>Редактирование записи разрешено, только если зарегистрирован пользователь с определенной ролью</li>
</ul>

<p>При конфигурировании утверждений нужно знать алгоритм работы компонента Evaluator, особенности экспорта компонент, использующих условия, и какие параметры передаются для проверки условий.</p>

<p><b>Атрибуты утверждений (statements)</b></p>
<br>
<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>поле</p></td>
<td valign="top" ><p>ярлык</p></td>
<td valign="top" ><p>назначение</p></td>
</tr>

<tr>
<td valign="top" ><p>statement_connector</p></td>
<td valign="top" ><p>Коннектор</p></td>
<td valign="top" ><p>Коннектор утверждения с предыдущим утверждением</p></td>
</tr>

<tr>
<td valign="top" ><p>statement_function</p></td>
<td valign="top" ><p>Функция</p></td>
<td valign="top" ><p>PHP функция, используемая для вычисления значения первого операнда</p></td>
</tr>

<tr>
<td valign="top" ><p>statement_operand1</p></td>
<td valign="top" ><p>Operand 1</p></td>
<td valign="top" ><p>Первый операнд</p></td>
</tr>

<tr>
<td valign="top" ><p>statement_operator</p></td>
<td valign="top" ><p>Оператор</p></td>
<td valign="top" ><p>Оператор сравнения операндов</p></td>
</tr>

<tr>
<td valign="top" ><p>statement_operand2</p></td>
<td valign="top" ><p>Operand 2</p></td>
<td valign="top" ><p>Второй операнд</p></td>
</tr>

<tr>
<td valign="top" ><p>statement_failure</p></td>
<td valign="top" ><p>Failure</p></td>
<td valign="top" ><p>Признак ошибки утверждения</p></td>
</tr>

<tr>
<td valign="top" ><p>statement_group</p></td>
<td valign="top" ><p>Группа</p></td>
<td valign="top" ><p>Группа, к которой относится утверждение</p></td>
</tr>

<tr>
<td valign="top" ><p>statement_index</p></td>
<td valign="top" ><p>Index</p></td>
<td valign="top" ><p>Индекс утверждения, определяющий порядок проверки утверждений</p></td>
</tr>

</tbody>
</table>

<p>Примеры конфигурирования утверждений приведены в разделе «Конфигурирование валидаторов формы».</p>

<h1>Конфигурирование конвертеров (converters)</h1>

<p>Для конфигурирования конвертеров нужно выбрать пункт меню Спецификация-&gt;Конвертер.</p>

<p>Конвертеры используются при конфигурировании фильтров форм ввода и форм поиска и при выводе данных в гридах. </p>

<p>Спецификации конвертеров хранятся в таблице «fgs_converter»</p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>поле</p></td>
<td valign="top" ><p>ярлык</p></td>
<td valign="top" ><p>назначение</p></td>
</tr>

<tr>
<td valign="top" ><p>converter_sid</p></td>
<td valign="top" ><p>Sid</p></td>
<td valign="top" ><p>Идентификатор конвертера</p></td>
</tr>

<tr>
<td valign="top" ><p>converter_type</p></td>
<td valign="top" ><p>Тип</p></td>
<td valign="top" ><p>Тип конвертера</p></td>
</tr>

<tr>
<td valign="top" ><p>converter_static</p></td>
<td valign="top" ><p>Статический метод?</p></td>
<td valign="top" ><p>Признак статического метода конвертера</p></td>
</tr>

</tbody>
</table>

<p>Нужно учесть, что идентификатор конвертера является одновременно и названием класса конвертера.</p>

<h1>Конфигурирование сообщений</h1>

<p>Для конфигурирования сообщений нужно выбрать пункт меню Спецификация-&gt;Сообщение.</p>

<p>Спецификации сообщений хранятся в таблицt «fgs_message» </p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>поле</p></td>
<td valign="top" ><p>ярлык</p></td>
<td valign="top" ><p>назначение</p></td>
</tr>

<tr>
<td valign="top" ><p>msg_abbr</p></td>
<td valign="top" ><p>Аббревиатура</p></td>
<td valign="top" ><p>Аббревиатура сообщения</p></td>
</tr>

<tr>
<td valign="top" ><p>msg_en</p></td>
<td valign="top" ><p>Текст на английском</p></td>
<td valign="top" ><p>Текст сообщения на английском</p></td>
</tr>

<tr>
<td valign="top" ><p>msg_ru</p></td>
<td valign="top" ><p>Текст на русском</p></td>
<td valign="top" ><p>Текст сообщения на русском</p></td>
</tr>

<tr>
<td valign="top" ><p>msg_system</p></td>
<td valign="top" ><p>System?</p></td>
<td valign="top" ><p>Признак сообщения к конфигуратору</p></td>
</tr>

</tbody>
</table>
<br>
<h1>Конфигурирование меню </h1>

<p>Для конфигурирования меню нужно выбрать пункт меню Спецификация-&gt;Меню.</p>

<p>Спецификации меню хранятся в двух таблицах «fgs_menu» и «fgs_item», связанных отношением «мастер-деталь». </p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>поле</p></td>
<td valign="top" ><p>ярлык</p></td>
<td valign="top" ><p>назначение</p></td>
</tr>

<tr>
<td valign="top" ><p>menu_id</p></td>
<td valign="top" ><p>Sid</p></td>
<td valign="top" ><p>Идентификатор меню</p></td>
</tr>

<tr>
<td valign="top" ><p>menu_name</p></td>
<td valign="top" ><p>Имя</p></td>
<td valign="top" ><p>Название меню</p></td>
</tr>

<tr>
<td valign="top" ><p>menu_system</p></td>
<td valign="top" ><p>System ?</p></td>
<td valign="top" ><p>Признак отношения меню к конфигуратору</p></td>
</tr>

</tbody>
</table>

<p>Для конфигурирования опций меню нужно выбрать действие «detail» для нужного условия и ввести данные утверждений.</p>

<p>Для каждого меню должен выделяться определенный диапазон, в котором должен находиться идентификатор опции. Идентификатор опции определяет также порядок вывода опций меню.</p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>поле</p></td>
<td valign="top" ><p>ярлык</p></td>
<td valign="top" ><p>назначение</p></td>
</tr>

<tr>
<td valign="top" ><p>item_id</p></td>
<td valign="top" ><p>Id</p></td>
<td valign="top" ><p>Идентификатор опции</p></td>
</tr>

<tr>
<td valign="top" ><p>item_pid</p></td>
<td valign="top" ><p>Pid</p></td>
<td valign="top" ><p>Идентификатор родительской опции</p></td>
</tr>

<tr>
<td valign="top" ><p>item_type</p></td>
<td valign="top" ><p>Тип</p></td>
<td valign="top" ><p>Тип опции</p></td>
</tr>

<tr>
<td valign="top" ><p>item_name</p></td>
<td valign="top" ><p>Имя</p></td>
<td valign="top" ><p>Название опции </p></td>
</tr>

<tr>
<td valign="top" ><p>item_action</p></td>
<td valign="top" ><p>Действие</p></td>
<td valign="top" ><p>Скрипт, запускаемый при выборе опции</p></td>
</tr>

<tr>
<td valign="top" ><p>item_class</p></td>
<td valign="top" ><p>Class</p></td>
<td valign="top" ><p>CSS класс опции</p></td>
</tr>

<tr>
<td valign="top" ><p>item_text</p></td>
<td valign="top" ><p>Text</p></td>
<td valign="top" ><p>Текст, выводимый JavaScript в диалоговом окне при выборе опции</p></td>
</tr>

<tr>
<td valign="top" ><p>item_condition</p></td>
<td valign="top" ><p>Condition</p></td>
<td valign="top" ><p>Условие видимости опции</p></td>
</tr>

<tr>
<td valign="top" ><p>item_target</p></td>
<td valign="top" ><p>Target</p></td>
<td valign="top" ><p>Код окна, в котором будет запущен скрипт</p></td>
</tr>

<tr>
<td valign="top" ><p>item_childs</p></td>
<td valign="top" ><p>Child options functoin</p></td>
<td valign="top" ><p>Функция формирования опций для опции, типа «меню»</p></td>
</tr>

</tbody>
</table>
<br>
<h1>Конфигурирование форм ввода (Forms)</h1>

<p>Для конфигурирования форм ввода нужно выбрать пункт меню Спецификация-&gt;Форма ввода.</p>

<p>Спецификации форм ввода хранятся в 4 таблицах: «fgs_form», являющейся мастер таблицей для 3 таблиц «fgs_element», «fgs_validator» и «fgs_filter». В таблице «fgs_element» хранятся спецификации элементов ввода, в таблице «fgs_validator» - валидаторов, а в таблице «fgs_filter» -фильтров вводимых данных. </p>

<p>Конфигурирование формы ввода заключается во вводе следующих данных:</p>

<ul>
<li>Общие данные самой формы ввода</li>
<li>Данные элементов и кнопок формы ввода</li>
<li>Данные валидаторов вводимых данных</li>
<li>Данные фильтров вводимых данных</li>
</ul>

<p><b>Общие данные формы ввода:</b></p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>поле</p></td>
<td valign="top" ><p>ярлык</p></td>
<td valign="top" ><p>назначение</p></td>
</tr>

<tr>
<td valign="top" ><p>form_system</p></td>
<td valign="top" ><p>System ?</p></td>
<td valign="top" ><p>Признак отношения формы к конфигуратору. Для форм разрабатываемого приложения должен быть установлен в «нет»</p></td>
</tr>

<tr>
<td valign="top" ><p>form_type</p></td>
<td valign="top" ><p>Тип</p></td>
<td valign="top" ><p>Тип формы. Для форм разрабатываемого приложения должен быть установлен в «приложение»</p></td>
</tr>

<tr>
<td valign="top" ><p>form_table</p></td>
<td valign="top" ><p>Таблица</p></td>
<td valign="top" ><p>Таблица формы</p></td>
</tr>

<tr>
<td valign="top" ><p>form_sid</p></td>
<td valign="top" ><p>Sid</p></td>
<td valign="top" ><p>Код формы</p></td>
</tr>

<tr>
<td valign="top" ><p>form_title</p></td>
<td valign="top" ><p>Название</p></td>
<td valign="top" ><p>Название формы</p></td>
</tr>

<tr>
<td valign="top" ><p>form_modes</p></td>
<td valign="top" ><p>Режимы</p></td>
<td valign="top" ><p>Режимы формы</p></td>
</tr>

<tr>
<td valign="top" ><p>form_startmode</p></td>
<td valign="top" ><p>Стартовый режим</p></td>
<td valign="top" ><p>Стартовый режим формы</p></td>
</tr>

<tr>
<td valign="top" ><p>form_action</p></td>
<td valign="top" ><p>Действие</p></td>
<td valign="top" ><p>Атрибут «action» формы</p></td>
</tr>

<tr>
<td valign="top" ><p>form_method</p></td>
<td valign="top" ><p>Метод</p></td>
<td valign="top" ><p>Атрибут «method» формы</p></td>
</tr>

<tr>
<td valign="top" ><p>form_id</p></td>
<td valign="top" ><p>Id</p></td>
<td valign="top" ><p>Атрибут «id» формы</p></td>
</tr>

<tr>
<td valign="top" ><p>form_rowid_after_insert</p></td>
<td valign="top" ><p>Rowid после вставки</p></td>
<td valign="top" ><p>Этот атрибут обычно нужен, если первичный ключ типа auto increment и нужно получить его сгенерированное значение для только что вставленной записи. Значение атрибута должно быть равно названию поля – первичного ключа.</p></td>
</tr>

<tr>
<td valign="top" ><p>form_onreset</p></td>
<td valign="top" ><p>Onreset</p></td>
<td valign="top" ><p>Функция JavaScript, вызываемая при наступлении события формы «onreset»</p></td>
</tr>

<tr>
<td valign="top" ><p>form_onsubmit</p></td>
<td valign="top" ><p>Onsubmit</p></td>
<td valign="top" ><p>Функция JavaScript, вызываемая при наступлении события формы «onsubmit»</p></td>
</tr>

<tr>
<td valign="top" ><p>form_initial</p></td>
<td valign="top" ><p>Начальные значения свойств</p></td>
<td valign="top" ><p>Данный параметр используется для задания начальных значений свойств компонента Form или для добавления своих свойств.</p></td>
</tr>

<tr>
<td valign="top" ><p>form_redirect_after_insert</p></td>
<td valign="top" ><p>Сделать redirect страницы после insert ?</p></td>
<td valign="top" ><p>Если данный параметр установлен в «Да», то после добавления страницы будет произведен redirect страницы для избегания добавления строк при обновлении страницы</p></td>
</tr>

</tbody>
</table>

<p>Для создания новой формы ввода можно скопировать форму с кодом FormTemplate, являющейся формой ввода типа «шаблон». Это позволит получить пустую форму с набором сконфигурированных стандартных кнопок. Для добавления полей ввода нужно выбрать действие «Add». При этом появится таблица с еще не добавленными полями таблицы формы. Отметив нужные поля нужно кликнуть на кнопке «Добавить поля». Нужно учесть, что поля добавляются с атрибутами, установленными на этапе конфигурирования полей. </p>

<p>Для конфигурирования элементов и кнопок формы ввода нужно выбрать действие «элемент» для нужной формы ввода. После этого появляется форма ввода и таблица элементов и кнопок. В режиме <b>inline editing</b> можно изменить компонент ввода, ярлык, индекс и fieldset элемента ввода. </p>

<p>Для конфигурирования элементов ввода предназначены две формы. Первая форма нужна для предварительного конфигурирования:</p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>Поле</p></td>
<td valign="top" ><p>ярлык</p></td>
<td valign="top" ><p>назначение</p></td>
</tr>

<tr>
<td valign="top" ><p>element_table</p></td>
<td valign="top" ><p>Таблица</p></td>
<td valign="top" ><p>Таблица поля</p></td>
</tr>

<tr>
<td valign="top" ><p>element_table_alias</p></td>
<td valign="top" ><p>Алиас таблицы</p></td>
<td valign="top" ><p>Алиас таблицы поля</p></td>
</tr>

<tr>
<td valign="top" ><p>element_field</p></td>
<td valign="top" ><p>Поле</p></td>
<td valign="top" ><p>Поле ввода. Если поле разное для разных языков, то можно часть названия поля, соответствующее коду языка заменить на xxx. При экспорте конфигуратор заменит xxx на код соответствующего языка</p></td>
</tr>

<tr>
<td valign="top" ><p>element_alias</p></td>
<td valign="top" ><p>Алиас поля</p></td>
<td valign="top" ><p>Алиас поля</p></td>
</tr>

<tr>
<td valign="top" ><p>element_sid</p></td>
<td valign="top" ><p>Sid</p></td>
<td valign="top" ><p>Системный код поля ввода </p></td>
</tr>

<tr>
<td valign="top" ><p>element_name</p></td>
<td valign="top" ><p>Атрибут name</p></td>
<td valign="top" ><p>Атрибут name</p></td>
</tr>

<tr>
<td valign="top" ><p>element_type</p></td>
<td valign="top" ><p>Тип</p></td>
<td valign="top" ><p>Тип поля</p></td>
</tr>

<tr>
<td valign="top" ><p>element_component</p></td>
<td valign="top" ><p>Компонент</p></td>
<td valign="top" ><p>Компонент ввода</p></td>
</tr>

<tr>
<td valign="top" ><p>element_extension</p></td>
<td valign="top" ><p>Расширение компонента</p></td>
<td valign="top" ><p>Расширение компонента ввода</p></td>
</tr>

<tr>
<td valign="top" ><p>element_index</p></td>
<td valign="top" ><p>Index</p></td>
<td valign="top" ><p>Индекс обработки и вывода поля </p></td>
</tr>

<tr>
<td valign="top" ><p>element_label</p></td>
<td valign="top" ><p>Ярлык</p></td>
<td valign="top" ><p>Ярлык ввода</p></td>
</tr>

<tr>
<td valign="top" ><p>element_modes</p></td>
<td valign="top" ><p>Режим ввода</p></td>
<td valign="top" ><p>Возможные режимы ввода</p></td>
</tr>

<tr>
<td valign="top" ><p>element_hidden</p></td>
<td valign="top" ><p>Скрытый ?</p></td>
<td valign="top" ><p>Признак «hidden» поля</p></td>
</tr>

<tr>
<td valign="top" ><p>element_fieldset</p></td>
<td valign="top" ><p>Fieldset</p></td>
<td valign="top" ><p>Fieldset поля</p></td>
</tr>

</tbody>
</table>

<p>Окончательное конфигурирование элементов ввода зависит от выбранного компонента ввода и для него нужно выбрать действие «Attribute» для нужного элемента ввода. При этом появляется форма с полями ввода, сгруппированными в 4 группы:</p>

<ul>
<li>Системные атрибуты</li>
<li>Атрибуты ввода</li>
<li>Атрибуты Ajax</li>
<li>События</li>
</ul>

<p>При этом набор полей ввода в этих группах зависит от типа выбранного компонента.</p>

<p><b>Конфигурирование системных атрибутов</b></p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>Поле</p></td>
<td valign="top" ><p>ярлык</p></td>
<td valign="top" ><p>назначение</p></td>
</tr>

<tr>
<td valign="top" ><p>element_component</p></td>
<td valign="top" ><p>Компонент</p></td>
<td valign="top" ><p>Компонент, используемый для ввода</p></td>
</tr>

<tr>
<td valign="top" ><p>element_table</p></td>
<td valign="top" ><p>Таблица</p></td>
<td valign="top" ><p>Таблица поля </p></td>
</tr>

<tr>
<td valign="top" ><p>element_table_alias</p></td>
<td valign="top" ><p>Алиас таблицы</p></td>
<td valign="top" ><p>Алиас таблицы поля</p></td>
</tr>

<tr>
<td valign="top" ><p>element_field</p></td>
<td valign="top" ><p>Поле</p></td>
<td valign="top" ><p>Поле ввода. Если поле разное для разных языков, то можно часть названия поля, соответствующее коду языка заменить на xxx. При экспорте конфигуратор заменит xxx на код соответствующего языка</p></td>
</tr>

<tr>
<td valign="top" ><p>element_alias</p></td>
<td valign="top" ><p>Алиас</p></td>
<td valign="top" ><p>Алиас поля ввода</p></td>
</tr>

<tr>
<td valign="top" ><p>element_sid</p></td>
<td valign="top" ><p>Sid</p></td>
<td valign="top" ><p>Системный идентификатор поля ввода. Необходим для различения полей ввода с разных таблиц, но с одинаковыми именами</p></td>
</tr>

<tr>
<td valign="top" ><p>element_index</p></td>
<td valign="top" ><p>Index</p></td>
<td valign="top" ><p>Номер вывода и обработки поля ввода</p></td>
</tr>

<tr>
<td valign="top" ><p>element_event</p></td>
<td valign="top" ><p>установить значение по событию</p></td>
<td valign="top" ><p>См. Урок 9</p></td>
</tr>

</tbody>
</table>

<p><b>Конфигурирование атрибутов ввода</b></p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>Поле</p></td>
<td valign="top" ><p>ярлык</p></td>
<td valign="top" ><p>назначение</p></td>
</tr>

<tr>
<td valign="top" ><p>element_fieldset</p></td>
<td valign="top" ><p>Fieldset</p></td>
<td valign="top" ><p>Fieldset поля</p></td>
</tr>

<tr>
<td valign="top" ><p>element_name</p></td>
<td valign="top" ><p>Атрибут name</p></td>
<td valign="top" ><p>Атрибут name поля ввода</p></td>
</tr>

<tr>
<td valign="top" ><p>element_label</p></td>
<td valign="top" ><p>Ярлык</p></td>
<td valign="top" ><p>Ярлык ввода</p></td>
</tr>

<tr>
<td valign="top" ><p>element_required</p></td>
<td valign="top" ><p>Необходимый ?</p></td>
<td valign="top" ><p>Признак необходимости ввода</p></td>
</tr>

<tr>
<td valign="top" ><p>element_list</p></td>
<td valign="top" ><p>Список</p></td>
<td valign="top" ><p>Список ввода</p></td>
</tr>

<tr>
<td valign="top" ><p>element_filter</p></td>
<td valign="top" ><p>Фильтр</p></td>
<td valign="top" ><p>Фильтр на список ввода</p></td>
</tr>

<tr>
<td valign="top" ><p>element_layout</p></td>
<td valign="top" ><p>Направление вывод</p></td>
<td valign="top" ><p>Направление вывода опций для компонент SelecetOneRadio и SelectManyCheckbox</p></td>
</tr>

<tr>
<td valign="top" ><p>element_null_option</p></td>
<td valign="top" ><p>Нулевая опция</p></td>
<td valign="top" ><p>Нулевая опция списка</p></td>
</tr>

<tr>
<td valign="top" ><p>element_default</p></td>
<td valign="top" ><p>По умолчанию</p></td>
<td valign="top" ><p>Значение по умолчанию</p></td>
</tr>

<tr>
<td valign="top" ><p>element_register</p></td>
<td valign="top" ><p>Глобальное имя</p></td>
<td valign="top" ><p>Глобальное имя элемента ввода</p></td>
</tr>

<tr>
<td valign="top" ><p>element_cai</p></td>
<td valign="top" ><p>Обнулить после вставки ?</p></td>
<td valign="top" ><p>Признак очистки значения ввода после вставки новой записи</p></td>
</tr>

<tr>
<td valign="top" ><p>element_left_table</p></td>
<td valign="top" ><p>Таблица слева</p></td>
<td valign="top" ><p>Таблица слева в предложении join</p></td>
</tr>

<tr>
<td valign="top" ><p>element_left_alias</p></td>
<td valign="top" ><p>Алиас таблицы слева</p></td>
<td valign="top" ><p>Алиас таблицы слева в предложении join</p></td>
</tr>

<tr>
<td valign="top" ><p>element_left_foreign_key</p></td>
<td valign="top" ><p>Внешний ключ таблицы слева</p></td>
<td valign="top" ><p>Внешний ключ таблицы слева в предложении join</p></td>
</tr>

<tr>
<td valign="top" ><p>element_where</p></td>
<td valign="top" ><p>Where</p></td>
<td valign="top" ><p>Значение Where в предложении join</p></td>
</tr>

<tr>
<td valign="top" ><p>element_cols</p></td>
<td valign="top" ><p>Колонок</p></td>
<td valign="top" ><p>Значение атрибута cols для textarea</p></td>
</tr>

<tr>
<td valign="top" ><p>element_rows</p></td>
<td valign="top" ><p>Строк</p></td>
<td valign="top" ><p>Значение атрибута rows для textarea</p></td>
</tr>

<tr>
<td valign="top" ><p>element_size</p></td>
<td valign="top" ><p>Size</p></td>
<td valign="top" ><p>атрибута size для ввода типа text и компонент SelectOneListbox и SelectManyListbox</p></td>
</tr>

<tr>
<td valign="top" ><p>element_maxlength</p></td>
<td valign="top" ><p>Maxlength</p></td>
<td valign="top" ><p>атрибута maxlength для ввода типа text</p></td>
</tr>

<tr>
<td valign="top" ><p>element_renderer</p></td>
<td valign="top" ><p>Визуализатор</p></td>
<td valign="top" ><p>Визуализатор элемента</p></td>
</tr>

<tr>
<td valign="top" ><p>element_converter</p></td>
<td valign="top" ><p>Конвертер</p></td>
<td valign="top" ><p>Конвертер элемента</p></td>
</tr>

<tr>
<td valign="top" ><p>element_readonly</p></td>
<td valign="top" ><p>Readonly</p></td>
<td valign="top" ><p>Признак Readonly</p></td>
</tr>

<tr>
<td valign="top" ><p>element_id</p></td>
<td valign="top" ><p>Id</p></td>
<td valign="top" ><p>атрибут Id ввода</p></td>
</tr>

<tr>
<td valign="top" ><p>element_value</p></td>
<td valign="top" ><p>Значение</p></td>
<td valign="top" ><p>Значение элемента</p></td>
</tr>

<tr>
<td valign="top" ><p>element_tabindex</p></td>
<td valign="top" ><p>Tabindex</p></td>
<td valign="top" ><p>атрибут Tabindex</p></td>
</tr>

<tr>
<td valign="top" ><p>element_accesskey</p></td>
<td valign="top" ><p>Accesskey</p></td>
<td valign="top" ><p>атрибут Accesskey</p></td>
</tr>

<tr>
<td valign="top" ><p>element_sequence</p></td>
<td valign="top" ><p>Последовательность</p></td>
<td valign="top" ><p>Последовательность, используемая для генерации значений поля. Зарезервировано для будущего использования в СУБД Oracle</p></td>
</tr>

<tr>
<td valign="top" ><p>element_path</p></td>
<td valign="top" ><p>Каталог загрузки</p></td>
<td valign="top" ><p>Каталог загрузки файла</p></td>
</tr>

<tr>
<td valign="top" ><p>element_filesize</p></td>
<td valign="top" ><p>Filesize</p></td>
<td valign="top" ><p>Максимальный размер загружаемого файла</p></td>
</tr>

<tr>
<td valign="top" ><p>element_file_extension</p></td>
<td valign="top" ><p>Extensions</p></td>
<td valign="top" ><p>Возможные расширения загружаемого файла</p></td>
</tr>

<tr>
<td valign="top" ><p>element_filename</p></td>
<td valign="top" ><p>Filename</p></td>
<td valign="top" ><p>Способ формирования названия загружаемого файла</p></td>
</tr>

<tr>
<td valign="top" ><p>element_width</p></td>
<td valign="top" ><p>Ширина</p></td>
<td valign="top" ><p>Ширина загружаемого рисунка- зарезервировано для использование в будущем</p></td>
</tr>

<tr>
<td valign="top" ><p>element_height</p></td>
<td valign="top" ><p>Высота </p></td>
<td valign="top" ><p>Высота загружаемого рисунка-зарезервировано для использование в будущем</p></td>
</tr>

<tr>
<td valign="top" ><p>element_trim</p></td>
<td valign="top" ><p>Удалять пробелы ?</p></td>
<td valign="top" ><p>Признак удаления концевых пробелов</p></td>
</tr>

</tbody>
</table>

<p><b>Конфигурирование кнопок</b></p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>Поле</p></td>
<td valign="top" ><p>ярлык</p></td>
<td valign="top" ><p>назначение</p></td>
</tr>

<tr>
<td valign="top" ><p>element_action</p></td>
<td valign="top" ><p>Действие</p></td>
<td valign="top" ><p>Действие, инициируемое кнопкой</p></td>
</tr>

<tr>
<td valign="top" ><p>element_event</p></td>
<td valign="top" ><p>Событие</p></td>
<td valign="top" ><p>Событие, генерируемое после завершения действия</p></td>
</tr>

<tr>
<td valign="top" ><p>element_confirm</p></td>
<td valign="top" ><p>Подтвердить?</p></td>
<td valign="top" ><p>Признак подтверждения действия при нажатии кнопки</p></td>
</tr>

<tr>
<td valign="top" ><p>element_file</p></td>
<td valign="top" ><p>Image</p></td>
<td valign="top" ><p>Название рисунка для кнопки</p></td>
</tr>

<tr>
<td valign="top" ><p>element_component</p></td>
<td valign="top" ><p>Компонент</p></td>
<td valign="top" ><p>Компонент кнопки</p></td>
</tr>

<tr>
<td valign="top" ><p>element_index</p></td>
<td valign="top" ><p>Индекс</p></td>
<td valign="top" ><p>Индекс вывода кнопки</p></td>
</tr>

<tr>
<td valign="top" ><p>element_name</p></td>
<td valign="top" ><p>Атрибут name</p></td>
<td valign="top" ><p>Атрибут name</p></td>
</tr>

<tr>
<td valign="top" ><p>element_renderer</p></td>
<td valign="top" ><p>Визуализатор</p></td>
<td valign="top" ><p>Визуализатор кнопки</p></td>
</tr>

<tr>
<td valign="top" ><p>element_id</p></td>
<td valign="top" ><p>Id</p></td>
<td valign="top" ><p>Атрибут Id</p></td>
</tr>

<tr>
<td valign="top" ><p>element_value</p></td>
<td valign="top" ><p>Значение</p></td>
<td valign="top" ><p>Атрибут value</p></td>
</tr>

<tr>
<td valign="top" ><p>element_tabindex</p></td>
<td valign="top" ><p>Tabindex</p></td>
<td valign="top" ><p>Атрибут Tabindex</p></td>
</tr>

<tr>
<td valign="top" ><p>element_accesskey</p></td>
<td valign="top" ><p>Accesskey</p></td>
<td valign="top" ><p>Атрибут Accesskey</p></td>
</tr>

</tbody>
</table>

<p>Кнопки формы ввода не должны иметь значения атрибута «Действие», равные «Очистить фильтр» или «Установить фильтр», которые предназначены для форм поиска.</p>

<p><b>Конфигурирование псевдо-компонента ElementTableJoiner</b></p>

<p>Данный псевдо-компонент был введен для решения следующей проблемы.</p>

<p>Предположим нам нужно создать форму ввода в таблицу инвойсов по компаниям. Кроме таблицы инвойсов, у нас есть также справочники компаний, стран и регионов. Компании привязаны к странам, а страны к регионам.</p>

<p>Компания для инвойса должна выбираться из списка компаний. Справочник компаний содержит большое количество записей. Поэтому ввод компании из большого списка не очень удобен. С целью сокращения опций списка ввод компании удобно сделать с помощью цепочки зависимых select:</p>

<p>Выбрать регион</p>

<p>Выбрать страну из региона</p>

<p>Выбрать компанию из страны</p>

<p>Однако таблица инвойсов не содержит коды регионов и стран. Справочник компаний не содержит кода региона. Поэтому для получения нужных данных нам нужно подсоединить к таблице инвойсов справочники компаний, стран и регионов. </p>

<p>Эту задачу и решает псевдо-компонент <b>ElementTableJoiner</b>, определяемый следующими атрибутами:</p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>поле</p></td>
<td valign="top" ><p>ярлык</p></td>
<td valign="top" ><p>назначение</p></td>
</tr>

<tr>
<td valign="top" ><p>element_table</p></td>
<td valign="top" ><p>Таблица</p></td>
<td valign="top" ><p>Подсоединяемая таблица</p></td>
</tr>

<tr>
<td valign="top" ><p>element_table_alias</p></td>
<td valign="top" ><p>Алиас таблицы</p></td>
<td valign="top" ><p>Алиас подсоединяемой таблицы</p></td>
</tr>

<tr>
<td valign="top" ><p>element_field</p></td>
<td valign="top" ><p>Первичный ключ</p></td>
<td valign="top" ><p>Первичный ключ подсоединяемой таблицы</p></td>
</tr>

<tr>
<td valign="top" ><p>element_alias</p></td>
<td valign="top" ><p>Алиас</p></td>
<td valign="top" ><p>Алиас первичного ключа</p></td>
</tr>

<tr>
<td valign="top" ><p>element_left_table</p></td>
<td valign="top" ><p>Таблица слева</p></td>
<td valign="top" ><p>Таблица слева</p></td>
</tr>

<tr>
<td valign="top" ><p>element_left_alias</p></td>
<td valign="top" ><p>Алиас таблицы слева</p></td>
<td valign="top" ><p>Алиас таблицы слева</p></td>
</tr>

<tr>
<td valign="top" ><p>element_left_foreign_key</p></td>
<td valign="top" ><p>Внешний ключ таблицы слева</p></td>
<td valign="top" ><p>Внешний ключ таблицы слева</p></td>
</tr>

<tr>
<td valign="top" ><p>element_where</p></td>
<td valign="top" ><p>Where</p></td>
<td valign="top" ><p>Зарезервировано</p></td>
</tr>

</tbody>
</table>

<p><b>Конфигурирование атрибутов Ajax</b></p>

<p>Конфигурирование атрибутов Ajax необходимо для следующих элементов ввода:</p>

<ul>
<li>Компонентом элемента ввода является InputAutocomplete или InputMultipleAutocomplete </li>
<li>Значение элемента ввода необходимо передавать в Ajax запросе для другого элемента ввода с компонентом InputAutocomplete</li>
<li>Элемент ввода участвует в цепочке зависимых элементов типа select (chained select) либо как участник, либо как параметр</li>
</ul>

<p>В одной форме может быть несколько элементов ввода с компонентом InputAutocomplete или InputMultipleAutocomplete . Поэтому необходимо указывать номер autocomplete, в котором участвует элемент ввода либо как участник, либо как параметр.</p>

<p>Поскольку в одной форме также может быть несколько цепочек зависимых select, то необходимо указывать номер цепочки, в котором участвует элемент ввода. </p>

<p>Нумерацию autocomplete и цепочек зависимых элементов типа select нужно начинать с 0.</p>

<p>Один и тот же элемент может участвовать в нескольких autocomplete в качестве параметра. В этом случае номера соответствующих элементов autocomplete нужно перечислять через запятую.</p>

<p>Аналогично один и тот же элемент может участвовать в нескольких цепочках зависимых select и номера соответствующих цепочек также нужно перечислять через запятую</p>

<p><b>Конфигурирование атрибутов Ajax для компонентов InputAutocomplete и InputMultipleAutocomplete</b></p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>Поле</p></td>
<td valign="top" ><p>ярлык</p></td>
<td valign="top" ><p>назначение</p></td>
</tr>

<tr>
<td valign="top" ><p>element_method</p></td>
<td valign="top" ><p>Метод</p></td>
<td valign="top" ><p>Метод посылки запроса</p></td>
</tr>

<tr>
<td valign="top" ><p>element_autocomplete</p></td>
<td valign="top" ><p>Номер autocomplete</p></td>
<td valign="top" ><p>Номер autocomplete, в котором участвует элемент ввода</p></td>
</tr>

<tr>
<td valign="top" ><p>element_token</p></td>
<td valign="top" ><p>Токен</p></td>
<td valign="top" ><p>Токен для разделения значений для компонента InputMultipleAutocomplete</p></td>
</tr>

<tr>
<td valign="top" ><p>element_search_field</p></td>
<td valign="top" ><p>Поле поиска</p></td>
<td valign="top" ><p>Поле таблицы списка, в котором осуществляется поиск введенных символов </p></td>
</tr>

<tr>
<td valign="top" ><p>element_min_chars</p></td>
<td valign="top" ><p>Минимум символов для запроса</p></td>
<td valign="top" ><p>Минимальное количество введенных символов, необходимое для посылки запроса </p></td>
</tr>

<tr>
<td valign="top" ><p>element_max_options</p></td>
<td valign="top" ><p>Максимум опций списка</p></td>
<td valign="top" ><p>Максимум опций списка, который должен возвратить сервер в запросе </p></td>
</tr>

<tr>
<td valign="top" ><p>element_chain</p></td>
<td valign="top" ><p>Цепочка select</p></td>
<td valign="top" ><p>Номер цепочки select, в которой участвует элемент ввода</p></td>
</tr>

<tr>
<td valign="top" ><p>element_tier</p></td>
<td valign="top" ><p>Уровень в цепочке select</p></td>
<td valign="top" ><p>Номер уровня цепочки select, на котором участвует элемент ввода</p></td>
</tr>

<tr>
<td valign="top" ><p>element_before_request</p></td>
<td valign="top" ><p>Функция до запроса</p></td>
<td valign="top" ><p>Функция, которую нужно вызвать до посылки запроса</p></td>
</tr>

<tr>
<td valign="top" ><p>element_after_request</p></td>
<td valign="top" ><p>Функция после запроса</p></td>
<td valign="top" ><p>Функция, которую нужно вызвать после посылки запроса</p></td>
</tr>

<tr>
<td valign="top" ><p>element_url</p></td>
<td valign="top" ><p>URL</p></td>
<td valign="top" ><p>URL запроса. Если не указан, то для autocomplete используется autocomplete.php</p></td>
</tr>

<tr>
<td valign="top" ><p>element_callback</p></td>
<td valign="top" ><p>Функция callback</p></td>
<td valign="top" ><p>Функция callback запроса</p></td>
</tr>

<tr>
<td valign="top" ><p>element_timeout</p></td>
<td valign="top" ><p>Timeout</p></td>
<td valign="top" ><p>Время ожидания после нажатия символа, после которого посылается запрос </p></td>
</tr>

</tbody>
</table>

<p><b>Конфигурирование атрибутов Ajax для компонента типа select участвующего либо как параметр компонента InputAutocomplete или InputMultipleAutocomplete, либо в цепочке зависимых элементов (chained select) либо как участник, либо как параметр</b></p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>Поле</p></td>
<td valign="top" ><p>ярлык</p></td>
<td valign="top" ><p>назначение</p></td>
</tr>

<tr>
<td valign="top" ><p>element_method</p></td>
<td valign="top" ><p>Метод</p></td>
<td valign="top" ><p>Метод посылки запроса</p></td>
</tr>

<tr>
<td valign="top" ><p>element_autocomplete</p></td>
<td valign="top" ><p>Номер autocomplete</p></td>
<td valign="top" ><p>Номер autocomplete, в котором участвует элемент ввода</p></td>
</tr>

<tr>
<td valign="top" ><p>element_chain</p></td>
<td valign="top" ><p>Цепочка select</p></td>
<td valign="top" ><p>Номер цепочки select, в которой участвует элемент ввода</p></td>
</tr>

<tr>
<td valign="top" ><p>element_tier</p></td>
<td valign="top" ><p>Уровень в цепочке select</p></td>
<td valign="top" ><p>Номер уровня цепочки select, на котором участвует элемент ввода</p></td>
</tr>

<tr>
<td valign="top" ><p>element_chain_role</p></td>
<td valign="top" ><p>Роль в цепочке select</p></td>
<td valign="top" ><p>Роль, которую играет элемент ввода в цепочке select</p></td>
</tr>

<tr>
<td valign="top" ><p>element_before_request</p></td>
<td valign="top" ><p>Функция до запроса</p></td>
<td valign="top" ><p>Функция, которую нужно вызвать до посылки запроса</p></td>
</tr>

<tr>
<td valign="top" ><p>element_after_request</p></td>
<td valign="top" ><p>Функция после запроса</p></td>
<td valign="top" ><p>Функция, которую нужно вызвать после посылки запроса</p></td>
</tr>

<tr>
<td valign="top" ><p>element_url</p></td>
<td valign="top" ><p>URL</p></td>
<td valign="top" ><p>URL запроса. Если не указан, то для chained select используется list.php</p></td>
</tr>

<tr>
<td valign="top" ><p>element_callback</p></td>
<td valign="top" ><p>Функция callback</p></td>
<td valign="top" ><p>Функция callback запроса</p></td>
</tr>

</tbody>
</table>

<p><b>Конфигурирование событий</b></p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>Поле</p></td>
<td valign="top" ><p>ярлык</p></td>
<td valign="top" ><p>назначение</p></td>
</tr>

<tr>
<td valign="top" ><p>element_onblur</p></td>
<td valign="top" ><p>onblur</p></td>
<td valign="top" ><p>Действие при событии onblur</p></td>
</tr>

<tr>
<td valign="top" ><p>element_onchange</p></td>
<td valign="top" ><p>onchange</p></td>
<td valign="top" ><p>Действие при событии onchange</p></td>
</tr>

<tr>
<td valign="top" ><p>element_onclick</p></td>
<td valign="top" ><p>onclick</p></td>
<td valign="top" ><p>Действие при событии onclick</p></td>
</tr>

<tr>
<td valign="top" ><p>element_ondblclick</p></td>
<td valign="top" ><p>ondblclick</p></td>
<td valign="top" ><p>Действие при событии ondblclick</p></td>
</tr>

<tr>
<td valign="top" ><p>element_onfocus</p></td>
<td valign="top" ><p>onfocus</p></td>
<td valign="top" ><p>Действие при событии onfocus</p></td>
</tr>

<tr>
<td valign="top" ><p>element_onkeydown</p></td>
<td valign="top" ><p>onkeydown</p></td>
<td valign="top" ><p>Действие при событии onkeydown</p></td>
</tr>

<tr>
<td valign="top" ><p>element_onkeypress</p></td>
<td valign="top" ><p>onkeypress</p></td>
<td valign="top" ><p>Действие при событии onkeypress</p></td>
</tr>

<tr>
<td valign="top" ><p>element_onkeyup</p></td>
<td valign="top" ><p>onkeyup</p></td>
<td valign="top" ><p>Действие при событии onkeyup</p></td>
</tr>

<tr>
<td valign="top" ><p>element_onmousedown</p></td>
<td valign="top" ><p>onmousedown</p></td>
<td valign="top" ><p>Действие при событии onmousedown</p></td>
</tr>

<tr>
<td valign="top" ><p>element_onmousemove</p></td>
<td valign="top" ><p>onmousemove</p></td>
<td valign="top" ><p>Действие при событии onmousemove</p></td>
</tr>

<tr>
<td valign="top" ><p>element_onmouseout</p></td>
<td valign="top" ><p>onmouseout</p></td>
<td valign="top" ><p>Действие при событии onmouseout</p></td>
</tr>

<tr>
<td valign="top" ><p>element_onmouseover</p></td>
<td valign="top" ><p>onmouseover</p></td>
<td valign="top" ><p>Действие при событии onmouseover</p></td>
</tr>

<tr>
<td valign="top" ><p>element_onmouseup</p></td>
<td valign="top" ><p>onmouseup</p></td>
<td valign="top" ><p>Действие при событии onmouseup</p></td>
</tr>

<tr>
<td valign="top" ><p>element_onselect</p></td>
<td valign="top" ><p>onselect</p></td>
<td valign="top" ><p>Действие при событии onselect</p></td>
</tr>

<tr>
<td valign="top" ><p>element_onblur</p></td>
<td valign="top" ><p>onblur</p></td>
<td valign="top" ><p>Действие при событии onblur</p></td>
</tr>

</tbody>
</table>

<p><b>Конфигурирование валидаторов формы</b></p>

<p>Для конфигурирования валидаторов формы нужно выбрать действие «валидатор» для нужной формы. </p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>Поле</p></td>
<td valign="top" ><p>ярлык</p></td>
<td valign="top" ><p>назначение</p></td>
</tr>

<tr>
<td valign="top" ><p>validator_field</p></td>
<td valign="top" ><p>Поле</p></td>
<td valign="top" ><p>Проверяемое поле формы. Если поле разное для разных языков, то можно часть названия поля, соответствующее коду языка заменить на xxx. При экспорте конфигуратор заменит xxx на код соответствующего языка</p></td>
</tr>

<tr>
<td valign="top" ><p>validator_condition</p></td>
<td valign="top" ><p>Условие</p></td>
<td valign="top" ><p>Условие, которому должно удовлетворять введенное значение поля</p></td>
</tr>

<tr>
<td valign="top" ><p>validator_parameter</p></td>
<td valign="top" ><p>Параметер</p></td>
<td valign="top" ><p>Параметр условия</p></td>
</tr>

<tr>
<td valign="top" ><p>validator_parameter_type</p></td>
<td valign="top" ><p>Тип параметра</p></td>
<td valign="top" ><p>Тип параметра условия</p></td>
</tr>

<tr>
<td valign="top" ><p>validator_error</p></td>
<td valign="top" ><p>Ошибка</p></td>
<td valign="top" ><p>Аббревиатура сообщения, которая описывает ошибку ввода</p></td>
</tr>

<tr>
<td valign="top" ><p>validator_class</p></td>
<td valign="top" ><p>Класс</p></td>
<td valign="top" ><p>Класс нестандартного условия</p></td>
</tr>

<tr>
<td valign="top" ><p>validator_class_static</p></td>
<td valign="top" ><p>Статический метод ?</p></td>
<td valign="top" ><p>Тип метода нестандартного условия</p></td>
</tr>

<tr>
<td valign="top" ><p>validator_break_onfailure</p></td>
<td valign="top" ><p>Прекратить при ошибке</p></td>
<td valign="top" ><p>Признак прекращения валидации поля при возникновении ошибки ввода</p></td>
</tr>

<tr>
<td valign="top" ><p>validator_index</p></td>
<td valign="top" ><p>Index</p></td>
<td valign="top" ><p>Порядок проверки валидатора</p></td>
</tr>

</tbody>
</table>

<p>При экспорте спецификации формы все валидаторы, относящиеся к одному поля ввода экспортируются в спецификацию этого поля. Поэтому поля «validator_index» и «validator_break_onfailure» будет иметь значение только при наличии нескольких валидаторов для одного и того же поля ввода.</p>

<p>Для правильного конфигурирования валидаторов нужно знать, как происходит процесс валидации в форме и процесс экспорта валидаторов. Происходит это следующим образом:</p>

<p>Компонент Form в цикле вызывает метод валидации (validate) всех своих элементов ввода, в который передает formValue - ассоциативный массив значений всех элементов ввода, а также код формы в элементе массива с индексом «xxx_sid» и режим формы в элементе массива с индексом «xxx_mode». Элемент ввода в свою очередь организует цикл проверки по всем своим валидаторам. Если указан класс нестандартного валидатора, то вызывается статический метод «test» компонента Validator и компонента <b>ConditionTester</b> в противном случае. При этом в метод «test» компонента Validator передается данные самого валидатора и массив formValue, а в в метод «test» компонента <b>ConditionTester</b> массив утверждений и массив formValue. </p>

<p>Рассмотрим, как нужно сконфигурировать валидатор и процесс экспорта валидатора для нескольких вариантов</p>

<p><b>Вариант 1</b>- значение одного поля field1 должно быть равно значению другого поля field2. </p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>Поле</p></td>
<td valign="top" ><p>ярлык</p></td>
<td valign="top" ><p>значение</p></td>
</tr>

<tr>
<td valign="top" ><p>validator_field</p></td>
<td valign="top" ><p>Поле</p></td>
<td valign="top" ><p>field1</p></td>
</tr>

<tr>
<td valign="top" ><p>validator_condition</p></td>
<td valign="top" ><p>Условие</p></td>
<td valign="top" ><p>Equal</p></td>
</tr>

<tr>
<td valign="top" ><p>validator_parameter</p></td>
<td valign="top" ><p>Параметер</p></td>
<td valign="top" ><p>field2</p></td>
</tr>

<tr>
<td valign="top" ><p>validator_parameter_type</p></td>
<td valign="top" ><p>Тип параметра</p></td>
<td valign="top" ><p>элемент ввода</p></td>
</tr>

</tbody>
</table>

<p>Условие Equal состоит из одного утверждения, которое сконфигурировано следующим образом:</p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>поле</p></td>
<td valign="top" ><p>ярлык</p></td>
<td valign="top" ><p>значение</p></td>
</tr>

<tr>
<td valign="top" ><p>statement_connector</p></td>
<td valign="top" ><p>Коннектор</p></td>
<td valign="top" ><p>И</p></td>
</tr>

<tr>
<td valign="top" ><p>statement_function</p></td>
<td valign="top" ><p>Функция</p></td>
<td valign="top" > </td>
</tr>

<tr>
<td valign="top" ><p>statement_operand1</p></td>
<td valign="top" ><p>Operand 1</p></td>
<td valign="top" ><p>%statement_operand1</p></td>
</tr>

<tr>
<td valign="top" ><p>statement_operator</p></td>
<td valign="top" ><p>Оператор</p></td>
<td valign="top" ><p>равно</p></td>
</tr>

<tr>
<td valign="top" ><p>statement_operand2</p></td>
<td valign="top" ><p>Operand 2</p></td>
<td valign="top" ><p>%statement_operand2</p></td>
</tr>

<tr>
<td valign="top" ><p>statement_failure</p></td>
<td valign="top" ><p>Failure</p></td>
<td valign="top" ><p>Ошибка при не выполнении</p></td>
</tr>

<tr>
<td valign="top" ><p>statement_group</p></td>
<td valign="top" ><p>Группа</p></td>
<td valign="top" > </td>
</tr>

<tr>
<td valign="top" ><p>statement_index</p></td>
<td valign="top" ><p>Index</p></td>
<td valign="top" ><p>0</p></td>
</tr>

</tbody>
</table>

<p>При экспорте утверждения значение «%statement_operand1» заменяется на «&amp;arg field1», а значение «%statement_operand2» заменяется на «&amp;arg field2».</p>

<p>Рассмотрим теперь как проверяется это утверждение в компоненте <b>ConditionTester</b> : </p>

<p>Для получения значений операндов 1 и 2 используется статический метод get компонента Evaluator, в который передается как оцениваемое значение так массив formValue, который как сказано ранее также передается компоненту <b>ConditionTester</b>. Компонент Evaluator по значению «&amp;arg field1» возвращает значение массива formValue с индексом field1, а по значению «&amp;arg field2» возвращает значение массива formValue с индексом field2:</p>

<p>$operand1=$formValue[field1];</p>

<p>$operand2=$formValue[field2];</p>

<p>Далее компонент <b>ConditionTester</b> возвращает результат проверки логического выражения:</p>

<p>($operand1==$operand2)</p>

<p><b>Вариант 2</b>- значение одного поля field1 должно быть меньше некоторого значения MaxValue</p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>Поле</p></td>
<td valign="top" ><p>ярлык</p></td>
<td valign="top" ><p>значение</p></td>
</tr>

<tr>
<td valign="top" ><p>validator_field</p></td>
<td valign="top" ><p>Поле</p></td>
<td valign="top" ><p>field1</p></td>
</tr>

<tr>
<td valign="top" ><p>validator_condition</p></td>
<td valign="top" ><p>Условие</p></td>
<td valign="top" ><p>Less</p></td>
</tr>

<tr>
<td valign="top" ><p>validator_parameter</p></td>
<td valign="top" ><p>Параметер</p></td>
<td valign="top" ><p>MaxValue</p></td>
</tr>

<tr>
<td valign="top" ><p>validator_parameter_type</p></td>
<td valign="top" ><p>Тип параметра</p></td>
<td valign="top" ><p>скалярное значение</p></td>
</tr>

</tbody>
</table>

<p>Условие Less состоит из одного утверждения, которое сконфигурировано следующим образом:</p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>поле</p></td>
<td valign="top" ><p>ярлык</p></td>
<td valign="top" ><p>значение</p></td>
</tr>

<tr>
<td valign="top" ><p>statement_connector</p></td>
<td valign="top" ><p>Коннектор</p></td>
<td valign="top" ><p>И</p></td>
</tr>

<tr>
<td valign="top" ><p>statement_function</p></td>
<td valign="top" ><p>Функция</p></td>
<td valign="top" > </td>
</tr>

<tr>
<td valign="top" ><p>statement_operand1</p></td>
<td valign="top" ><p>Operand 1</p></td>
<td valign="top" ><p>%statement_operand1</p></td>
</tr>

<tr>
<td valign="top" ><p>statement_operator</p></td>
<td valign="top" ><p>Оператор</p></td>
<td valign="top" ><p>меньше</p></td>
</tr>

<tr>
<td valign="top" ><p>statement_operand2</p></td>
<td valign="top" ><p>Operand 2</p></td>
<td valign="top" ><p>%statement_operand2</p></td>
</tr>

<tr>
<td valign="top" ><p>statement_failure</p></td>
<td valign="top" ><p>Failure</p></td>
<td valign="top" ><p>Ошибка при не выполнении</p></td>
</tr>

<tr>
<td valign="top" ><p>statement_group</p></td>
<td valign="top" ><p>Группа</p></td>
<td valign="top" > </td>
</tr>

<tr>
<td valign="top" ><p>statement_index</p></td>
<td valign="top" ><p>Index</p></td>
<td valign="top" ><p>0</p></td>
</tr>

</tbody>
</table>

<p>При экспорте утверждения значение «%statement_operand1» заменяется на «&amp;arg field1», а значение «%statement_operand2» заменяется на MaxValue</p>

<p>Значения операндов 1 и 2 с помощью компонента Evaluator получаются следующими:</p>

<p>$operand1=$formValue[field1];</p>

<p>$operand2 =MaxValue</p>

<p>Далее компонент <b>ConditionTester</b> возвращает результат проверки логического выражения:</p>

<p>($operand1&lt;$operand2)</p>

<p><b>Вариант 3</b>- значение одного поля field1 должно быть в некотором интервале от MinValue до MaxValue </p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>Поле</p></td>
<td valign="top" ><p>ярлык</p></td>
<td valign="top" ><p>значение</p></td>
</tr>

<tr>
<td valign="top" ><p>validator_field</p></td>
<td valign="top" ><p>Поле</p></td>
<td valign="top" ><p>field1</p></td>
</tr>

<tr>
<td valign="top" ><p>validator_condition</p></td>
<td valign="top" ><p>Условие</p></td>
<td valign="top" ><p>Range</p></td>
</tr>

<tr>
<td valign="top" ><p>validator_parameter</p></td>
<td valign="top" ><p>Параметер</p></td>
<td valign="top" ><p>‘min’=&gt;MinValue,’max’=&gt; MaxValue</p></td>
</tr>

<tr>
<td valign="top" ><p>validator_parameter_type</p></td>
<td valign="top" ><p>Тип параметра</p></td>
<td valign="top" ><p>массив</p></td>
</tr>

</tbody>
</table>

<p>Условие Range состоит из одного утверждения, которое сконфигурировано следующим образом:</p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>поле</p></td>
<td valign="top" ><p>ярлык</p></td>
<td valign="top" ><p>значение</p></td>
</tr>

<tr>
<td valign="top" ><p>statement_connector</p></td>
<td valign="top" ><p>Коннектор</p></td>
<td valign="top" ><p>И</p></td>
</tr>

<tr>
<td valign="top" ><p>statement_function</p></td>
<td valign="top" ><p>Функция</p></td>
<td valign="top" > </td>
</tr>

<tr>
<td valign="top" ><p>statement_operand1</p></td>
<td valign="top" ><p>Operand 1</p></td>
<td valign="top" ><p>%statement_operand1</p></td>
</tr>

<tr>
<td valign="top" ><p>statement_operator</p></td>
<td valign="top" ><p>Оператор</p></td>
<td valign="top" ><p>диапазон</p></td>
</tr>

<tr>
<td valign="top" ><p>statement_operand2</p></td>
<td valign="top" ><p>Operand 2</p></td>
<td valign="top" ><p>%statement_operand2</p></td>
</tr>

<tr>
<td valign="top" ><p>statement_failure</p></td>
<td valign="top" ><p>Failure</p></td>
<td valign="top" ><p>Ошибка при не выполнении</p></td>
</tr>

<tr>
<td valign="top" ><p>statement_group</p></td>
<td valign="top" ><p>Группа</p></td>
<td valign="top" > </td>
</tr>

<tr>
<td valign="top" ><p>statement_index</p></td>
<td valign="top" ><p>Index</p></td>
<td valign="top" ><p>0</p></td>
</tr>

</tbody>
</table>

<p>При экспорте утверждения значение «%statement_operand1» заменяется на «&amp;arg field1», а значение «%statement_operand2» заменяется на array(‘min’=&gt;MinValue,’max’=&gt; MaxValue)</p>

<p>Значения операндов 1 и 2 с помощью компонента Evaluator получаются следующими:</p>

<p>$operand1=$formValue[‘field1’];</p>

<p>$operand2= array(‘min’=&gt;MinValue,’max’=&gt; MaxValue);</p>

<p>Далее компонент <b>ConditionTester</b> возвращает результат проверки логического выражения:</p>

<p>($operand1&gt;=$operand2['min']&amp;&amp;$operand1&lt;=$operand2['max'])</p>

<p><b>Конфигурирование фильтров формы</b></p>

<p>Для конфигурирования фильтров формы нужно выбрать действие «фильтр» для нужной формы. </p>

<p>Фильтры могут быть как с условием, так и без. Фильтры без условия применяются всегда. Фильтры с условием применяются, если условие оказалось правильным. В связи с этим конфигурирование фильтров делится на конфигурирование самого фильтра и конфигурирование условия фильтрации:</p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>Поле</p></td>
<td valign="top" ><p>ярлык</p></td>
<td valign="top" ><p>назначение</p></td>
</tr>

<tr>
<td valign="top" ><p>filter_field</p></td>
<td valign="top" ><p>Поле</p></td>
<td valign="top" ><p>поле формы, подлежащее фильтрации. Если поле разное для разных языков, то можно часть названия поля, соответствующее коду языка заменить на xxx. При экспорте конфигуратор заменит xxx на код соответствующего языка</p></td>
</tr>

<tr>
<td valign="top" ><p>filter_converter</p></td>
<td valign="top" ><p>конвертер</p></td>
<td valign="top" ><p>Конвертер, применяемый к полю</p></td>
</tr>

<tr>
<td valign="top" ><p>filter_parameter</p></td>
<td valign="top" ><p>Параметер</p></td>
<td valign="top" ><p>Параметр фильтрации</p></td>
</tr>

<tr>
<td valign="top" ><p>filter_parameter_type</p></td>
<td valign="top" ><p>Тип параметра</p></td>
<td valign="top" ><p>Тип параметра фильтрации</p></td>
</tr>

<tr>
<td valign="top" ><p>filter_index</p></td>
<td valign="top" ><p>Индекс</p></td>
<td valign="top" ><p>Порядок применения фильтра</p></td>
</tr>

<tr>
<td valign="top" ><p>filter_condition</p></td>
<td valign="top" ><p>Условие</p></td>
<td valign="top" ><p>Условие, которое нужно проверить до фильтрации</p></td>
</tr>

<tr>
<td valign="top" ><p>filter_condition_field</p></td>
<td valign="top" ><p>Поле условия</p></td>
<td valign="top" ><p>Проверяемое поле формы</p></td>
</tr>

<tr>
<td valign="top" ><p>filter_condition_parameter</p></td>
<td valign="top" ><p>Параметр условия</p></td>
<td valign="top" ><p>Параметр условия</p></td>
</tr>

<tr>
<td valign="top" ><p>filter_condition_parameter_type</p></td>
<td valign="top" ><p>Тип параметр условия</p></td>
<td valign="top" ><p>Тип параметра условия</p></td>
</tr>

<tr>
<td valign="top" ><p>filter_condition_class</p></td>
<td valign="top" ><p>Класс условия</p></td>
<td valign="top" ><p>Класс нестандартного условия</p></td>
</tr>

<tr>
<td valign="top" ><p>filter_condition_class_static</p></td>
<td valign="top" ><p>Статический метод ?</p></td>
<td valign="top" ><p>Тип метода нестандартного условия</p></td>
</tr>

</tbody>
</table>

<p>Конфигурирование условия фильтрации ничем не отличается от конфигурирования валидаторов.</p>

<p>На одно и то же поле можно установить несколько фильтров, поэтому значение индекса имеет значение только при наличии нескольких фильтров для одного и того же поля ввода.</p>

<p>Процесс фильтрации введенных данных происходит после валидации данных:</p>

<p>Компонент Form в цикле вызывает метод фильтрации (filter) всех своих элементов ввода, в который передает formValue - ассоциативный массив значений всех элементов ввода, а также код формы в элементе массива с индексом «xxx_sid» и режим формы в элементе массива с индексом «xxx_mode». Элемент ввода в свою очередь организует цикл фильтрации по всем своим фильтрам с помощью компонента Converter, в который передается значение фильтруемого поля, данные используемого фильтра и массив formValue. </p>

<h1>Конфигурирование форм поиска (Searchs)</h1>

<p>Для конфигурирования форм поиска нужно выбрать пункт меню Спецификация-&gt;Форма поиска.</p>

<p>Спецификации форм поиска хранятся в тех же 4 таблицах, что и формы ввода: «fgs_form», являющейся мастер таблицей для 3 таблиц «fgs_element», «fgs_validator» и «fgs_filter». В таблице «fgs_element» хранятся спецификации предикатов поиска, в таблице «fgs_validator» - валидаторы, а в таблице «fgs_filter» -фильтры вводимых данных. </p>

<p>В связи с тем, что общая информация о формах вода и поиска хранятся в одной и той же таблице и код идентификатора формы должен быть уникальным, то для форм поиска рекомендуется присваивать идентификаторы, начинающиеся с «Search».</p>

<p>Конфигурирование форм поиска во многом аналогично формам ввода. </p>

<p>Конфигурирование формы поиска заключается во вводе следующих данных:</p>

<ul>
<li>Общие данные самой формы поиска</li>
<li>Данные элементов и кнопок формы поиска</li>
<li>Данные валидаторов вводимых данных</li>
<li>Данные фильтров вводимых данных</li>
</ul>

<p><b>Общие данные формы поиска:</b></p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>поле</p></td>
<td valign="top" ><p>ярлык</p></td>
<td valign="top" ><p>назначение</p></td>
</tr>

<tr>
<td valign="top" ><p>form_system</p></td>
<td valign="top" ><p>System ?</p></td>
<td valign="top" ><p>Признак отношения формы поиска к конфигуратору. Для форм поиска разрабатываемого приложения должен быть установлен в «нет»</p></td>
</tr>

<tr>
<td valign="top" ><p>form_type</p></td>
<td valign="top" ><p>Тип</p></td>
<td valign="top" ><p>Тип формы. Для форм разрабатываемого приложения должен быть установлен в «поиск прикладной»</p></td>
</tr>

<tr>
<td valign="top" ><p>form_table</p></td>
<td valign="top" ><p>Таблица</p></td>
<td valign="top" ><p>Таблица формы</p></td>
</tr>

<tr>
<td valign="top" ><p>form_sid</p></td>
<td valign="top" ><p>Sid</p></td>
<td valign="top" ><p>Код формы</p></td>
</tr>

<tr>
<td valign="top" ><p>form_title</p></td>
<td valign="top" ><p>Название</p></td>
<td valign="top" ><p>Название формы</p></td>
</tr>

<tr>
<td valign="top" ><p>form_action</p></td>
<td valign="top" ><p>Действие</p></td>
<td valign="top" ><p>Атрибут «action» формы</p></td>
</tr>

<tr>
<td valign="top" ><p>form_id</p></td>
<td valign="top" ><p>Id</p></td>
<td valign="top" ><p>Атрибут «id» формы</p></td>
</tr>

<tr>
<td valign="top" ><p>form_onreset</p></td>
<td valign="top" ><p>Onreset</p></td>
<td valign="top" ><p>Функция JavaScript, вызываемая при наступлении события формы «onreset»</p></td>
</tr>

<tr>
<td valign="top" ><p>form_onsubmit</p></td>
<td valign="top" ><p>Onsubmit</p></td>
<td valign="top" ><p>Функция JavaScript, вызываемая при наступлении события формы «onsubmit»</p></td>
</tr>

<tr>
<td valign="top" ><p>form_method</p></td>
<td valign="top" ><p>Метод</p></td>
<td valign="top" ><p>Атрибут «method» формы</p></td>
</tr>

<tr>
<td valign="top" ><p>form_initial</p></td>
<td valign="top" ><p>Начальные значения свойств</p></td>
<td valign="top" ><p>Данный параметр используется для задания начальных значений свойств компонента Search или для добавления своих свойств.</p></td>
</tr>

</tbody>
</table>

<p>Для создания новой формы поиска можно скопировать форму с кодом SearchTemplate, являющейся формой поиска типа «шаблон поиска». Это позволит получить пустую форму поиска с набором сконфигурированных стандартных кнопок. Для добавления компонентов ввода предикатов нужно выбрать действие «Add». При этом появится таблица с еще не добавленными полями таблицы формы. Отметив нужные поля нужно кликнуть на кнопке «Добавить поля». Нужно учесть, что поля добавляются с атрибутами, установленными на этапе конфигурирования полей. </p>

<p>Для конфигурирования компонентов ввода предикатов нужно выбрать действие «элемент» для нужной формы поиска. После этого появляется форма ввода и таблица предикатов и кнопок. В режиме <b>inline editing</b> можно изменить компонент ввода аргумента, условие сравнения, ярлык, индекс и fieldset. </p>

<p>Напомним, что компонент ввода предиката в общем случае является контейнером, содержащим три компонента ввода:</p>

<ul>
<li>Компонент (<b>SelectOneRadio</b>) для ввода коннектора предиката с предыдущим предикатом</li>
<li>Компонент (<b>SelectOneMenu</b>) для ввода оператора сравнения </li>
<li>Компонент для ввода значения аргумента предиката</li>
</ul>

<p>Для конфигурирования предикатов поиска предназначены три формы. Первая форма нужна для предварительного конфигурирования предиката:</p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>Поле</p></td>
<td valign="top" ><p>ярлык</p></td>
<td valign="top" ><p>назначение</p></td>
</tr>

<tr>
<td valign="top" ><p>element_table</p></td>
<td valign="top" ><p>Таблица</p></td>
<td valign="top" ><p>Таблица поля</p></td>
</tr>

<tr>
<td valign="top" ><p>element_table_alias</p></td>
<td valign="top" ><p>Алиас таблицы</p></td>
<td valign="top" ><p>Алиас таблицы поля</p></td>
</tr>

<tr>
<td valign="top" ><p>element_field</p></td>
<td valign="top" ><p>Поле</p></td>
<td valign="top" ><p>Поле ввода</p></td>
</tr>

<tr>
<td valign="top" ><p>element_alias</p></td>
<td valign="top" ><p>Алиас поля</p></td>
<td valign="top" ><p>Алиас поля</p></td>
</tr>

<tr>
<td valign="top" ><p>element_sid</p></td>
<td valign="top" ><p>Sid</p></td>
<td valign="top" ><p>Системный код поля ввода </p></td>
</tr>

<tr>
<td valign="top" ><p>element_type</p></td>
<td valign="top" ><p>Тип</p></td>
<td valign="top" ><p>Тип поля</p></td>
</tr>

<tr>
<td valign="top" ><p>element_label</p></td>
<td valign="top" ><p>Ярлык</p></td>
<td valign="top" ><p>Ярлык ввода</p></td>
</tr>

<tr>
<td valign="top" ><p>element_component</p></td>
<td valign="top" ><p>Компонент</p></td>
<td valign="top" ><p>Компонент ввода аргумента</p></td>
</tr>

<tr>
<td valign="top" ><p>element_index</p></td>
<td valign="top" ><p>Index</p></td>
<td valign="top" ><p>Индекс обработки и вывода предиката </p></td>
</tr>

<tr>
<td valign="top" ><p>element_predicate</p></td>
<td valign="top" ><p>Условия сравнения</p></td>
<td valign="top" ><p>Условия сравнения </p></td>
</tr>

<tr>
<td valign="top" ><p>element_predicate_custom</p></td>
<td valign="top" ><p>Специальный предикат</p></td>
<td valign="top" ><p>Класс нестандартного предиката</p></td>
</tr>

<tr>
<td valign="top" ><p>element_hidden</p></td>
<td valign="top" ><p>Скрытый ?</p></td>
<td valign="top" ><p>Признак «hidden» предиката</p></td>
</tr>

<tr>
<td valign="top" ><p>element_fieldset</p></td>
<td valign="top" ><p>Fieldset</p></td>
<td valign="top" ><p>Fieldset предиката</p></td>
</tr>

</tbody>
</table>

<p>Окончательное конфигурирование аргумента предиката зависит от выбранного компонента ввода и ничем не отличается от окончательного конфигурирования элементов ввода форм поиска. Для этого нужно выбрать действие «Attribute» для нужного предиката.</p>

<p>Кнопки формы поиска должны иметь одно из 3- значений атрибута «Действие»:</p>

<ul>
<li>Очистить фильтр</li>
<li>Установить фильтр</li>
<li>Cancel</li>
</ul>

<p>Окончательное конфигурирование коннектора и оператора предиката зависит от выбранного условия сравнения и для перехода к нему нужно выбрать действие «предикат» для нужного предиката.</p>

<p>Если выбрано условие сравнения «Тест на принадлежность диапазону», то нужно заполнить следующую форму:</p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>Поле</p></td>
<td valign="top" ><p>ярлык</p></td>
<td valign="top" ><p>назначение</p></td>
</tr>

<tr>
<td valign="top" ><p>element_table</p></td>
<td valign="top" ><p>Таблица</p></td>
<td valign="top" ><p>Таблица поля</p></td>
</tr>

<tr>
<td valign="top" ><p>element_field</p></td>
<td valign="top" ><p>Поле</p></td>
<td valign="top" ><p>Поле предиката</p></td>
</tr>

<tr>
<td valign="top" ><p>element_type</p></td>
<td valign="top" ><p>Тип</p></td>
<td valign="top" ><p>Тип поля</p></td>
</tr>

<tr>
<td valign="top" ><p>element_function</p></td>
<td valign="top" ><p>SQL функция</p></td>
<td valign="top" ><p>SQL функция</p></td>
</tr>

<tr>
<td valign="top" ><p>element_layout</p></td>
<td valign="top" ><p>Верстка</p></td>
<td valign="top" ><p>Направление вывода элементов ввода минимума и максимума аргумента</p></td>
</tr>

<tr>
<td valign="top" ><p>element_min_label</p></td>
<td valign="top" ><p>ярлык для max</p></td>
<td valign="top" ><p>ярлык для элемента ввода минимума аргумента</p></td>
</tr>

<tr>
<td valign="top" ><p>element_max_label</p></td>
<td valign="top" ><p>ярлык для max</p></td>
<td valign="top" ><p>ярлык для элемента ввода максимума аргумента</p></td>
</tr>

<tr>
<td valign="top" ><p>element_operators</p></td>
<td valign="top" ><p>Операторы</p></td>
<td valign="top" ><p>Возможные операторы </p></td>
</tr>

<tr>
<td valign="top" ><p>element_operator_default</p></td>
<td valign="top" ><p>Оператор по умолчанию</p></td>
<td valign="top" ><p>Оператор по умолчанию</p></td>
</tr>

<tr>
<td valign="top" ><p>element_fix_operator</p></td>
<td valign="top" ><p>Фиксировать оператор ?</p></td>
<td valign="top" ><p>Признак возможности изменения оператора пользователем </p></td>
</tr>

<tr>
<td valign="top" ><p>element_connector</p></td>
<td valign="top" ><p>коннектор по умолчанию</p></td>
<td valign="top" ><p>коннектор по умолчанию</p></td>
</tr>

<tr>
<td valign="top" ><p>element_fix_connector</p></td>
<td valign="top" ><p>Фиксировать коннектор ?</p></td>
<td valign="top" ><p>Признак возможности изменения коннектора пользователем</p></td>
</tr>

<tr>
<td valign="top" ><p>element_fieldset</p></td>
<td valign="top" ><p>Fieldset</p></td>
<td valign="top" ><p>Fieldset предиката</p></td>
</tr>

</tbody>
</table>

<p>Если же выбрано условие сравнения не равное «Тест на принадлежность диапазону», то нужно заполнить следующую форму:</p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>Поле</p></td>
<td valign="top" ><p>ярлык</p></td>
<td valign="top" ><p>назначение</p></td>
</tr>

<tr>
<td valign="top" ><p>element_table</p></td>
<td valign="top" ><p>Таблица</p></td>
<td valign="top" ><p>Таблица поля</p></td>
</tr>

<tr>
<td valign="top" ><p>element_field</p></td>
<td valign="top" ><p>Поле</p></td>
<td valign="top" ><p>Поле предиката</p></td>
</tr>

<tr>
<td valign="top" ><p>element_type</p></td>
<td valign="top" ><p>Тип</p></td>
<td valign="top" ><p>Тип поля</p></td>
</tr>

<tr>
<td valign="top" ><p>element_function</p></td>
<td valign="top" ><p>SQL функция</p></td>
<td valign="top" ><p>SQL функция</p></td>
</tr>

<tr>
<td valign="top" ><p>element_operators</p></td>
<td valign="top" ><p>Операторы</p></td>
<td valign="top" ><p>Возможные операторы</p></td>
</tr>

<tr>
<td valign="top" ><p>element_operator_default</p></td>
<td valign="top" ><p>ярлык для max</p></td>
<td valign="top" ><p>Оператор по умолчанию</p></td>
</tr>

<tr>
<td valign="top" ><p>element_fix_operator</p></td>
<td valign="top" ><p>ярлык для max</p></td>
<td valign="top" ><p>Признак возможности изменения оператора пользователем</p></td>
</tr>

<tr>
<td valign="top" ><p>element_connector</p></td>
<td valign="top" ><p>операторы</p></td>
<td valign="top" ><p>коннектор по умолчанию</p></td>
</tr>

<tr>
<td valign="top" ><p>element_fix_connector</p></td>
<td valign="top" ><p>Оператор по умолчанию</p></td>
<td valign="top" ><p>Признак возможности изменения коннектора пользователем</p></td>
</tr>

<tr>
<td valign="top" ><p>element_fieldset</p></td>
<td valign="top" ><p>Фиксировать оператор ?</p></td>
<td valign="top" ><p>Fieldset предиката</p></td>
</tr>

</tbody>
</table>

<p>Атрибут «Поле» может содержать не только название одного поля, но и валидную комбинацию полей. Таким образом, можно организовать поиска на различные комбинации полей и используя различные SQL функции.</p>

<p><b>Конфигурирование кнопок форм поиска</b></p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>Поле</p></td>
<td valign="top" ><p>ярлык</p></td>
<td valign="top" ><p>назначение</p></td>
</tr>

<tr>
<td valign="top" ><p>element_action</p></td>
<td valign="top" ><p>Действие</p></td>
<td valign="top" ><p>Действие, инициируемое кнопкой</p></td>
</tr>

<tr>
<td valign="top" ><p>element_event</p></td>
<td valign="top" ><p>Событие</p></td>
<td valign="top" ><p>Событие, генерируемое после завершения действия</p></td>
</tr>

<tr>
<td valign="top" ><p>element_confirm</p></td>
<td valign="top" ><p>Подтвердить ?</p></td>
<td valign="top" ><p>Признак подтверждения действия при нажатии кнопки</p></td>
</tr>

<tr>
<td valign="top" ><p>element_file</p></td>
<td valign="top" ><p>Image</p></td>
<td valign="top" ><p>Название рисунка для кнопки</p></td>
</tr>

<tr>
<td valign="top" ><p>element_component</p></td>
<td valign="top" ><p>Компонент</p></td>
<td valign="top" ><p>Компонент кнопки</p></td>
</tr>

<tr>
<td valign="top" ><p>element_index</p></td>
<td valign="top" ><p>Индекс</p></td>
<td valign="top" ><p>Индекс вывода кнопки</p></td>
</tr>

<tr>
<td valign="top" ><p>element_name</p></td>
<td valign="top" ><p>Атрибут name</p></td>
<td valign="top" ><p>Атрибут name</p></td>
</tr>

<tr>
<td valign="top" ><p>element_renderer</p></td>
<td valign="top" ><p>Визуализатор</p></td>
<td valign="top" ><p>Визуализатор кнопки</p></td>
</tr>

<tr>
<td valign="top" ><p>element_id</p></td>
<td valign="top" ><p>Id</p></td>
<td valign="top" ><p>Атрибут Id</p></td>
</tr>

<tr>
<td valign="top" ><p>element_value</p></td>
<td valign="top" ><p>Значение</p></td>
<td valign="top" ><p>Атрибут value</p></td>
</tr>

<tr>
<td valign="top" ><p>element_tabindex</p></td>
<td valign="top" ><p>Tabindex</p></td>
<td valign="top" ><p>Атрибут Tabindex</p></td>
</tr>

<tr>
<td valign="top" ><p>element_accesskey</p></td>
<td valign="top" ><p>Accesskey</p></td>
<td valign="top" ><p>Атрибут Accesskey</p></td>
</tr>

</tbody>
</table>

<p>Конфигурирование валидаторов и фильтров для форм поиска в точности совпадает с конфигурированием валидаторов и фильтров для форм ввода.</p>

<h1>Конфигурирование гридов (Grids)</h1>

<p>Для создания гридов нужно выбрать пункт меню Спецификация-&gt;Грид.</p>

<p>Спецификации гридов хранятся в 2 таблицах: «fgs_grid», являющейся мастер таблицей для таблицы «fgs_column». В таблице «fgs_column» хранятся спецификации колонок и возможные действия над записями.</p>

<p>Конфигурирование гридов заключается во вводе следующих данных:</p>

<ul>
<li>Общие данные самого грида</li>
<li>Данные компонент колонок, действий над отдельными записями и действий над набором записей</li>
</ul>

<p><b>Общие данные грида:</b></p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>поле</p></td>
<td valign="top" ><p>ярлык</p></td>
<td valign="top" ><p>назначение</p></td>
</tr>

<tr>
<td valign="top" ><p>grid_system</p></td>
<td valign="top" ><p>System?</p></td>
<td valign="top" ><p>Признак отношения грида к конфигуратору. Для гридов разрабатываемого приложения должен быть установлен в «нет»</p></td>
</tr>

<tr>
<td valign="top" ><p>grid_type</p></td>
<td valign="top" ><p>Тип</p></td>
<td valign="top" ><p>Тип грида. Для гридов разрабатываемого приложения должен быть установлен в «приложение»</p></td>
</tr>

<tr>
<td valign="top" ><p>grid_table</p></td>
<td valign="top" ><p>Таблица</p></td>
<td valign="top" ><p>Таблица грида</p></td>
</tr>

<tr>
<td valign="top" ><p>grid_sid</p></td>
<td valign="top" ><p>Sid</p></td>
<td valign="top" ><p>Код грида</p></td>
</tr>

<tr>
<td valign="top" ><p>grid_title</p></td>
<td valign="top" ><p>Название</p></td>
<td valign="top" ><p>Название грида</p></td>
</tr>

<tr>
<td valign="top" ><p>grid_pagesize</p></td>
<td valign="top" ><p>Размер страницы</p></td>
<td valign="top" ><p>Количество записей, выводимых на одной странице</p></td>
</tr>

<tr>
<td valign="top" ><p>grid_order</p></td>
<td valign="top" ><p>Сортировка</p></td>
<td valign="top" ><p>Начальная сортировка грида</p></td>
</tr>

<tr>
<td valign="top" ><p>grid_direction</p></td>
<td valign="top" ><p>Direction</p></td>
<td valign="top" ><p>Начальное направление сортировки</p></td>
</tr>

<tr>
<td valign="top" ><p>grid_user_offset</p></td>
<td valign="top" ><p>Offset пользователя?</p></td>
<td valign="top" ><p>Признак возможности изменения Offset пользователем</p></td>
</tr>

<tr>
<td valign="top" ><p>grid_user_order</p></td>
<td valign="top" ><p>Сортировка пользователя?</p></td>
<td valign="top" ><p>Признак возможности изменения сортировки пользователем</p></td>
</tr>

<tr>
<td valign="top" ><p>grid_user_pagesize</p></td>
<td valign="top" ><p>Pagesize пользователя?</p></td>
<td valign="top" ><p>Признак возможности изменения количества записей, выводимых на одной странице, пользователем</p></td>
</tr>

<tr>
<td valign="top" ><p>grid_headerspan</p></td>
<td valign="top" ><p>Headerspan</p></td>
<td valign="top" ><p>Количество строк в заголовке грида </p></td>
</tr>

<tr>
<td valign="top" ><p>grid_id</p></td>
<td valign="top" ><p>Id</p></td>
<td valign="top" ><p>Id грида</p></td>
</tr>

<tr>
<td valign="top" ><p>grid_modal</p></td>
<td valign="top" ><p>Modal?</p></td>
<td valign="top" ><p>Признак возможности скрытия грида пользователем</p></td>
</tr>

<tr>
<td valign="top" ><p>grid_inline_edit</p></td>
<td valign="top" ><p>Inline редактирование?</p></td>
<td valign="top" ><p>Признак Inline редактирования</p></td>
</tr>

<tr>
<td valign="top" ><p>grid_initial</p></td>
<td valign="top" ><p>Начальные значения свойств</p></td>
<td valign="top" ><p>Данный параметр используется для задания начальных значений свойств компонента <b>Grid</b> или для добавления своих свойств.</p></td>
</tr>

</tbody>
</table>

<p>Как известно грид позволяет выполнить редактирование в двух режимах:</p>

<p>Режим 1- в гриде все редактируемые поля уже находятся в режиме редактирования и для сохранения измененных данных нужно нажать на кнопку сохранения. Режим 1 эмулирует редактирование электронной таблицы.</p>

<p>Режим 2- так называемое <b>inline editing</b>, при котором для перехода в режим редактирования нужно дважды кликнуть мышкой на нужном поле нужной записи. Сохранение измененных данных осуществляется путем нажатия кнопки Enter для полей ввода типа ColumnInputText или кликнув на нужную опцию для полей с компонентом ввода ColumnSelectOneMenu.</p>

<p>При установке признака Inline редактирования в «да», редактирование осуществляется в режиме 2, т.е. путем двойного клика мышкой на нужном поле нужной записи. </p>

<p>Для создания нового грида можно скопировать грид типа «шаблон». При этом грид с кодом MasterGridTemplate является шаблоном для гридов мастер таблиц, а с кодом GridTemplate является шаблоном для всех остальных, Копирование позволяет получить пустой грид с набором сконфигурированных стандартных действий над записями. Для добавления колонок грида нужно выбрать действие «Add». При этом появится таблица с еще не добавленными полями базовой таблицы грида. Отметив нужные поля нужно кликнуть на кнопке «Добавить поля». Нужно учесть, что поля добавляются с атрибутами, установленными на этапе конфигурирования полей. </p>

<p>Для конфигурирования колонок, действий над отдельными записями и действий над набором записей нужно выбрать действие «колонка». После этого появляется форма ввода и таблица колонок, действий над отдельными записями и действий над набором записей. В режиме <b>inline editing</b> можно изменить компонент вывода, заголовок и индекс. </p>

<p>Для конфигурирования колонок вывода предназначены две формы. Первая для предварительного конфигурирования:</p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>Поле</p></td>
<td valign="top" ><p>ярлык</p></td>
<td valign="top" ><p>назначение</p></td>
</tr>

<tr>
<td valign="top" ><p>column_table</p></td>
<td valign="top" ><p>Таблица</p></td>
<td valign="top" ><p>Таблица поля колонки</p></td>
</tr>

<tr>
<td valign="top" ><p>column_table_alias</p></td>
<td valign="top" ><p>Алиас таблицы</p></td>
<td valign="top" ><p>Алиас таблицы поля колонки</p></td>
</tr>

<tr>
<td valign="top" ><p>column_field</p></td>
<td valign="top" ><p>Поле</p></td>
<td valign="top" ><p>Поле, выводимое в колонке. Если поле разное для разных языков, то можно часть названия поля, соответствующее коду языка заменить на xxx. При экспорте конфигуратор заменит xxx на код соответствующего языка</p></td>
</tr>

<tr>
<td valign="top" ><p>column_alias</p></td>
<td valign="top" ><p>Алиас поля</p></td>
<td valign="top" ><p>Алиас поля колонки</p></td>
</tr>

<tr>
<td valign="top" ><p>column_type</p></td>
<td valign="top" ><p>Тип</p></td>
<td valign="top" ><p>Тип поля</p></td>
</tr>

<tr>
<td valign="top" ><p>column_component</p></td>
<td valign="top" ><p>Компонент</p></td>
<td valign="top" ><p>Компонент колонки</p></td>
</tr>

<tr>
<td valign="top" ><p>column_index</p></td>
<td valign="top" ><p>Индекс</p></td>
<td valign="top" ><p>Индекс вывода</p></td>
</tr>

<tr>
<td valign="top" ><p>column_header</p></td>
<td valign="top" ><p>Заголовок</p></td>
<td valign="top" ><p>Заголовок колонки вывода</p></td>
</tr>

<tr>
<td valign="top" ><p>column_save</p></td>
<td valign="top" ><p>Сохранить</p></td>
<td valign="top" ><p>Признак сохранения значения поля в сессионной переменной</p></td>
</tr>

<tr>
<td valign="top" ><p>column_hidden</p></td>
<td valign="top" ><p>Скрытый?</p></td>
<td valign="top" ><p>Признак скрытия колонки. Необходимо установить в 1 для полей, которые не нужно выводить в гриде, но которые нужны для вспомогательных целей.</p></td>
</tr>

<tr>
<td valign="top" ><p>column_align</p></td>
<td valign="top" ><p>Align</p></td>
<td valign="top" ><p>Атрибут align колонки</p></td>
</tr>

<tr>
<td valign="top" ><p>column_width</p></td>
<td valign="top" ><p>Ширина</p></td>
<td valign="top" ><p>Атрибут width колонки</p></td>
</tr>

<tr>
<td valign="top" ><p>column_function</p></td>
<td valign="top" ><p>SQL функция в select</p></td>
<td valign="top" ><p>SQL функция в select</p></td>
</tr>

<tr>
<td valign="top" ><p>column_sid</p></td>
<td valign="top" ><p>Sid</p></td>
<td valign="top" ><p>Системный код колонки</p></td>
</tr>

<tr>
<td valign="top" ><p>column_register</p></td>
<td valign="top" ><p>Глобальное имя</p></td>
<td valign="top" ><p>Наименование ключа элемента массива globals компонента Registry, в котором сохраняется значение поля </p></td>
</tr>

<tr>
<td valign="top" ><p>column_sort</p></td>
<td valign="top" ><p>Сортировать как</p></td>
<td valign="top" ><p>Если введен 0-не разрешать сортировку по колонке, 1-разрешить сортировку колонки по полю колонки. Если же введено название поля, то разрешить сортировку по колонке, но сортировать не по полю колонки, а по введенному названию поля</p></td>
</tr>

<tr>
<td valign="top" ><p>column_sort_prefix</p></td>
<td valign="top" ><p>Префикс сортировки</p></td>
<td valign="top" ><p>Постоянное значение в начале предложения order by </p></td>
</tr>

<tr>
<td valign="top" ><p>column_sort_suffix</p></td>
<td valign="top" ><p>Суффикс сортировки</p></td>
<td valign="top" ><p>Постоянное значение в конце предложения order by </p></td>
</tr>

</tbody>
</table>

<p>Атрибут «Поле» может содержать не только название поля, но и валидную комбинацию полей. В этом случае необходимо вводить атрибут «Алиас поля». Таким образом, можно выводить сумму или произведение двух или нескольких полей.</p>

<p>Окончательное конфигурирование колонок вывода зависит от выбранного компонента вывода и для него нужно выбрать действие «Attribute» для нужной колонки вывода. При этом появляется форма с полями ввода, сгруппированными в 5 групп:</p>

<ul>
<li>System</li>
<li>Визуализация</li>
<li>Сортировка</li>
<li>Атрибуты ввода</li>
<li>События</li>
</ul>

<p>При этом набор групп полей и полей ввода в этих группах зависит от типа выбранного компонента. Например, группа «Атрибуты ввода» появляется только для компонент ColumnInputText и ColumnSelectOneMenu, а группа «Сортировка» не появляется для компонент GridButton, RowSelector, RowAction, RowSetAction.</p>

<p><b>Конфигурирование атрибутов группы System</b></p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>Поле</p></td>
<td valign="top" ><p>ярлык</p></td>
<td valign="top" ><p>назначение</p></td>
</tr>

<tr>
<td valign="top" ><p>column_table</p></td>
<td valign="top" ><p>Таблица</p></td>
<td valign="top" ><p>Таблица поля колонки</p></td>
</tr>

<tr>
<td valign="top" ><p>column_table_alias</p></td>
<td valign="top" ><p>Алиас таблицы</p></td>
<td valign="top" ><p>Алиас таблицы поля колонки</p></td>
</tr>

<tr>
<td valign="top" ><p>column_field</p></td>
<td valign="top" ><p>Поле</p></td>
<td valign="top" ><p>Поле колонки. Если поле разное для разных языков, то можно часть названия поля, соответствующее коду языка заменить на xxx. При экспорте конфигуратор заменит xxx на код соответствующего языка</p></td>
</tr>

<tr>
<td valign="top" ><p>column_alias</p></td>
<td valign="top" ><p>Алиас</p></td>
<td valign="top" ><p>Алиас поля колонки</p></td>
</tr>

<tr>
<td valign="top" ><p>column_type</p></td>
<td valign="top" ><p>Тип</p></td>
<td valign="top" ><p>Тип поля колонки</p></td>
</tr>

<tr>
<td valign="top" ><p>column_sid</p></td>
<td valign="top" ><p>Sid</p></td>
<td valign="top" ><p>Системный код колонки</p></td>
</tr>

<tr>
<td valign="top" ><p>column_component</p></td>
<td valign="top" ><p>Индекс</p></td>
<td valign="top" ><p>Индекс вывода</p></td>
</tr>

<tr>
<td valign="top" ><p>column_save</p></td>
<td valign="top" ><p>Сохранить?</p></td>
<td valign="top" ><p>Признак сохранения значения поля в сессионной переменной</p></td>
</tr>

<tr>
<td valign="top" ><p>column_register</p></td>
<td valign="top" ><p>Глобальное имя</p></td>
<td valign="top" ><p>Наименование ключа элемента массива globals компонента Registry, в котором сохраняется значение поля </p></td>
</tr>

<tr>
<td valign="top" ><p>column_hidden</p></td>
<td valign="top" ><p>Скрытый?</p></td>
<td valign="top" ><p>Признак скрытия колонки. Необходимо установить в 1 для полей, которые не нужно выводить в гриде, но которые нужны для вспомогательных целей.</p></td>
</tr>

<tr>
<td valign="top" ><p>column_calculate</p></td>
<td valign="top" ><p>Суммировать?</p></td>
<td valign="top" ><p>Признак суммирования значений колонки. Если установлен в «Да»,то по колонке будет выведена сумма значений поля всем по выведенным записям.</p></td>
</tr>

</tbody>
</table>

<p><b>Конфигурирование полей атрибутов группы Визуализация</b></p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>Поле</p></td>
<td valign="top" ><p>ярлык</p></td>
<td valign="top" ><p>назначение</p></td>
</tr>

<tr>
<td valign="top" ><p>column_renderer</p></td>
<td valign="top" ><p>Визуализатор</p></td>
<td valign="top" ><p>Визуализатор колонки. </p></td>
</tr>

<tr>
<td valign="top" ><p>column_index</p></td>
<td valign="top" ><p>Индекс</p></td>
<td valign="top" ><p>Алиас таблицы поля колонки</p></td>
</tr>

<tr>
<td valign="top" ><p>column_header</p></td>
<td valign="top" ><p>Заголовок</p></td>
<td valign="top" ><p>Аббревиатура текста, выводимое в заголовке колонки</p></td>
</tr>

<tr>
<td valign="top" ><p>column_span</p></td>
<td valign="top" ><p>Span</p></td>
<td valign="top" ><p>Формула вывода заголовка колонки</p></td>
</tr>

<tr>
<td valign="top" ><p>column_align</p></td>
<td valign="top" ><p>Align</p></td>
<td valign="top" ><p>Атрибут Align колонки</p></td>
</tr>

<tr>
<td valign="top" ><p>column_width</p></td>
<td valign="top" ><p>Ширина</p></td>
<td valign="top" ><p>Атрибут width колонки</p></td>
</tr>

<tr>
<td valign="top" ><p>column_list</p></td>
<td valign="top" ><p>Список</p></td>
<td valign="top" ><p>Список, используемый для вывода значения поля</p></td>
</tr>

<tr>
<td valign="top" ><p>column_relation</p></td>
<td valign="top" ><p>Тип связи</p></td>
<td valign="top" ><p>Тип связи таблицы списка с базовой таблицей грида</p></td>
</tr>

<tr>
<td valign="top" ><p>column_join_lookup</p></td>
<td valign="top" ><p>Сделать join с таблицей ?</p></td>
<td valign="top" ><p>Признак объединения таблицы списка с базовой таблицей грида</p></td>
</tr>

<tr>
<td valign="top" ><p>column_converter</p></td>
<td valign="top" ><p>Конвертер</p></td>
<td valign="top" ><p>Конвертер значения поля - только для компонента ColumnText</p></td>
</tr>

<tr>
<td valign="top" ><p>column_format</p></td>
<td valign="top" ><p>Format</p></td>
<td valign="top" ><p>Формат вывода значения поля - зарезервировано для будущего</p></td>
</tr>

<tr>
<td valign="top" ><p>column_function</p></td>
<td valign="top" ><p>SQL функция в select</p></td>
<td valign="top" ><p>SQL функция в select</p></td>
</tr>

</tbody>
</table>

<p>Рассмотрим <b>конфигурирование многострочных заголовков</b> на следующем примере. Пусть нам нужно сформировать заголовок таблицы из трех строк:</p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td colspan="3" valign="top" ><p>ColumnSet1</p></td>
<td colspan="2" valign="top" ><p>ColumnSet2</p></td>
<td rowspan="3" valign="top" ><p>Column6</p></td>
</tr>

<tr>
<td colspan="2" valign="top" ><p>ColumnSet3</p></td>
<td rowspan="2" valign="top" ><p>Column3</p></td>
<td rowspan="2" valign="top" ><p>Column4</p></td>
<td rowspan="2" valign="top" ><p>Column5</p></td>
</tr>

<tr>
<td valign="top" ><p>Column1</p></td>
<td valign="top" ><p>Column2</p></td>
</tr>
</tbody>
</table>

<p>Для начала устанавливаем значение атрибута «Headerspan» для грида равным 3.</p>

<p>Требуемые значения атрибутов Span и Заголовок приведены в таблице:</p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>Колонка</p></td>
<td valign="top" ><p>Атрибут Span</p></td>
<td valign="top" ><p>Атрибут Заголовок</p></td>
</tr>

<tr>
<td valign="top" ><p>Column1</p></td>
<td valign="top" ><p>1*3,1*2,1*1</p></td>
<td valign="top" ><p>ColumnSet1, ColumnSet3, Column1</p></td>
</tr>

<tr>
<td valign="top" ><p>Column2</p></td>
<td valign="top" ><p>0,0,1*1</p></td>
<td valign="top" ><p>Column2</p></td>
</tr>

<tr>
<td valign="top" ><p>Column3</p></td>
<td valign="top" ><p>0,2*1,0</p></td>
<td valign="top" ><p>Column3</p></td>
</tr>

<tr>
<td valign="top" ><p>Column4</p></td>
<td valign="top" ><p>0,2*1,0</p></td>
<td valign="top" ><p>ColumnSet2, Column4</p></td>
</tr>

<tr>
<td valign="top" ><p>Column5</p></td>
<td valign="top" ><p>0,2*1,0</p></td>
<td valign="top" ><p>Column5</p></td>
</tr>

<tr>
<td valign="top" ><p>Column6</p></td>
<td valign="top" > </td>
<td valign="top" ><p>Column6</p></td>
</tr>

</tbody>
</table>

<p>0 означает, что вывода нет</p>

<p>N*m означает значение атрибутов rowspan и colspan , а именно rowspan=n и colspan=m.</p>

<p>Если атрибут Span не задан, то это означает, что колонка имеет однострочный заголовок.</p>

<p>Атрибуты Span и Заголовок должны отражать алгоритм формирования заголовка в 3 прохода:</p>

<p>В первый проход нужно сформировать ColumnSet1, ColumnSet2 и Column6.</p>

<p>Во второй проход нужно сформировать ColumnSet3, Column3, Column4 и Column5</p>

<p>В третий проход нужно сформировать Column1 и Column2</p>

<p>Для колонки Column1 при первом проходе нужно сформировать ячейку 1*3 и вывести в качестве заголовка ColumnSet1. При втором проходе нужно сформировать ячейку 1*2 и вывести в качестве заголовка ColumnSet3. При третьем проходе нужно сформировать ячейку 1*1 и вывести в качестве заголовка Column1.</p>

<p>Для колонки Column2 при первом и втором проходах ничего выводить не нужно.</p>

<p>При третьем проходе нужно сформировать ячейку 1*1 и вывести в качестве заголовка Column2</p>

<p>Для колонки Column3 при первом проходе ничего выводить не нужно. При втором проходе нужно сформировать 2*1 и вывести в качестве заголовка Column3. При третьем проходе ничего выводить не нужно.</p>

<p>Для колонки Column4 при первом проходе нужно сформировать ячейку 1*2 и вывести в качестве заголовка ColumnSet2. При втором проходе нужно сформировать ячейку 2*1 и вывести в качестве заголовка Column4. При третьем проходе ничего выводить не нужно.</p>

<p>Для колонки Column5 при первом проходе ничего выводить не нужно. При втором проходе нужно сформировать ячейку 2*1 и вывести в качестве заголовка Column5. При третьем проходе ничего выводить не нужно.</p>

<p><b>Конфигурирование полей атрибутов группы Сортировка</b></p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>Поле</p></td>
<td valign="top" ><p>ярлык</p></td>
<td valign="top" ><p>назначение</p></td>
</tr>

<tr>
<td valign="top" ><p>column_sort</p></td>
<td valign="top" ><p>Сортировать как</p></td>
<td valign="top" ><p>Если введен 0-не разрешать сортировку по колонке, 1-разрешить сортировку колонки по полю колонки. Если же введено название поля, то разрешить сортировку по колонке, но сортировать не по полю колонки, а по введенному названию поля</p></td>
</tr>

<tr>
<td valign="top" ><p>column_sort_prefix</p></td>
<td valign="top" ><p>Префикс сортировки</p></td>
<td valign="top" ><p>Постоянное значение в начале предложения order by </p></td>
</tr>

<tr>
<td valign="top" ><p>column_sort_suffix</p></td>
<td valign="top" ><p>Суффикс сортировки</p></td>
<td valign="top" ><p>Постоянное значение в конце предложения order by </p></td>
</tr>

</tbody>
</table>

<p><b>Конфигурирование колонок с компонентом вывода ColumnLookup</b></p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>поле</p></td>
<td valign="top" ><p>ярлык</p></td>
<td valign="top" ><p>назначение</p></td>
</tr>

<tr>
<td valign="top" ><p>column_list</p></td>
<td valign="top" ><p>Список</p></td>
<td valign="top" ><p>Список, используемый для вывода </p></td>
</tr>

<tr>
<td valign="top" ><p>column_relation</p></td>
<td valign="top" ><p>Тип связи</p></td>
<td valign="top" ><p>Тип связи поля с таблицей списка </p></td>
</tr>

<tr>
<td valign="top" ><p>column_join_lookup</p></td>
<td valign="top" ><p>Сделать join с таблицей?</p></td>
<td valign="top" ><p>Признак соединения таблицы переменного списка с базовой таблицей грида</p></td>
</tr>

</tbody>
</table>

<p>Рассмотрим подробно атрибут «Сделать join с таблицей?». </p>

<p>Это атрибут используется только для переменных списков и только для случая, когда поле записи базовой таблицы может хранить значение только одной опции списка: «Один к одному». </p>

<p>Другой тип связи «Один ко многим» означает, что поле записи базовой таблицы может хранить значения нескольких опций списка, т.е. поле может хранить набор значений. Эти виды связи не совпадают с типами связи таблиц БД «Один к одному» и «Один ко многим».</p>

<p>Если установить его в «Да», то в SQL запросе на выборку выводимых записей компонент <b>Grid</b> выполнит соединение таблицы переменного списка с базовой таблицей грида (left join) и в число выбираемых полей включит поле – описание опции списка. </p>

<p>Если установить его в «Нет», то компонент <b>Grid</b> загрузит переменный список только из опций, необходимых для визуализации набора выводимых записей. </p>

<p>Если типа связи поля с таблицей переменного списка «Один ко многим», то компонент <b>Grid</b> загрузит переменный список только из опций, необходимых для визуализации набора выводимых записей. </p>

<p>Данный механизм вывода полей с компонентом вывода ColumnLookup реализован для оптимизации вывода записей.</p>

<p><b>Конфигурирование псевдо-компонента ColumnTableJoiner</b></p>

<p>Данный псевдо - компонент предназначен для подсоединения таблиц к базовой таблице.</p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>поле</p></td>
<td valign="top" ><p>ярлык</p></td>
<td valign="top" ><p>назначение</p></td>
</tr>

<tr>
<td valign="top" ><p>column_table</p></td>
<td valign="top" ><p>Таблица</p></td>
<td valign="top" ><p>Подсоединяемая таблица</p></td>
</tr>

<tr>
<td valign="top" ><p>column_table_alias</p></td>
<td valign="top" ><p>Алиас таблицы</p></td>
<td valign="top" ><p>Алиас таблицы поля колонки</p></td>
</tr>

<tr>
<td valign="top" ><p>column_field</p></td>
<td valign="top" ><p>Первичный ключ</p></td>
<td valign="top" ><p>Первичный ключ подсоединяемой таблицы</p></td>
</tr>

<tr>
<td valign="top" ><p>column_alias</p></td>
<td valign="top" ><p>Алиас</p></td>
<td valign="top" ><p>Алиас первичного ключа</p></td>
</tr>

<tr>
<td valign="top" ><p>column_left_table</p></td>
<td valign="top" ><p>Таблица слева</p></td>
<td valign="top" ><p>Таблица слева</p></td>
</tr>

<tr>
<td valign="top" ><p>column_left_alias</p></td>
<td valign="top" ><p>Алиас таблицы слева</p></td>
<td valign="top" ><p>Алиас таблицы слева</p></td>
</tr>

<tr>
<td valign="top" ><p>column_left_foreign_key</p></td>
<td valign="top" ><p>Внешний ключ таблицы слева</p></td>
<td valign="top" ><p>Внешний ключ таблицы слева</p></td>
</tr>

<tr>
<td valign="top" ><p>column_join</p></td>
<td valign="top" ><p>Тип join</p></td>
<td valign="top" ><p>Тип join</p></td>
</tr>

<tr>
<td valign="top" ><p>column_where</p></td>
<td valign="top" ><p>Where</p></td>
<td valign="top" ><p>Зарезервировано</p></td>
</tr>

<tr>
<td valign="top" ><p>column_required</p></td>
<td valign="top" ><p>Необходимый?</p></td>
<td valign="top" ><p>Обязательность подсоединения таблицы</p></td>
</tr>

</tbody>
</table>

<p>Поясним использование атрибута «Необходимый?». </p>

<p>Компонент Search позволяет выполнять поиск по полям таблицы, не являющейся базовой. Поэтому подсоединение не базовой таблицы необходимо только при установке условия поиска по полям не базовой таблицы. В этом случае атрибут нужно установить в «Нет».</p>

<p>Если же соединение не базовой таблицы не связано с установкой условий поиска, то атрибут нужно установить в «Да».</p>

<p><b>Конфигурирование действий над отдельными записями (RowAction)</b></p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>поле</p></td>
<td valign="top" ><p>ярлык</p></td>
<td valign="top" ><p>назначение</p></td>
</tr>

<tr>
<td valign="top" ><p>column_index</p></td>
<td valign="top" ><p>Индекс</p></td>
<td valign="top" ><p>Индекс вывода </p></td>
</tr>

<tr>
<td valign="top" ><p>column_action</p></td>
<td valign="top" ><p>Действие</p></td>
<td valign="top" ><p>Выполняемое действие</p></td>
</tr>

<tr>
<td valign="top" ><p>column_immediate</p></td>
<td valign="top" ><p>Мгновенный?</p></td>
<td valign="top" ><p>Признак выполнения действия самим компонентом <b>Grid</b></p></td>
</tr>

<tr>
<td valign="top" ><p>column_condition</p></td>
<td valign="top" ><p>Условие</p></td>
<td valign="top" ><p>Условие, необходимое для выполнения действия </p></td>
</tr>

<tr>
<td valign="top" ><p>column_condition_field</p></td>
<td valign="top" ><p>Поле условия</p></td>
<td valign="top" ><p>Проверяемое поле условия</p></td>
</tr>

<tr>
<td valign="top" ><p>column_condition_class</p></td>
<td valign="top" ><p>Класс условия</p></td>
<td valign="top" ><p>Класс нестандартного условия</p></td>
</tr>

<tr>
<td valign="top" ><p>column_condition_class_static</p></td>
<td valign="top" ><p>Статичный класс условия</p></td>
<td valign="top" ><p>Признак статичности класса</p></td>
</tr>

<tr>
<td valign="top" ><p>column_condition_parameter</p></td>
<td valign="top" ><p>Параметр условия</p></td>
<td valign="top" ><p>Параметр условия</p></td>
</tr>

<tr>
<td valign="top" ><p>column_condition_parameter_type</p></td>
<td valign="top" ><p>Тип параметр условия</p></td>
<td valign="top" ><p>Тип параметр условия</p></td>
</tr>

<tr>
<td valign="top" ><p>column_name</p></td>
<td valign="top" ><p>Имя</p></td>
<td valign="top" ><p>Имя колонки</p></td>
</tr>

<tr>
<td valign="top" ><p>column_file</p></td>
<td valign="top" ><p>Image</p></td>
<td valign="top" ><p>Файл иконки</p></td>
</tr>

<tr>
<td valign="top" ><p>column_renderer</p></td>
<td valign="top" ><p>Визуализатор</p></td>
<td valign="top" ><p>Класс нестандартного визуализатора</p></td>
</tr>

</tbody>
</table>

<p><b>Конфигурирование действий над набором записей (RowSetAction)</b></p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>поле</p></td>
<td valign="top" ><p>ярлык</p></td>
<td valign="top" ><p>назначение</p></td>
</tr>

<tr>
<td valign="top" ><p>column_index</p></td>
<td valign="top" ><p>Индекс</p></td>
<td valign="top" ><p>Индекс вывода </p></td>
</tr>

<tr>
<td valign="top" ><p>column_action</p></td>
<td valign="top" ><p>Действие</p></td>
<td valign="top" ><p>Выполняемое действие</p></td>
</tr>

<tr>
<td valign="top" ><p>column_immediate</p></td>
<td valign="top" ><p>Мгновенный?</p></td>
<td valign="top" ><p>Признак выполнения действия самим компонентом <b>Grid</b></p></td>
</tr>

<tr>
<td valign="top" ><p>column_condition</p></td>
<td valign="top" ><p>Условие</p></td>
<td valign="top" ><p>Условие, необходимое для выполнения действия </p></td>
</tr>

<tr>
<td valign="top" ><p>column_condition_field</p></td>
<td valign="top" ><p>Поле условия</p></td>
<td valign="top" ><p>Проверяемое поле условия</p></td>
</tr>

<tr>
<td valign="top" ><p>column_condition_class</p></td>
<td valign="top" ><p>Класс условия</p></td>
<td valign="top" ><p>Класс нестандартного условия</p></td>
</tr>

<tr>
<td valign="top" ><p>column_condition_class_static</p></td>
<td valign="top" ><p>Статичный класс условия</p></td>
<td valign="top" ><p>Признак статичности класса</p></td>
</tr>

<tr>
<td valign="top" ><p>column_condition_parameter</p></td>
<td valign="top" ><p>Параметр условия</p></td>
<td valign="top" ><p>Параметр условия</p></td>
</tr>

<tr>
<td valign="top" ><p>column_condition_parameter_type</p></td>
<td valign="top" ><p>Тип параметр условия</p></td>
<td valign="top" ><p>Тип параметр условия</p></td>
</tr>

<tr>
<td valign="top" ><p>column_name</p></td>
<td valign="top" ><p>Имя</p></td>
<td valign="top" ><p>Имя колонки</p></td>
</tr>

<tr>
<td valign="top" ><p>column_file</p></td>
<td valign="top" ><p>Image</p></td>
<td valign="top" ><p>Файл иконки</p></td>
</tr>

</tbody>
</table>
<br>
<h1>Конфигурирование контроллеров (controllers)</h1>

<p>Для конфигурирования контроллеров нужно выбрать пункт меню Спецификация-&gt;Контроллер.</p>

<p>Спецификации контроллеров хранятся в двух таблицах «fgs_сontroller» и «fgs_unit», связанных отношением «мастер-деталь». </p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>поле</p></td>
<td valign="top" ><p>ярлык</p></td>
<td valign="top" ><p>назначение</p></td>
</tr>

<tr>
<td valign="top" ><p>controller_system</p></td>
<td valign="top" ><p>System ?</p></td>
<td valign="top" ><p>Признак отношения контроллера к конфигуратору. Для контроллеров разрабатываемого приложения должен быть установлен в «нет»</p></td>
</tr>

<tr>
<td valign="top" ><p>controller_sid</p></td>
<td valign="top" ><p>Sid</p></td>
<td valign="top" ><p>Код контроллера</p></td>
</tr>

<tr>
<td valign="top" ><p>controller_type</p></td>
<td valign="top" ><p>Тип</p></td>
<td valign="top" ><p>Тип контроллера</p></td>
</tr>

<tr>
<td valign="top" ><p>controller_title</p></td>
<td valign="top" ><p>Название</p></td>
<td valign="top" ><p>Название контроллера</p></td>
</tr>

<tr>
<td valign="top" ><p>controller_class</p></td>
<td valign="top" ><p>Класс</p></td>
<td valign="top" ><p>Класс контроллера</p></td>
</tr>

<tr>
<td valign="top" ><p>controller_script</p></td>
<td valign="top" ><p>Script</p></td>
<td valign="top" ><p>Скрипт контроллера</p></td>
</tr>

<tr>
<td valign="top" ><p>controller_template</p></td>
<td valign="top" ><p>Шаблон</p></td>
<td valign="top" ><p>Шаблон контроллера</p></td>
</tr>

<tr>
<td valign="top" ><p>controller_roles</p></td>
<td valign="top" ><p>Роли</p></td>
<td valign="top" ><p>Список ролей, которым доступен контроллер</p></td>
</tr>

<tr>
<td valign="top" ><p>controller_users</p></td>
<td valign="top" ><p>Пользователи</p></td>
<td valign="top" ><p>Список пользователей, которым доступен контроллер</p></td>
</tr>

<tr>
<td valign="top" ><p>controller_initial</p></td>
<td valign="top" ><p>Initial</p></td>
<td valign="top" ><p>Начальные значения свойств контроллера. Формат ввода должен быть таким:</p>

<p>‘Название свойства 1’=&gt;значение свойства 1’, ‘Название свойства 2’=&gt;значение свойства 2…</p></td>
</tr>

<tr>
<td valign="top" ><p>controller_session</p></td>
<td valign="top" ><p>Session</p></td>
<td valign="top" ><p>Список свойств контроллера, которые нужно сохранять в сессионных переменных. Название свойств нужно заключать в одинарные кавычки и разделять между собой запятыми</p></td>
</tr>

</tbody>
</table>

<p>Для конфигурирования компонент Unit контроллеров нужно выбрать действие «detail» для нужного контроллера и ввести данные Unit.</p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>поле</p></td>
<td valign="top" ><p>ярлык</p></td>
<td valign="top" ><p>назначение</p></td>
</tr>

<tr>
<td valign="top" ><p>unit_sid</p></td>
<td valign="top" ><p>Sid</p></td>
<td valign="top" ><p>Код Unit </p></td>
</tr>

<tr>
<td valign="top" ><p>unit_type</p></td>
<td valign="top" ><p>Тип</p></td>
<td valign="top" ><p>Тип Unit </p></td>
</tr>

<tr>
<td valign="top" ><p>unit_class</p></td>
<td valign="top" ><p>Класс</p></td>
<td valign="top" ><p>Класс Unit </p></td>
</tr>

<tr>
<td valign="top" ><p>unit_form</p></td>
<td valign="top" ><p>Форма</p></td>
<td valign="top" ><p>Форма Unit </p></td>
</tr>

<tr>
<td valign="top" ><p>unit_form_class</p></td>
<td valign="top" ><p>Класс Формы</p></td>
<td valign="top" ><p>Класс формы Unit </p></td>
</tr>

<tr>
<td valign="top" ><p>unit_form_renderer</p></td>
<td valign="top" ><p>Визуализатор Формы</p></td>
<td valign="top" ><p>Визуализатор формы Unit </p></td>
</tr>

<tr>
<td valign="top" ><p>unit_form_display</p></td>
<td valign="top" ><p>Показывать Форму ?</p></td>
<td valign="top" ><p>Признак видимости формы в начале</p></td>
</tr>

<tr>
<td valign="top" ><p>unit_form_hide</p></td>
<td valign="top" ><p>Скрывать Форму ?</p></td>
<td valign="top" ><p>Признак скрытия формы после завершения редактирование записей</p></td>
</tr>

<tr>
<td valign="top" ><p>unit_grid</p></td>
<td valign="top" ><p>Грид</p></td>
<td valign="top" ><p>Грид Unit </p></td>
</tr>

<tr>
<td valign="top" ><p>unit_grid_class</p></td>
<td valign="top" ><p>Класс Грида</p></td>
<td valign="top" ><p>Класс грида Unit </p></td>
</tr>

<tr>
<td valign="top" ><p>unit_grid_renderer</p></td>
<td valign="top" ><p>Визуализатор Грида</p></td>
<td valign="top" ><p>Визуализатор грида Unit </p></td>
</tr>

<tr>
<td valign="top" ><p>unit_grid_display</p></td>
<td valign="top" ><p>Показывать Грид ?</p></td>
<td valign="top" ><p>Признак видимости грида в начале</p></td>
</tr>

<tr>
<td valign="top" ><p>unit_grid_hide</p></td>
<td valign="top" ><p>Скрывать Грид ?</p></td>
<td valign="top" ><p>Признак скрытия грида при редактировании записей</p></td>
</tr>

<tr>
<td valign="top" ><p>unit_grid_multimode_hide</p></td>
<td valign="top" ><p>Скрывать в мультирежиме ?</p></td>
<td valign="top" ><p>Признак скрытия грида при выборе операций над несколькими записями</p></td>
</tr>

<tr>
<td valign="top" ><p>unit_search</p></td>
<td valign="top" ><p>Поиск</p></td>
<td valign="top" ><p>Форма поиска Unit </p></td>
</tr>

<tr>
<td valign="top" ><p>unit_search_class</p></td>
<td valign="top" ><p>Класс Формы поиска</p></td>
<td valign="top" ><p>Класс формы поиска Unit </p></td>
</tr>

<tr>
<td valign="top" ><p>unit_search_renderer</p></td>
<td valign="top" ><p>Визуализатор Формы Поиска</p></td>
<td valign="top" ><p>Визуализатор формы поиска Unit </p></td>
</tr>

<tr>
<td valign="top" ><p>unit_search_display</p></td>
<td valign="top" ><p>Показывать Форму Поиска ?</p></td>
<td valign="top" ><p>Признак видимости формы поиска в начале</p></td>
</tr>

<tr>
<td valign="top" ><p>unit_search_hide</p></td>
<td valign="top" ><p>Скрывать форму поиска ?</p></td>
<td valign="top" ><p>Признак скрытия формы поиска при нажатии кнопок поиска</p></td>
</tr>

<tr>
<td valign="top" ><p>unit_dataset</p></td>
<td valign="top" ><p>Набор данных</p></td>
<td valign="top" ><p>Набор данных</p></td>
</tr>

<tr>
<td valign="top" ><p>unit_dataset_class</p></td>
<td valign="top" ><p>Класс набора данных</p></td>
<td valign="top" ><p>Класс набора данных</p></td>
</tr>

<tr>
<td valign="top" ><p>unit_initial</p></td>
<td valign="top" ><p>Initial</p></td>
<td valign="top" ><p>Начальные значения свойств Unit </p></td>
</tr>

<tr>
<td valign="top" ><p>unit_session</p></td>
<td valign="top" ><p>Session</p></td>
<td valign="top" ><p>Список свойств Unit , которые нужно сохранять в сессионных переменных</p></td>
</tr>

</tbody>
</table>

<p><b>Конфигурирование контроллеров типа CRUD</b></p>

<p>Тип контроллера должен быть равен «crud». Должен быть сконфигурирован только один Unit и тип этого Unit должен быть равен «crud».</p>

<p><b>Конфигурирование контроллеров типа MasterDetail</b></p>

<p>Тип контроллера должен быть равен «MasterDetail». Должно быть сконфигурировано только два Unit и типы этих Unit должны быть равны «master» и «detail». Базовые таблицы компонент detail Unit и master Unit должны быть связаны отношением “master-detail”.</p>

<p>Также базовая таблица компонент detail Unit должна иметь поле, являющимся внешним ключом к первичному ключу базовой таблицы компонент master Unit. Требуемое конфигурирование таблиц типа «detail» и внешних ключей таких таблиц приведено в соответствующих разделах данного документа.</p>

<p><b>Конфигурирование контроллеров типа UnitSet</b></p>

<p>Тип контроллера должен быть равен «<b>UnitSet</b>» Должно быть сконфигурировано как минимум два Unit и тип одного Unit должен быть равен «master». Все базовые таблицы detail Unit-ов должны иметь в качестве мастер таблицы базовую таблицу master Unit. Также базовая таблица компонент каждого detail Unit-а должна иметь поле, являющимся внешним ключом к первичному ключу базовой таблицы компонент master Unit.</p>

<h1>Экспорт спецификаций</h1>

<p>Экспорт спецификаций компонент осуществляется только для текущего языка интерфейса. Для экспорта спецификаций для определенного языка нужно этот язык сделать текущим.</p>

<p>При выборе пункта меню для экспорта спецификаций компонент, экспортируются спецификации всех компонент выбранного типа. </p>

<p>Экспорт спецификаций компонента нужно выполнять каждый раз при изменении спецификаций как самого компонента так спецификаций связанных с ним компонент. </p>

<p>Например, при изменении спецификации сообщений нужно выполнить сначала экспорт сообщений, а затем всех остальных компонент.</p>

<p>Формы ввода, поиска и гриды связаны со списками. Поэтому при изменении спецификаций списков, необходимо выполнить, сначала экспорт списков и затем форм ввода, поиска и гридов.</p>

<p>Контроллеры и списки связаны с наборами данных. Поэтому при изменении спецификаций наборов данных, необходимо выполнить, сначала экспорт наборов данных и затем экспорт контроллеров, списков форм ввода, поиска и гридов.</p>

<p>При экспорте спецификаций конфигуратор проверяет правильность введенных спецификаций, и все найденные ошибки выводит в окне вывода отладочной информации. </p>

<h1>Тестирование контроллеров</h1>

<p>После экспорта контроллеров можно протестировать созданные контроллеры. Для этого нужно найти нужный контроллер и кликнуть мышкой на поле кода контроллера (Sid). После этого конфигуратор откроет новую вкладку с кодом окна «application» с тестируемым контроллером. </p>

<p>Напомним, что в режиме разработки можно быстро переходить в режим конфигурирования как форм ввода и поиска и гридов, так и отдельных элементов этих компонент. </p>

<p>Для перехода к редактированию спецификации формы ввода нужно сделать двойной клик на названии формы ввода.</p>

<p>Для перехода к редактированию спецификации отдельного элемента ввода нужен двойной клик на ярлыке нужного элемента.</p>

<p>Для редактирования спецификации формы поиска нужен двойной клик на названии формы поиска.</p>

<p>Для перехода к редактированию спецификации отдельного предиката нужен двойной клик на ярлыке нужного предиката.</p>

<p>Для перехода к редактированию спецификации грида нужен двойной клик на названии грида.</p>

<p>Для перехода к редактированию спецификации отдельной колонки нужен двойной клик на заголовке нужной колонки.</p>

<p>Конфигурирование выбранных компонент осуществляется на отдельной вкладке браузера с кодом окна «instant_edit».</p>

<h1>Уроки Конфигуратора</h1>

<p>В этой части документа приводятся примеры конфигурирования компонент самого Конфигуратора, которые можно использовать для реализации нужного функционала разрабатываемых приложений. Для ознакомления с установленными атрибутами предлагается иногда кликнуть на иконке редактирования компонент. Подчеркиваю – только для ознакомления! Что-то изменять и кликать на кнопке «Обновить» категорически запрещено! В примерах показано как фреймворк использует установленные атрибуты для реализации нужного функционала.</p>

<p><b>Урок 1 - Конфигурирование сообщений</b></p>

<p>Конфигурирование сообщений является примером интерфейса к одиночной таблице (fgs_message). Данный вид интерфейса определяет требования к конфигурированию только контроллера.</p>

<p>Выберите пункт меню Спецификация-&gt;Контроллер, найдите контроллер с кодом «message». Этот контроллер предоставляет описываемый интерфейс. Обратите внимание на следующие ключевые атрибуты конфигурирования:</p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>ярлык</p></td>
<td valign="top" ><p>значение</p></td>
<td valign="top" ><p>комментарий</p></td>
</tr>

<tr>
<td valign="top" ><p>Тип</p></td>
<td valign="top" ><p>crud</p></td>
<td valign="top" > </td>
</tr>

<tr>
<td valign="top" ><p>Класс</p></td>
<td valign="top" ><p>Crud</p></td>
<td valign="top" > </td>
</tr>

<tr>
<td valign="top" ><p>Script</p></td>
<td valign="top" ><p>configurator.php</p></td>
<td valign="top" ><p>Этот файл управляющего скрипта для конфигуратора. Для разрабатываемого приложения нужно указывать значение «application.php»</p></td>
</tr>

<tr>
<td valign="top" ><p>Шаблон</p></td>
<td valign="top" ><p>crud.php</p></td>
<td valign="top" ><p>Этот файл служит шаблоном для интерфейса Crud для конфигуратора. Для разрабатываемого приложения нужно указывать значение «admin_crud.php»</p></td>
</tr>

</tbody>
</table>

<p>Кликните на иконке «Detail» для этого контроллера. Обратите внимание, что есть только один Unit системным кодом crud и типом crud.</p>

<p>При клике на коде компонента в гриде Unit-а Конфигуратор переходит к конфигурированию выбранного компонента на вкладке с кодом окна «instant_edit».</p>

<p><b>Урок 2 - Конфигурирование полей БД</b></p>

<p>Конфигурирование полем БД является примером интерфейса к одиночной таблице (fgs_field). Особенностью этого интерфейса является использование грида для редактирования некоторых полей в режиме <b>inline editing</b>.</p>

<p>Выберите пункт меню Спецификация-&gt;Поле Таблицы. Далее сделайте двойной клик мышкой на названии грида- откроется новая вкладка для конфигурирования грида с системным кодом «fields». Перейдите на эту вкладку. Кликните на иконке «Обновить». Появится форма с общими атрибутами грида. Ключевым атрибутом является атрибут с ярлыком «Inline редактирование?», установленным в «да».</p>

<p>Далее кликните на иконке «Колонка». Появится таблица элементов грида. Для ознакомления с установленными атрибутами колонок ввода кликайте мышкой иконке «Attribute» для полей с компонентами ColumnSelectOneMenu и ColumnInputText.</p>

<p><b>Урок 3 - Конфигурирование таблиц БД</b></p>

<p>Конфигурирование таблиц БД является примером интерфейса к двум таблицам, связанными отношением master-detail (fgs_table и fgs_field). Рассмотрим ключевые моменты конфигурирования данного интерфейса.</p>

<p>Выберите пункт меню Спецификация-&gt;Поле Таблицы, найдите поле «field_table» для таблицы fgs_field и перейдите к редактированию этого поля, чтобы только ознакомиться с установленными атрибутами. Ничего менять при этом не нужно! Обратите внимание, что для этого поля указаны следующие атрибуты</p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>ярлык</p></td>
<td valign="top" ><p>Значение</p></td>
</tr>

<tr>
<td valign="top" ><p>Ссылается на таблицу</p></td>
<td valign="top" ><p>fgs_table</p></td>
</tr>

<tr>
<td valign="top" ><p>Первичный ключ таблицы на которую ссылается</p></td>
<td valign="top" ><p>table_name</p></td>
</tr>

<tr>
<td valign="top" ><p>Тип таблицы, на которую ссылается</p></td>
<td valign="top" ><p>Master таблица</p></td>
</tr>

</tbody>
</table>

<p>Выберите пункт меню Спецификация-&gt;Таблица, найдите таблицу fgs_field и обратите внимание, что в качестве «Таблица master» указана таблица fgs_table. </p>

<p>Далее сделайте двойной клик мышкой на названии грида- откроется новая вкладка (код окна «instant_edit») для конфигурирования грида с системным кодом «tables». Далее перейдите на вкладку с кодом окна «instant_edit». Кликните на иконке «Колонка». Появится таблица элементов грида. Кликните на иконке «Attribute» для компонента RowAction с действием «detail». Появится форма с установленными атрибутами. Обратите внимание на следующие атрибуты: </p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>ярлык</p></td>
<td valign="top" ><p>значение</p></td>
</tr>

<tr>
<td valign="top" ><p>Действие</p></td>
<td valign="top" ><p>detail</p></td>
</tr>

<tr>
<td valign="top" ><p>Мгновенный?</p></td>
<td valign="top" ><p>нет</p></td>
</tr>

</tbody>
</table>

<p>Выберите пункт меню Спецификация-&gt;Контроллер, найдите контроллер с кодом «table». Этот контроллер предоставляет описываемый интерфейс. Обратите внимание на следующие ключевые атрибуты конфигурирования:</p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>ярлык</p></td>
<td valign="top" ><p>значение</p></td>
<td valign="top" ><p>комментарий</p></td>
</tr>

<tr>
<td valign="top" ><p>Тип</p></td>
<td valign="top" ><p>MasterDetail</p></td>
<td valign="top" > </td>
</tr>

<tr>
<td valign="top" ><p>Класс</p></td>
<td valign="top" ><p>MasterDetail</p></td>
<td valign="top" > </td>
</tr>

<tr>
<td valign="top" ><p>Script</p></td>
<td valign="top" ><p>configurator.php</p></td>
<td valign="top" ><p>Этот файл управляющим скриптом для конфигуратора. Для разрабатываемого приложения нужно указывать значение «application.php»</p></td>
</tr>

<tr>
<td valign="top" ><p>Шаблон</p></td>
<td valign="top" ><p>md.php</p></td>
<td valign="top" ><p>Этот файл служит шаблоном для интерфейса MasterDetail для конфигуратора. Для разрабатываемого приложения нужно указывать значение «admin_md.php»</p></td>
</tr>

</tbody>
</table>

<p>Кликните на иконке «Detail» для этого контроллера. Обратите внимание, что есть два Unit: один с системным кодом detail и типом detail и второй с системным кодом master и типом master.</p>

<p><b>Урок 4 - Конфигурирование списков</b></p>

<p>Конфигурирование списков является примером интерфейса к двум таблицам, связанными отношением master-detail (fgs_list и fgs_option). Данный вид конфигурирования интересен конфигурацией связанных select и конфигурацией компонента RowAction с условием.</p>

<p>Выберите пункт меню Спецификация-&gt;Список. Сделайте видимой форму ввода списка. Это можно сделать с помощью клика на гиперссылке «Form», расположенной на дополнительной панели.</p>

<p>Форма ввода списков позволяет при изменении признака списка «System?» менять зависимые списки, используемые для ввода полей с ярлыками «Таблица» и «Набор данных». В зависимости от установки этого признака в «Да» или «Нет», будут выводиться списки таблиц и наборов данных, принадлежащих, соответственно Конфигуратору или разрабатываемому приложению. </p>

<p>В данном случае цепочка зависимых select состоит из верхнего узла «System ?» (уровень 0) и двух узлов нижнего уровня «Таблица» и «Набор данных». При этом узлы «Таблица» и «Набор данных» находятся на одинаковом уровне- уровне 1.</p>

<p>Для ознакомления с конфигурацией формы ввода дважды кликните на названии формы. Далее перейдите на вкладку с кодом окна «instant_edit». Затем кликните на иконке «Элемент». Появится грид с элементами ввода формы. Ознакомьтесь с атрибутами полей list_system, list_table и list_dataset кликнув в гриде на иконке «Attribute» соответствующего поля. Особое внимание обратите на группу атрибутов «Атрибуты Ajax». Для поля list_system отметьте, что оно имеет глобальную область видимости под именем «system».</p>

<p>Далее нужно ознакомиться со списком ListTable, который является списком таблиц. Для этого просто кликните на названии списка для поля list_table в гриде элементов формы ввода. Конфигуратор перейдет к конфигурированию списков на вкладке «instant_edit». Этот список является переменным списком и основан на наборе данных ListTable. Для ознакомления с набором данных ListTable кликните на названии набора данных в гриде. Конфигуратор перейдет к конфигурированию наборов данных, ограниченных единственным набором данных ListTable. В гриде наборов данных кликните на иконке «Detail» и просмотрите, как сконфигурированы два предиката этого набора данных.</p>

<p>Здесь нужно пояснение, какие списки используются для конфигуратора и приложений. Для конфигуратора используются все переменные списки, основанные на таблицах с признаком «System?», установленный в «Да» и все постоянные списки, которые основаны на таблице fgs_option. Для приложений же используются все переменные списки, основанные на таблицах с признаком «System?», установленный в «Нет» и все постоянные списки, которые основаны на таблице fgs_option. </p>

<p>Для включения всех постоянных списков и нужен предикат для поля table_name с атрибутами: </p>

<table border="1" cellpadding="2" cellspacing="0" >
<tbody>
<tr>
<td valign="top" ><p>Ярлык</p></td>
<td valign="top" ><p>Значение </p></td>
<td valign="top" ><p>комментарий</p></td>
</tr>

<tr>
<td valign="top" ><p>Таблица</p></td>
<td valign="top" ><p>fgs_table</p></td>
<td valign="top" > </td>
</tr>

<tr>
<td valign="top" ><p>Поле</p></td>
<td valign="top" ><p>table_name</p></td>
<td valign="top" > </td>
</tr>

<tr>
<td valign="top" ><p>Аргумент</p></td>
<td valign="top" ><p>fgs_option</p></td>
<td valign="top" > </td>
</tr>

<tr>
<td valign="top" ><p>Тип аргумента</p></td>
<td valign="top" > </td>
<td valign="top" ><p>В качестве типа аргумента будет взят тип поля table_name</p></td>
</tr>

<tr>
<td valign="top" ><p>Оператор</p></td>
<td valign="top" ><p>равно</p></td>
<td valign="top" > </td>
</tr>

<tr>
<td valign="top" ><p>Коннектор</p></td>
<td valign="top" ><p>И</p></td>
<td valign="top" ><p>Не используются, поскольку это первый обрабатываемый предикат: Индекс=10</p></td>
</tr>

<tr>
<td valign="top" ><p>Необходимый?</p></td>
<td valign="top" ><p>да</p></td>
<td valign="top" > </td>
</tr>

<tr>
<td valign="top" ><p>Индекс</p></td>
<td valign="top" ><p>10</p></td>
<td valign="top" > </td>
</tr>

</tbody>
</table>

<p>Для включения в список переменных списков нужен предикат для поля table_system с атрибутами: </p>

<table border="1" cellpadding="2" cellspacing="0" >
<tbody>
<tr>
<td valign="top" ><p>Ярлык</p></td>
<td valign="top" ><p>Значение </p></td>
<td valign="top" ><p>комментарий</p></td>
</tr>

<tr>
<td valign="top" ><p>Таблица</p></td>
<td valign="top" ><p>fgs_table</p></td>
<td valign="top" > </td>
</tr>

<tr>
<td valign="top" ><p>Поле</p></td>
<td valign="top" ><p>table_system</p></td>
<td valign="top" > </td>
</tr>

<tr>
<td valign="top" ><p>Аргумент</p></td>
<td valign="top" ><p>&amp;rgv system</p></td>
<td valign="top" ><p>Означает, что аргумент является элементом массива globals компонента Registry с ключом system</p></td>
</tr>

<tr>
<td valign="top" ><p>Тип аргумента</p></td>
<td valign="top" > </td>
<td valign="top" ><p>В качестве типа аргумента будет взят тип поля table_name</p></td>
</tr>

<tr>
<td valign="top" ><p>Оператор</p></td>
<td valign="top" ><p>равно</p></td>
<td valign="top" > </td>
</tr>

<tr>
<td valign="top" ><p>Коннектор</p></td>
<td valign="top" ><p>ИЛИ</p></td>
<td valign="top" > </td>
</tr>

<tr>
<td valign="top" ><p>Необходимый?</p></td>
<td valign="top" ><p>да</p></td>
<td valign="top" > </td>
</tr>

<tr>
<td valign="top" ><p>Индекс</p></td>
<td valign="top" ><p>20</p></td>
<td valign="top" > </td>
</tr>

</tbody>
</table>

<p>Формирование списка таблиц с кодом ListTable происходит следующим образом.</p>

<p>Компонент Form помещает значение поля list_system в элемент массива globals компонента Registry с ключом system. При загрузке списка таблиц с системным кодом ListTable, загрузчик списков ListLoader использует вспомогательный компонент PredicateBuilder для получения условия, накладываемого набором данных ListTable. Компонент PredicateBuilder, в свою очередь, использует компонент Evaluator для получения значения «&amp;rgv system» и возвращает условие (table_name = 'fgs_option' or table_system = '0') или (table_name = 'fgs_option' or table_system = '1'), которое и использует ListLoader для загрузки списка таблиц с кодом ListTable.</p>

<p>Аналогично происходит формирование списка наборов данных (код UnitDataset) для ввода поля list_dataset. Список UnitDataset основан на наборе данных UnitDataset, который имеет всего один предикат с атрибутами:</p>

<table border="1" cellpadding="2" cellspacing="0" >
<tbody>
<tr>
<td valign="top" ><p>Ярлык</p></td>
<td valign="top" ><p>Значение </p></td>
<td valign="top" ><p>комментарий</p></td>
</tr>

<tr>
<td valign="top" ><p>Таблица</p></td>
<td valign="top" ><p>fgs_dataset</p></td>
<td valign="top" > </td>
</tr>

<tr>
<td valign="top" ><p>Поле</p></td>
<td valign="top" ><p>dataset_system</p></td>
<td valign="top" > </td>
</tr>

<tr>
<td valign="top" ><p>Аргумент</p></td>
<td valign="top" ><p>&amp;rgv system</p></td>
<td valign="top" ><p>Означает, что аргумент является элементом массива globals компонента Registry с ключом system</p></td>
</tr>

<tr>
<td valign="top" ><p>Тип аргумента</p></td>
<td valign="top" > </td>
<td valign="top" ><p>В качестве типа аргумента будет взят тип поля dataset_system</p></td>
</tr>

<tr>
<td valign="top" ><p>Оператор</p></td>
<td valign="top" ><p>равно</p></td>
<td valign="top" > </td>
</tr>

<tr>
<td valign="top" ><p>Коннектор</p></td>
<td valign="top" ><p>И</p></td>
<td valign="top" > </td>
</tr>

<tr>
<td valign="top" ><p>Необходимый?</p></td>
<td valign="top" ><p>да</p></td>
<td valign="top" > </td>
</tr>

</tbody>
</table>

<p>При загрузке списка с системным кодом UnitDataset, загрузчик списков ListLoader использует вспомогательный компонент PredicateBuilder для получения условия, накладываемого набором данных UnitDataset. Компонент PredicateBuilder, в свою очередь, использует компонент Evaluator для получения значения «&amp;rgv system» и возвращает условие (dataset_system = '0') или (dataset_system = '1'), которое и использует ListLoader для загрузки списка наборов данных с кодом UnitDataset.</p>

<p>Рассмотрим, как конфигурировать компонент RowAction с условием. Выберите снова пункт меню Спецификация-&gt;Список. Вы видите, что в гриде списков списки, основанные на таблице fgs_option имеют иконку «Detail», а списки, не основанные на таблице fgs_option, не имеют этой иконки. Для того, чтобы узнать, как это было сконфигурировано, дважды кликните на название грида. Конфигуратор перейдет режим конфигурирования грида с системным кодом «lists» на вкладке «instant_edit». Перейдите на эту вкладку. Кликните на иконке «Колонка». Появится таблица колонок этого грида. Кликните на иконке «Attribute» для компонента RowAction с действием «detail». Появится форма ввода атрибутов этого компонента. Обратите внимание на следующие атрибуты:</p>

<table border="1" cellpadding="2" cellspacing="0" >
<tbody>
<tr>
<td valign="top" ><p>Ярлык</p></td>
<td valign="top" ><p>Значение </p></td>
</tr>

<tr>
<td valign="top" ><p>Условие</p></td>
<td valign="top" ><p>Equal</p></td>
</tr>

<tr>
<td valign="top" ><p>Поле условия</p></td>
<td valign="top" ><p>list_table</p></td>
</tr>

<tr>
<td valign="top" ><p>Класс условия</p></td>
<td valign="top" > </td>
</tr>

<tr>
<td valign="top" ><p>Параметр условия</p></td>
<td valign="top" ><p>fgs_option</p></td>
</tr>

<tr>
<td valign="top" ><p>Тип параметр условия</p></td>
<td valign="top" ><p>скалярное значение</p></td>
</tr>

</tbody>
</table>

<p>Класс условия не указан. Это означает, что это стандартное условие.</p>

<p>Посмотрим, как же сконфигурировано условие Equal. Выберите пункт меню Спецификация-&gt;Условие и найдите условие с кодом Equal. Обратите внимание, что тип этого условия «общее условие ». Это условие состоит только из одного утверждения с атрибутами: </p>

<table border="1" cellpadding="2" cellspacing="0" >
<tbody>
<tr>
<td valign="top" ><p>Ярлык</p></td>
<td valign="top" ><p>Значение </p></td>
<td valign="top" ><p>комментарий</p></td>
</tr>

<tr>
<td valign="top" ><p>Operand 1</p></td>
<td valign="top" ><p>%statement_operand1</p></td>
<td valign="top" ><p>Означает, что Operand 1 будет заменяться при экспорте</p></td>
</tr>

<tr>
<td valign="top" ><p>Оператор</p></td>
<td valign="top" ><p>равно</p></td>
<td valign="top" > </td>
</tr>

<tr>
<td valign="top" ><p>Operand 2</p></td>
<td valign="top" ><p>%statement_operand2</p></td>
<td valign="top" ><p>Означает, что Operand 2 будет заменяться при экспорте</p></td>
</tr>

<tr>
<td valign="top" ><p>Failure</p></td>
<td valign="top" ><p>Ошибка при не выполнении</p></td>
<td valign="top" > </td>
</tr>

</tbody>
</table>

<p>При экспорте этого условия </p>

<p>Operand 1 станет равным «&amp;arg list_table»</p>

<p>Operand 2 станет равным « fgs_option»</p>

<p>Вывод иконки «Detail»(компонент GridKit) и валидация соответствующего действия (компонент <b>Grid</b>) происходит следующим образом.</p>

<p>Для проверки условия используется компонент <b>ConditionTester</b>, которому передается как проверяемые утверждения и массив полей текущей записи. Компонент <b>ConditionTester</b> для оценки Operand 1 использует компонент Evaluator, в который передается выражение «&amp;arg list_table» и массив полей текущей записи. Компонент Evaluator возвращает компоненту <b>ConditionTester</b> значение поля «list_table». Далее компонент <b>ConditionTester</b> сравнивает, равно ли полученное значение значению «fgs_option» (Operand 2) и возвращает признак выполнения условия соответствующему компоненту. В зависимости от результата проверки принимается решение выводить иконку или нет (GridKit) или признать действие валидным или нет (<b>Grid</b>).</p>

<p><b>Урок 5 - Конфигурирование контроллеров</b></p>

<p>Конфигурирование контроллеров является примером интерфейса к двум таблицам, связанными отношением master-detail (fgs_controller и fgs_unit). Данный пример конфигурирования интересен следующим. Как вы знаете, все контроллеры делятся по признаку отношения к Конфигуратору или к разрабатываемому приложению. Это определяется по атрибуту «System ?» контроллера. Соответственно этому признаку при конфигурации Unit, входящих в состав контроллера, используются соответствующие списки форм ввода, гридов, форм поиска и наборов данных. Таким образом, для прикладных контроллеров используются списки прикладных форм ввода, гридов, форм поиска и наборов данных, а для контроллеров Конфигуратора используются списки системных форм ввода, гридов, форм поиска и наборов данных. Конфигурирование контроллеров показывает, как передать значение поля из мастер таблицы в формы ввода подчиненной таблицы (detail Form). </p>

<p>Для начала выберем пункт меню Спецификация-&gt;Контроллер. Появится таблица контроллеров. Дважды кликните по названию грида и конфигуратор перейдет к конфигурированию грида с системным кодом «controllers» в окне с кодом «instant_edit». Перейдите на эту вкладку. Кликните на иконке «Колонка» и появится список колонок этого грида. Кликните на иконке «Attribute» для поля «controller_system». Появится форма ввода атрибутов этого поля. Обратите внимание на атрибут «Глобальное имя», который равен «system»и атрибут «Сохранить», установленный в «да».</p>

<p>Вернитесь на вкладку конфигурирования контроллеров и кликните на иконке «Detail» любого контроллера. Появится форма ввода и грид для Unit. Кликните на названии формы ввода, и конфигуратор перейдет к конфигурированию формы ввода с системным кодом «unit» в окне с кодом «instant_edit». Перейдите на эту вкладку. Кликните на иконке «Элемент» для единственной записи, соответствующей этой форме ввода. Появится таблица элементов ввода, относящихся к этой форме ввода. Нас будет интересовать конфигурирование полей ввода unit_form, unit_grid, unit_search и unit_dataset.</p>

<p>Рассмотрим конфигурирование только поля unit_form поскольку, конфигурирование остальных полей аналогично этому. Для ввода этого поля используется список с кодом UnitForm, основанный на наборе данных с кодом UnitForm. Для просмотра атрибутов списка UnitForm кликните на названии списка UnitForm. Конфигуратор перейдет к конфигурированию этого списка в этом же окне («instant_edit»). Список UnitForm исключает типы форм поиска с помощью атрибута «Предложение where в запросе», равного «form_type not like 'search%'». Кликните на названии набора данных UnitForm. В этом же окне («instant_edit») конфигуратор перейдет к конфигурированию этого набора данных. Этот набор данных состоит из 5 предикатов.</p>

<p>По поводу 4-х предикатов, относящихся к полю «form_type» таблицы «fgs_form» нужно сделать следующее пояснение. Все формы ввода с типом равным «template», «column», «element», «predicate» являются служебными и не используются для ввода данных. Поэтому эти четыре предиката отсекают служебные формы. Более интересен пятый предикат, относящийся к полю «form_system» таблицы «fgs_form» и имеющий атрибуты:</p>

<table border="1" cellpadding="2" cellspacing="0" >
<tbody>
<tr>
<td valign="top" ><p>Ярлык</p></td>
<td valign="top" ><p>Значение </p></td>
<td valign="top" ><p>комментарий</p></td>
</tr>

<tr>
<td valign="top" ><p>Таблица</p></td>
<td valign="top" ><p>fgs_form</p></td>
<td valign="top" > </td>
</tr>

<tr>
<td valign="top" ><p>Поле</p></td>
<td valign="top" ><p>form_system</p></td>
<td valign="top" > </td>
</tr>

<tr>
<td valign="top" ><p>Аргумент</p></td>
<td valign="top" ><p>&amp;rgv system</p></td>
<td valign="top" ><p>Означает, что аргумент является элементом массива globals компонента Registry с ключом system</p></td>
</tr>

<tr>
<td valign="top" ><p>Тип аргумента</p></td>
<td valign="top" > </td>
<td valign="top" ><p>В качестве типа аргумента будет взят тип поля form_system</p></td>
</tr>

<tr>
<td valign="top" ><p>Оператор</p></td>
<td valign="top" ><p>равно</p></td>
<td valign="top" > </td>
</tr>

<tr>
<td valign="top" ><p>Коннектор</p></td>
<td valign="top" ><p>И</p></td>
<td valign="top" > </td>
</tr>

<tr>
<td valign="top" ><p>Необходимый?</p></td>
<td valign="top" ><p>да</p></td>
<td valign="top" > </td>
</tr>

</tbody>
</table>

<p>Формирование списка таблиц с кодом UnitForm происходит следующим образом.</p>

<p>Для ввода конфигурации Unit пользователь должен кликнуть на иконке «Detail» соответствующего контроллера. При этом master <b>Grid</b> контроллера с кодом «controllers» должен загрузить только одну запись, соответствующую выбранному контроллеру.</p>

<p>При загрузке только одной записи компонент <b>Grid</b> помещает в массив globals компонента Registry значение значения колонок с установленным атрибутом «Глобальное имя». В нашем случае это колонка для поля controller_system.</p>

<p>При загрузке списка таблиц с системным кодом ListTable, загрузчик списков ListLoader использует вспомогательный компонент PredicateBuilder для получения условия, накладываемого набором данных UnitForm. Компонент PredicateBuilder, в свою очередь, использует компонент Evaluator для получения значения «&amp;rgv system» и возвращает условие ((form_system = '1' and form_type != 'template' and form_type != 'column' and form_type != 'element' and form_type != 'predicate')) или ((form_system = '0' and form_type != 'template' and form_type != 'column' and form_type != 'element' and form_type != 'predicate')), которое ListLoader добавляет к условию (form_type not like 'search%') и использует для загрузки списка форм ввода с кодом UnitForm.</p>

<p><b>Урок 6 - Конфигурирование форм ввода </b></p>

<p>Конфигурирование форм ввода является примером конфигурирования интерфейса <b>UnitSet</b>. </p>

<p>Особенностями данного конфигурирования является использование набора данных, нестандартного визуализатора формы ввода и типа Unit, отличного от master и detail.</p>

<p>Для начала ознакомимся с контроллером с системным кодом forms, организующего этот интерфейс. Для этого выберите пункт меню Спецификация-&gt;Контроллер. В появившейся таблице контроллеров найдите контроллер с системным кодом forms и кликните на иконке «Detail» этого контроллера. </p>

<p>Обратите внимание, что в состав master Unit включен набор данных InputForm. Это связано с тем, что спецификации форм ввода и поиска хранятся в одних и тех же четырех таблицах. Поэтому из записей, выводимых в master <b>Grid</b>, нужно исключить формы поиска. Именно для этого и служит набор данных InputForm. Для ознакомления с набором данных InputForm кликните на названии набора данных InputForm в записи detail <b>Grid</b>, соответствующей Unit с кодом master. Конфигуратор откроет дополнительную вкладку с кодом окна «instant_edit» для конфигурирования именно этого набора данных. Перейдите на эту вкладку. Этот набор данных имеет один простой предикат с атрибутами:</p>

<table border="1" cellpadding="2" cellspacing="0" >
<tbody>
<tr>
<td valign="top" ><p>Ярлык</p></td>
<td valign="top" ><p>Значение </p></td>
<td valign="top" ><p>комментарий</p></td>
</tr>

<tr>
<td valign="top" ><p>Таблица</p></td>
<td valign="top" ><p>fgs_form</p></td>
<td valign="top" > </td>
</tr>

<tr>
<td valign="top" ><p>Поле</p></td>
<td valign="top" ><p>form_type</p></td>
<td valign="top" > </td>
</tr>

<tr>
<td valign="top" ><p>Аргумент</p></td>
<td valign="top" ><p>search</p></td>
<td valign="top" > </td>
</tr>

<tr>
<td valign="top" ><p>Тип аргумента</p></td>
<td valign="top" > </td>
<td valign="top" ><p>В качестве типа аргумента будет взят тип поля form_type</p></td>
</tr>

<tr>
<td valign="top" ><p>Оператор</p></td>
<td valign="top" ><p>не содержит (not like)</p></td>
<td valign="top" > </td>
</tr>

<tr>
<td valign="top" ><p>Коннектор</p></td>
<td valign="top" ><p>И</p></td>
<td valign="top" > </td>
</tr>

<tr>
<td valign="top" ><p>Необходимый?</p></td>
<td valign="top" ><p>да</p></td>
<td valign="top" > </td>
</tr>

</tbody>
</table>

<p>Этот предикат просто отражает тот факт, что все формы, относящиеся к формам поиска, содержат в своем типе подстроку «search».</p>

<p>Вернитесь на вкладку конфигурирования контроллеров и кликните на иконке «Обновить» для записи detail <b>Grid</b>, соответствующей Unit с кодом «attribute». Этот Unit организует интерфейс для редактирования атрибутов элементов ввода в зависимости от компонента элемента ввода. В появившейся форме ввода атрибутов этого Unit, обратите внимание, что в качестве визуализатора для формы ввода указано значение AttributeView, а в качестве класса Unit указано значение «Attribute».</p>

<p>Обратите также внимание на Unit с кодом add, который имеет тип auxiliary. При конфигурировании форм ввода этот Unit организует добавление полей ввода. Грид этого Unit имеет код InitForm и имеет нестандартный визуализатор FgsAddGridView. Этот грид имеет атрибут «Modal?», установленный в «Да». Как вы знаете, обычно компоненты Form, <b>Grid</b> и Search можно скрывать и показывать. Однако при добавлении полей это было посчитано нецелесообразным. Именно для этого и служит такое значение этого атрибута. Визуализатор FgsAddGridView не включает возможности установки пользователем постраничного вывода записей, установки произвольного значения атрибутов offset, pagesize.</p>

<p><b>Урок 7 - Конфигурирование меню</b></p>

<p>Конфигурирование меню является примером интерфейса к двум таблицам, связанными отношением master-detail (fgs_menu и fgs_item). В данном примере интересно конфигурирование detail <b>Grid</b> и один аспект загрузки списков.</p>

<p>Выберите пункт меню Спецификация-&gt;Меню. В появившейся таблице меню найдите меню с системным кодом configurator и кликните на иконке «Detail» этого меню. Появится форма ввода и таблица опций этого меню. Опции меню представляют собой иерархическое дерево. </p>

<p>Для конфигурирования detail <b>Grid</b> сделайте двойной клик на названии грида и перейдите на вкладку конфигурирования detail <b>Grid</b>. На этой вкладке кликните на иконке «Колонка». Появится таблица колонок этого грида. Обратите внимание на поле item_pid, которое хранит код родительского узла опции меню. Для вывода этого поля используется компонент ColumnLookup со списком MenuItem. Этот список формируется из пунктов меню, имеющих тип «меню». Кликните на названии списка MenuItem. Конфигуратор перейдет к конфигурированию этого списка. Этот список основан на этой же таблице fgs_item и поэтому для него установлен алиас таблицы и алиас поля. Этот список использует набор данных MenuItem для установки условия на выбираемые записи. Вы можете самостоятельно ознакомиться с атрибутами предикатов этого набора данных. Самое важное здесь именно то, что для ввода данных таблицы используется список, основанный на этой же таблице. При экспорте спецификации этой формы ввода конфигуратор устанавливает этот факт и к свойствам таких элементов ввода добавляет атрибут «listDrop». При создании же экземпляра компонента Form с элементами ввода с таким атрибутом создается одноименный атрибут самого компонента Form. Компонент Unit, в состав которого входит компонент Form.с таким атрибутом, регистрирует для загрузчика списков ListLoader событие «done», инициируемого компонентом Form. При вставке новой записи, редактировании или удалении записи компонентом Form инициирует событие «done», которое направляется для обработки также загрузчику списков. В качестве аргументов события компонент Form включает также название своей базовой таблицы. Обработка этого события загрузчиком списков заключается в сбросе признака загрузки списков, основанных на таблице, переданной в аргументах события. Поэтому при попытке загрузить такие списки загрузчик списков снова загружает опции списков.</p>

<p><b>Урок 8 - Конфигурирование условий</b></p>

<p>Конфигурирование условий является примером интерфейса к двум таблицам, связанными отношением master-detail (fgs_condition и fgs_statement). В данном примере интересно конфигурирование перехода к вводу утверждений сразу после ввода нового условия.</p>

<p>Для ввода условий используется форма с кодом «condition». Обычно для кнопки «Insert» атрибут «событие» не задается и конфигуратор при экспорте устанавливает его значение в «done». В нашем случае атрибут «событие» равен «detail». Это приводит к тому, что после добавления нового условия компонент Form генерит событие «detail», которое и приводит к переходу контроллера в режим «detail». </p>

<p>Такой же подход используется при конфигурировании контроллеров форм ввода, форм поиска и гридов. Поскольку эти контроллеры являются контроллерами типа <b>UnitSet</b>, то атрибут «событие» кнопки «Insert» соответствующих форм ввода равен коду нужного Unit. После добавления новой записи генерируется событие, которые приводит к переходу в соответствующий режим котроллера. Например, сразу после добавления новой формы ввода происходит переход контроллера в режим ввода элементов ввода.</p>

<p><b>Урок 9 - Конфигурирование изменений значений элементов ввода по событию</b></p>

<p>Предположим у нас есть форма ввода, имеющая элемент ввода типа <b>SelectOneMenu</b>, использующий переменный список из записей справочной таблицы. При вводе новой записи или редактировании какой-нибудь записи может оказаться, что нужной опции нет в списке и нужно:</p>

<ul>
<li>добавить нужную опцию, т.е. добавить новую запись в справочную таблицу </li>
<li>первичный ключ добавленной записи присвоить значению элемента ввода</li>
</ul>

<p>При этом данные, введенные в исходной форме, должны сохраняться.</p>

<p>Для реализации данного функционала нужно:</p>

<p>Контроллер интерфейса должен быть типа <b>UnitSet</b></p>

<p>Исходная форма ввода должна имеет элемент InputButton c действием «Создать событие» и установленным атрибутом «событие». </p>

<p>Контроллер должен включать Unit типа «auxiliary» с единственным компонентом из формы ввода справочной таблицы. Код этого Unit должен быть равен атрибуту «событие» кнопки из предыдущего пункта</p>

<p>Кнопка «Insert» этой формы должна имеет установленный атрибут «Событие» </p>

<p>Атрибут «установить значение по событию» (поле «element_event») для элемента ввода должен быть равен атрибуту «Событие» кнопки «Insert»</p>

