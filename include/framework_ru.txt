<h1 align="center">Руководство фреймворка FGS Factory</h1>

<p>Данный документ описывает возможности, архитектуру и взаимодействие между различными частями фреймворка FGS Factory.</p>

<h2>Компонентная архитектура фреймворка</h2>

<p>Фреймворк базируется на трех основных визуальных компонентах <b>Form</b>, <b>Grid</b>, <b>Search</b> и одном невизуальном компоненте <b>Dataset</b>. <b>Form</b> дает возможность пользователю ввод, редактирование, удаление и просмотр отдельных записей таблицы. <b>Grid</b> позволяет пользователю просматривать и редактировать записи в табличном виде. <b>Search</b> позволяет пользователю вводить фильтры на записи, выводимые в компоненте <b>Grid</b>. Компонент <b>Dataset</b> создает скрытые фильтры на записи таблицы БД. </p>

<p>Компоненты <b>Form</b>, <b>Grid</b>, <b>Search</b> и <b>Dataset</b>, создающие интерфейс пользователя к одной таблице БД объединяются в компонент <b>Unit</b>. <b>Unit</b> осуществляет взаимодействие между своими компонентами и является контроллером. </p>

<p>Компоненты взаимодействуют между собой следующим образом:</p>

<p><b>Dataset</b>- устанавливает неявные фильтры для <b>Grid</b></p>

<p><b>Search</b>- устанавливает фильтры, введенные пользователем, для <b>Grid</b></p>

<p><b>Grid</b>- передает <b>Form</b> данные для копирования, редактирования или удаления записей</p>

<p>Характер взаимодействия компонент определяет следующие ограничения на состав одного <b>Unit</b>:</p>

<ul>
<li>должно быть не более одного компонента каждого типа</li>
<li>должен присутствовать хотя бы один компонент <b>Form</b> или <b>Grid</b></li>
<li>если нет <b>Grid</b>, то <b>Search</b> и <b>Dataset</b> не нужны</li>
<li><b>Search</b> и <b>Dataset</b> являются необязательными компонентами</li>
</ul>

<p>Все компоненты имеют набор атрибутов, характеризующих его состояние. При завершении работы скрипта состояние компонент сохраняется в сессионных переменных, а в начале работы скрипта состояние компонента восстанавливается из сессионных переменных.</p>

<p>Фреймворк реализует три основных варианта интерфейса пользователя к БД:</p>

<ul>
<li>интерфейс к одиночной таблице (контроллер <b>Crud</b>)</li>
<li>интерфейс к двум таблицам, связанных отношением master- detail (контроллер <b>MasterDetail</b>)</li>
<li>интерфейс к нескольким таблицам, одна из которых является master таблицей, а остальные либо связаны с master таблицей отношением master- detail либо нет (контроллер <b>UnitSet</b>)</li>
</ul>

<p>Каждому виду интерфейса соответствует свой класс контроллера. Иногда в качестве названия интерфейса используется название контроллера интерфейса. Так интерфейс к одиночной таблице называется интерфейсом <b>Crud</b>, а интерфейсы, организуемые контроллерами <b>MasterDetail</b> и <b>UnitSet</b>, называется соответственно интерфейсами <b>MasterDetail</b> и <b>UnitSet</b>. Делается это исключительно для краткости изложения.</p>

<p>Контроллер <b>Crud</b> состоит из одного <b>Unit</b>. </p>

<p>Контроллер <b>MasterDetail</b> включает в себя два компонента <b>Unit</b>- master <b>Unit</b> и detail <b>Unit</b> и осуществляет взаимодействие между компонентами разных <b>Unit</b>. </p>

<p>Контроллер <b>UnitSet</b> включает в себя несколько <b>Unit</b>- один master <b>Unit</b> и остальные detail или вспомогательные <b>Unit</b> и осуществляет взаимодействие между компонентами разных <b>Unit</b>. </p>

<p>Взаимодействие между компонентами осуществляется с помощью запросов (request) и событий (event). Запросом может быть клик по гиперссылке(GET-запрос) или нажатие на кнопку формы (GET или POST-запрос). События генерируются компонентами в ответ на запросы, но это не является обязательным. Регистрацию возможных запросов и диспетчеризацию приходящих запросов осуществляет обработчик запросов (компонент <b>RequestHandler</b>), а регистрацию возможных событий и диспетчеризацию сгенерированных событий осуществляет обработчик событий (компонент <b>EventHandler</b>).</p>

<p>Все контроллеры являются расширениями абстрактного класса Controller.</p>

<p>Для обмена данными между компонентами, сохранения и восстановления состояния компонент предназначен компонент <b>Registry</b>.</p>

<p>Доступ к данным регулирует компонент <b>AccessHandler</b>.</p>

<p>Установку соединения с базой данных, выборку и манипуляции с данными осуществляет драйвер конкретной базы данных. </p>

<p>Для профилирования времени исполнения скрипта служит таймер (компонент <b>Timer</b>).</p>

<p>Компонент <b>Form</b> называется также формой ввода и состоит из элементов ввода и кнопок </p>

<p>Компонент <b>Grid</b> состоит из элементов вывода типа <b>Column</b> (колонки или столбцы) и элементов выбора действий над отдельными или наборами записями.</p>

<p>Кроме вывода записей компонент <b>Grid</b> можно использовать для редактирования записей.</p>

<p>Компонент <b>Search</b> называется также формой поиска и состоит из компонентов ввода условий поиска или предикатов.</p>

<p>Компонент <b>Dataset</b> состоит из условий поиска, которые не вводятся явно пользователем, а либо заранее известны, либо определяются в момент исполнения скрипта. </p>

<p>Элементы ввода и вывода могут использовать динамические списки, формируемые на основе таблиц. Для загрузки таких списков используется компонент <b>ListLoader</b>. Использование <b>ListLoader</b> позволяет использовать единожды загруженный список разными компонентами.</p>

<p>Все файлы компонент используют расширение inc. Пути к файлам компонент определены файле classes.php в массиве $cp, который использует функция автозагрузки __autoload классов.</p>

<p>Некоторые вспомогательные компоненты реализуют шаблон проектирования <b>Singleton</b>. Эти компоненты создаются в начале работы управляющего скрипта путем включения bootstrap файла. Доступ к экземплярам этих компонент осуществляется через глобальные переменные:</p>

<p>$timer – экземпляр таймера</p>

<p>$db– экземпляр драйвера базы данных</p>

<p>$registry– экземпляр компонента <b>Registry</b></p>

<p>$requestHandler– экземпляр обработчика запросов</p>

<p>$eventHandler– экземпляр обработчика событий</p>

<p>$<b>ListLoader</b>– экземпляр загрузчика списков</p>

<p>$accessHandler– экземпляр обработчика доступа к контроллеру</p>

<h2>Концепция спецификаций</h2>

<p>Фреймворк использует концепцию спецификаций – вид и логика работы компонент определяется его спецификацией. Фреймворк создает экземпляры компонентов на основе спецификаций. Если нужно изменить свойства или поведение компонента, то нужно изменить его спецификацию. </p>

<p>Под спецификацией компонента понимается набор параметров, определяющие его свойства и логику работы. Параметры условно делятся на три группы:</p>

<ul>
<li>HTML-атрибуты </li>
<li>HTML-события</li>
<li>Системные атрибуты</li>
</ul>

<p>HTML-атрибуты и HTML-события определяются стандартом HTML для соответствующего HTML-аналога (если таковой существует). Системные атрибуты – это атрибуты, определяющие логику работы компонент.</p>

<p>Например, спецификация для компонента <b>Form</b> состоит из параметров:</p>

<ul>
<li>HTML-атрибуты- method, enctype, action, name и другие, относящиеся к HTML элементу «form»</li>
<li>HTML-события – onreset, onsubmit и и другие, относящиеся HTML элементу «form»</li>
<li>Системные атрибуты – идентификатор формы, списки элементов ввода, кнопки формы, таблица базы данных и т.п. </li>
</ul>

<p>Спецификации хранятся в системных таблицах. «Системная таблица» означает использование этой таблицы только Конфигуратором. Разработчик использует конфигуратор для создания и изменения спецификаций. Для ускорения работы данные из этих таблиц экспортируются в файлы спецификаций, которые и используются фреймворком для создания экземпляров компонент. Для каждого языка интерфейса создается свой набор спецификаций, хранящийся в отдельном каталоге. Спецификации для каждого вида компонент хранятся в отдельных каталогах. </p>

<p>Для определения пути к спецификациям компонент фреймворк использует следующие константы:</p>

<table border="1" cellpadding="2" cellspacing="0" >
<tbody>
<tr>
<td valign="top" ><p>компонент</p></td>
<td valign="top" ><p>Константа пути</p></td>
</tr>

<tr>
<td valign="top" ><p>контроллер</p></td>
<td valign="top" ><p>CONTROLLER_PATH</p></td>
</tr>

<tr>
<td valign="top" ><p>Форма ввода</p></td>
<td valign="top" ><p>FORM_PATH</p></td>
</tr>

<tr>
<td valign="top" ><p>грид</p></td>
<td valign="top" ><p>GRID_PATH</p></td>
</tr>

<tr>
<td valign="top" ><p>Форма поиска</p></td>
<td valign="top" ><p>SEARCH_PATH</p></td>
</tr>

<tr>
<td valign="top" ><p>Набор данных</p></td>
<td valign="top" ><p>DATASET_PATH</p></td>
</tr>

<tr>
<td valign="top" ><p>список</p></td>
<td valign="top" ><p>LIST_PATH</p></td>
</tr>

<tr>
<td valign="top" ><p>Таблица базы данных</p></td>
<td valign="top" ><p>TABLE_PATH</p></td>
</tr>

<tr>
<td valign="top" ><p>меню</p></td>
<td valign="top" ><p>MENU_PATH</p></td>
</tr>

<tr>
<td valign="top" ><p>Элемент ввода</p></td>
<td valign="top" ><p>ELEMENT_PATH</p></td>
</tr>

<tr>
<td valign="top" ><p>Колонка вывода</p></td>
<td valign="top" ><p>COLUMN_PATH</p></td>
</tr>

</tbody>
</table>

<p>Путь к спецификации компонента формируется так:</p>

<p>Константа компонента/ Язык интерфейса</p>

<p>Структура спецификаций разработана для минимизации кода. Порядок создания спецификаций компонент описан в документе «Руководство Конфигуратора».</p>

<p>Каждый компонент имеет некий набор переменных, определяющих его состояние. Список переменных состояния, начальные значения переменных и список сохраняемых переменных определяются в спецификации компонента. Спецификация и состояние компонента определяют набор запросов и событий, которые он может обработать. Так, например, если <b>Form</b> находится в режиме вставки новой записи, то он никак не сможет обновить или удалить запись. Также, если в спецификации <b>Form</b> указан только режим update, то все запросы на вставку или удаление игнорируются.</p>

<p>Каждый контроллер предоставляет интерфейс пользователя к базе данных и поэтому необходим механизм ограничения доступа. Для этого спецификация контроллера содержит так называемый Access Control List –список управления доступом. Этот список может содержать роли и пользователи, которым разрешено запускать данный контроллер.</p>

<p>Необходимо также отметить, что некоторые системные атрибуты не вводятся явно разработчиком, а создаются только во время экспорта на основании введенных данных. Несмотря на то, что при экспорте спецификаций выполняются некоторые проверки на логическую полноту введенных данных и выдаются некоторые предупреждающие сообщения, нельзя гарантировать правильность введенных спецификаций. Поэтому, необходимо четко следовать инструкциям по вводу спецификаций для реализации нужного функционала, и, руководствуясь предупреждениям конфигуратора, корректировать спецификации. </p>

<p><b>Алгоритм обработки запроса</b></p>

<p>Для успешного использования фреймворка необходимо знать, как фреймворк обрабатывает HTTP запрос от клиента (браузера), какие операции фреймворк выполняет и в какой последовательности. </p>

<p>В состав пакета входят два примера управляющего скрипта: configurator.php и application.php. Скрипт configurator.php является управляющим скриптом для конфигуратора спецификаций, а application.php является примером управляющего скрипта для приложений, разрабатываемых на основе данного фреймворка.</p>

<p>Сначала определим понятие «окно» запроса.</p>

<p>Для имитации разных сессий в одном окне браузера и организации параллельного исполнения нескольких экземпляров одного контроллера фреймворк использует понятие «окна» запроса. При этом каждый экземпляр контроллера выполняется в своем «окне».</p>

<p>Управляющий скрипт сначала пытается определить окно запроса (текущее окно запроса). Если передается параметр fgsw, то окном запроса становится окно с кодом равным параметру fgsw. Если же параметр fgsw не передается, окном запроса становится окно с кодом равным «main».</p>

<p>На втором шаге управляющий скрипт пытается определить текущий контроллер, который должен выполняться в текущем окне запроса. Если передается параметр fgsc, то текущим контроллером становится контроллер с кодом равным параметру fgsc. При отсутствии параметра fgsc и если в текущем окне уже запускался какой-то контроллер, то текущим контроллером становится этот контроллер. Если же параметр fgsc не передается и если в текущем окне не запускался никакой контроллер, то выводится просто меню конфигуратора или приложения.</p>

<p>На третьем шаге при наличии текущего контроллера создается требуемый контроллер.</p>

<p>Далее необходимо обратиться к программному коду какого-нибудь контроллера (<b>Crud</b>, <b>MasterDetail</b> или <b>UnitSet</b> ), а именно к последней части кода конструктора класса:</p>
<pre>
if($registry->newController())
{
    $this->initState();
}
else
{
    $this->restoreState();
}
</pre>
<p>Этот кусок кода выполняет следующие действия:</p>

<p>Если текущий контроллер в текущем окне запроса ранее не выполнялся, то происходит инициализация состояния контроллера. Если текущий контроллер в текущем окне запроса ранее уже выполнялся, то происходит восстановление состояния контроллера.</p>

<p>Если передается параметр fgsinit, то также происходит инициализация состояния контроллера.</p>

<p>Напомним, что контроллер содержит компоненты <b>Unit</b>, состоящие из компонент <b>Form</b>, <b>Grid</b>, <b>Search</b> и <b>Dataset</b>, которые, в свою очередь, также являются контейнерами. Поэтому сохранение и восстановление состояния контроллера подразумевает сохранение и восстановление всех его компонент.</p>

<p>После создания контроллера управляющий скрипт вызывает метод «run» котроллера. </p>

<p>Обратимся к программному коду метода «run» компонента Controller.</p>

<p>На четвертом шаге происходит проверка доступа к контроллеру, которая осуществляется компонентом <b>AccessHandler</b> на основе списка управления доступом (Access Control List), являющегося атрибутом спецификации контроллера. Список управления доступом содержит списки ролей и пользователей, которые имеют право запускать контроллер.</p>

<p>На пятом шаге происходит регистрация возможных запросов и событий, инициируемых компонентами. </p>

<p>Обычно GET-запрос создается при клике на гиперссылке, а POST-запрос при нажатии на кнопку типа submit. Фреймворк обрабатывает GET или POST запросы, инициатором или триггером которого являются только компоненты <b>Form</b>, <b>Grid</b>, <b>Search</b> и контроллеры.</p>

<p>Каждый компонент самостоятельно регистрирует возможные запросы и события, инициируемые и обрабатываемые им самим. Компонент <b>Unit</b> регистрирует возможные запросы и события, инициируемые и обрабатываемые либо им самим, либо своими компонентами. Регистрацией запросов и событий между компонентами разных <b>Unit</b> управляет контроллер <b>MasterDetail</b> или <b>UnitSet</b>. </p>

<p>За регистрацию возможных запросов и событий отвечает метод subscribe компонента.</p>

<p>Фремйворк однозначно идентифицирует GET или POST запрос, инициируемый компонентом по четырем параметрам:</p>

<p>Код окна запроса (параметр fgsw)</p>

<p>Код контроллера (параметр fgsc)</p>

<p>Код инициатора запроса (параметр fgst)</p>

<p>Код <b>Unit</b>, к которому принадлежит инициатор запроса (параметр fgsu)</p>

<p>Все компоненты должны добавлять параметры fgsc, fgst и fgsu в свои запросы. Параметр fgsw необязательный и его нужно добавлять при необходимости выполнения запроса в окне, отличном от окна main. Компоненты делают это либо добавляя в формы поля типа «hidden», либо добавляя к гиперссылкам эти параметры.</p>

<p>На шестом шаге происходит диспетчеризация GET или POST запроса. В процессе обработки запроса могут генерироваться события. Так компонент <b>Form</b> при успешном выполнении запроса на вставку, обновление или удаление генерирует событие об успешном завершении операции.</p>

<p>Нужно особо подчеркнуть, что обрабатываемый запрос может быть только один, а сгенерированных событий может быть несколько.</p>

<p>На седьмом шаге происходит диспетчеризация сгенерированных событий. В процессе обработки события также могут генерироваться события.</p>

<p>На восьмом шаге происходит загрузка данных для визуализации. Обычно это получение набора записей для вывода в компоненте <b>Grid</b> и/или загрузка записи для компонента <b>Form</b>.</p>

<p>На девятом шаге сохраняются данные состояния котроллера и всех его компонент.</p>

<p>На последнем десятом шаге происходит генерация HTML-кода или рендеринг страницы. Фреймворк включает стандартные классы <b>FgsFormView</b>, <b>FgsGridView</b>, <b>FgsSearchView</b> для рендеринга соответственно компонент <b>Form</b>, <b>Grid</b> и <b>Search</b>. Для рендеринга элементов ввода компонентов <b>Form</b> и <b>Search</b> используется класс <b>Form</b>Kit, а для вывода данных в <b>Grid</b> - класс <b>Grid</b>Kit. </p>

<p>Таким образом, обработка запроса включает 10 шагов:</p>
<ol start="1" type="1">
<li> Установка текущего окна запроса</li>

<li> Установка текущего контроллера запроса</li>

<li>Создание контроллера, инициализация или восстановление состояния контроллера </li>

<li>Проверка доступа</li>
<li>Регистрация возможных запросов и событий</li>
<li>Диспетчеризация запроса на исполнение</li>
<li>Диспетчеризация событий на обработку</li>
<li>Загрузка данных для визуализации</li>
<li>Сохранение состояния компонент</li>
<li>Рендеринг страницы</li>
</ol>
<h1>Взаимодействие между компонентами одного <b>Unit</b></h1>

<p>Рассмотрим взаимодействие компонент <b>Grid</b>, <b>Form</b> и контроллером на примере редактирования записи.</p>

<p>Редактирования записи происходит в два этапа. Это связано с тем, что компонент <b>Form</b> обычно находится в режиме добавления новой записи. Поэтому сначала компонент <b>Form</b> нужно перевести в режим редактирования записи.</p>

<p>Рассмотрим переход компонента <b>Form</b> в режим редактирования записи.</p>

<p>Каждой записи, выводимой компонентом <b>Grid</b>, соответствует иконка редактирования этой записи. </p>

<p>Компонент <b>Grid</b> регистрирует в качестве возможного запроса запрос на редактирование записи, инициированного им самим. </p>

<p>Компонент <b>Form</b> регистрирует в качестве возможного события событие на редактирование записи, генерируемое компонентом <b>Grid</b>.</p>

<p>При клике пользователя на иконке редактирования некоторой записи в компоненте <b>Grid</b>, на шаге 6 обработчик запросов определяет поступление запроса на редактирование и посылает его на исполнение компоненту <b>Grid</b>.</p>

<p>Компонент <b>Grid</b> проверяет корректность поступившего запроса и, в случае успеха, генерирует событие на обновление выбранной пользователем записи.</p>

<p>На шаге 7 обработчик событий фиксирует наступление события и посылает его на исполнение компоненту <b>Form</b>.</p>

<p>Компонент <b>Form</b>, используя присланные аргументы события, переходит в режим редактирования, загружает выбранную запись и инициализирует значение элементов ввода.</p>

<p>Далее контроллер завершает оставшиеся шаги цикл обработки запроса. На этом первый этап завершен.</p>

<p>Рассмотрим этап самого редактирования записи.</p>

<p>Пользователь редактирует выбранную запись и нажимает на кнопку сохранения данных.</p>

<p>Поскольку компонент <b>Form</b> находится в режиме редактирования, то он регистрирует в качестве возможного запроса запрос на сохранение отредактированных данных, инициированного им самим.</p>

<p>Компонент <b>Unit</b> регистрирует в качестве возможного события событие об успешном выполнении операции, генерируемое компонентом <b>Form</b>.</p>

<p>На шаге 6 обработчик запросов определяет поступление запроса на сохранение отредактированных данных и посылает его на исполнение компоненту <b>Form</b>.</p>

<p>Компонент <b>Form</b> формирует данные SQL запроса на обновление записи и передает его на исполнение драйверу базы данных. В случае успеха обновления записи компонент <b>Form</b> генерирует событие об успешном выполнении операции. Далее компонент <b>Form</b> переходит в режим добавления новой записи и инициализирует элементы ввода.</p>

<p>На шаге 7 обработчик событий фиксирует наступление события об успешном выполнении операции и посылает его на исполнение компоненту <b>Unit</b>.</p>

<p>Компонент <b>Unit</b> обрабатывает полученное событие. Обработке заключается в установке атрибутов видимости компонент, входящих в <b>Unit</b>.</p>

<p>Далее контроллер завершает оставшиеся шаги цикла обработки запроса.</p>

<p>Рассмотрим взаимодействие компонент <b>Grid</b> и <b>Search</b> на примере установки компонентом <b>Search</b> нового фильтра на выводимые компонентом <b>Grid</b> записи.</p>

<p>Компонент <b>Search</b> всегда готов к вводу нового фильтра. Поэтому установка нового фильтра происходит сразу.</p>

<p>Компонент <b>Unit</b> регистрирует для компонента <b>Grid</b> в качестве возможного события событие об установлении нового фильтра, генерируемое компонентом <b>Search</b>.</p>

<p>Компонент <b>Search</b> регистрирует в качестве возможного запроса запрос на установление нового фильтра, инициированного им самим.</p>

<p>Пользователь вводит данные нового фильтра и нажимает на кнопку установки нового фильтра.</p>

<p>На шаге 6 обработчик запросов определяет поступление запроса на установку фильтра и посылает его на исполнение компоненту <b>Search</b>.</p>

<p>Компонент <b>Search</b> проверяет введенные данные нового фильтра и, в случае успеха, генерирует событие об установке нового фильтра.</p>

<p>Компонент <b>Grid</b> обрабатывает полученное событие. Обработка состоит в установке в 0 атрибута offset, равного номеру первой выбираемой записи для вывода.</p>

<p>.</p>

<p>Далее контроллер завершает оставшиеся шаги цикла обработки запроса.</p>

<h1>Взаимодействие между компонентами разных <b>Unit</b></h1>

<p>Рассмотрим взаимодействие компонент разных <b>Unit</b> на примере контроллера типа <b>MasterDetail</b>, содержащего master <b>Unit</b> и detail <b>Unit</b>. Напомним, что данный тип контроллера организует доступ к двум таблицам, связанным отношением master-detail. </p>

<p>В начале работы контроллера типа <b>MasterDetail</b> пользователь имеет доступ только к интерфейсу таблицы master (режим master контроллера).</p>

<p>Каждой записи, выводимой компонентом <b>Grid</b>, входящего в master <b>Unit</b> (master Grid), соответствует иконка для активизации интерфейса таблицы detail (режима detail контроллера).</p>

<p>. </p>

<p>Компонент master Grid регистрирует в качестве возможного запроса запрос для активизации интерфейса таблицы detail, инициированного им самим. </p>

<p>В режиме master контроллер регистрирует для себя и для компонент <b>Form</b> и <b>Grid</b> из detail <b>Unit</b> (detail <b> Form </b>и detail Grid) в качестве возможных событий событие «detail», генерируемое компонентом master Grid.</p>

<p>При нажатии пользователем иконки для активизации интерфейса таблицы detail на шаге 6 обработчик запросов определяет поступление запроса на активизацию интерфейса таблицы detail и посылает его на исполнение компоненту master Grid.</p>

<p>Компонент master Grid проверяет корректность поступившего запроса и, в случае успеха, генерирует событие на активизацию режима detail для выбранной пользователем записи таблицы master. В качестве параметра события передается значение первичного ключа выбранной записи.</p>

<p>На шаге 7 обработчик событий фиксирует наступление события и посылает его на исполнение контроллеру и компонентам detail <b> Form </b>и detail Grid</p>

<p>Контроллер устанавливает свой режим в «detail». В этом режиме выводится master Grid только с одной выбранной записью и компоненты detail <b>Unit</b>.</p>

<p>Компонент detail Form, используя присланные аргументы события, переходит в режим добавления новой записи и инициализирует элементы ввода. Переданное значение первичного ключа выбранной записи таблицы master запоминается и служит в качестве значения внешнего ключа таблицы detail.</p>

<p>Компонент detail Grid обрабатывает присланное событие. Переданное значение первичного ключа выбранной записи таблицы master запоминается и служит в качестве значения внешнего ключа таблицы detail при выборке записей.</p>

<p>Далее контроллер завершает оставшиеся шаги цикл обработки запроса.</p>

<p>В режиме detail регистрируются запросы и события только для компонентов detail <b>Unit</b> и запрос для обратного перехода в режим «master» для самого контроллера. </p>

<h1>Драйверы базы данных</h1>

<p>Фреймворк проектировался с учетом использования различных систем управления базами данных (СУБД). </p>

<p>Фреймворк взаимодействует с базой данных через специализированные драйверы, учитывающие особенности конкретной СУБД.</p>

<p>Для использования какой-то конкретной СУБД необходимы два драйвера:</p>

<p>Драйвер для манипулирования данными</p>

<p>Драйвер для загрузки информации о таблицах в системные таблицы конфигуратора</p>

<p>Драйвер для манипулирования данными должен реализовывать шаблон проектирования <b>Singleton</b> и иметь следующие методы:</p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>метод</p></td>
<td valign="top" ><p>назначение</p></td>
</tr>

<tr>
<td valign="top" ><p>getInstance</p></td>
<td valign="top" ><p>Получение единственного экземпляра класса</p></td>
</tr>

<tr>
<td valign="top" ><p>__construct</p></td>
<td valign="top" ><p>Конструктор класса должен быть типа private.</p></td>
</tr>

<tr>
<td valign="top" ><p>table_join</p></td>
<td valign="top" ><p>метод создания объединения таблиц</p></td>
</tr>

<tr>
<td valign="top" ><p>connect</p></td>
<td valign="top" ><p>Метод соединения с базой данных</p></td>
</tr>

<tr>
<td valign="top" ><p>value</p></td>
<td valign="top" ><p>Метод получения единственного значения из таблицы</p></td>
</tr>

<tr>
<td valign="top" ><p>page</p></td>
<td valign="top" ><p>Метод получения набора записей с использованием limit</p></td>
</tr>

<tr>
<td valign="top" ><p>set</p></td>
<td valign="top" ><p>Метод получения набора записей без использования limit</p></td>
</tr>

<tr>
<td valign="top" ><p>row</p></td>
<td valign="top" ><p>Метод получения одной записи из таблицы по первичному ключу</p></td>
</tr>

<tr>
<td valign="top" ><p>record</p></td>
<td valign="top" ><p>Метод получения одной записи из таблицы по переданному SQL запросу</p></td>
</tr>

<tr>
<td valign="top" ><p>execute</p></td>
<td valign="top" ><p>Метод исполнения переданного SQL запроса</p></td>
</tr>

<tr>
<td valign="top" ><p>insert</p></td>
<td valign="top" ><p>Метод добавления новой записи по переданному массиву полей и их значений</p></td>
</tr>

<tr>
<td valign="top" ><p>update</p></td>
<td valign="top" ><p>Метод изменения записей по переданному массиву полей и их новых значений</p></td>
</tr>

<tr>
<td valign="top" ><p>remove</p></td>
<td valign="top" ><p>Метод удаления записи по первичному ключу</p></td>
</tr>

<tr>
<td valign="top" ><p>code</p></td>
<td valign="top" ><p>Метод кодирования значений перед записью данных в базу данных</p></td>
</tr>

<tr>
<td valign="top" ><p>decode</p></td>
<td valign="top" ><p>Метод декодирования значений, полученных из базы данных</p></td>
</tr>

<tr>
<td valign="top" ><p>IsTime</p></td>
<td valign="top" ><p>Метод определения принадлежности типа поля таблицы к типу «время»</p></td>
</tr>

<tr>
<td valign="top" ><p>IsText</p></td>
<td valign="top" ><p>Метод определения принадлежности типа поля таблицы к типу «текст»</p></td>
</tr>

<tr>
<td valign="top" ><p>IsNumber</p></td>
<td valign="top" ><p>Метод определения принадлежности типа поля таблицы к типу «число»</p></td>
</tr>

<tr>
<td valign="top" ><p>IsBlob</p></td>
<td valign="top" ><p>Метод определения принадлежности типа поля таблицы к типу «бинарный»</p></td>
</tr>

<tr>
<td valign="top" ><p>IsAggregateFunction</p></td>
<td valign="top" ><p>Метод принадлежности SQL функции к агрегатным функциям</p></td>
</tr>

<tr>
<td valign="top" ><p>localdatetime</p></td>
<td valign="top" ><p>Метод для формирования даты и времени в локальном формате</p></td>
</tr>

<tr>
<td valign="top" ><p>localdate</p></td>
<td valign="top" ><p>Метод для формирования даты в локальном формате</p></td>
</tr>

</tbody>
</table>

<p>Конструктор класса должен также содержать формирование массива соответствия кодов операций сравнения, используемых в предикатах, с их SQL эквивалентами данной СУБД. </p>

<p>Компоненты <b>Form</b> и <b>Grid</b> сами создают все необходимые SQL запросы, и разработчик избавлен от ручного кодирования SQL запросов для стандартных операций ввода, вывода и поиска данных. </p>

<h1>Работа со списками</h1>

<p>Списки бывают постоянные и переменные. Опции постоянных списков хранятся в системной таблице. Переменные списки формируются из записей таблиц. Спецификации списков хранятся в специальной таблице fgs_list. Опции постоянных списков хранятся в системной таблице fgs_option. </p>

<p>Примеры постоянных списков: </p>

<ul>
<li>Список их 2-х опций: Да и Нет</li>
<li>Список дней недели</li>
<li>Список названий месяцев</li>
</ul>

<p>Переменный список основан на записях определенной таблицы. Первичный ключ этой таблицы используются как значение опции, а текстовое поле как описание опции. Для ограничения опций списка можно использовать определенный набор данных. </p>

<p>Списки используются как для ввода, так и вывода данных.</p>

<p>Для ввода данных используются компоненты выбора одной (<b>InputSingleSelect</b>) или нескольких опций списка (<b>InputMultipleSelect</b>).</p>

<p>Списки используются для вывода текстового представления полей таблиц с помощью компонента <b>ColumnLookup</b>. Например, вместо кода компании можно выводить название компании. Если поле принимает только два значения 0 и 1, то можно вместо них выводить Да или Нет. </p>

<p>Обычно, если поле вводится с помощью выбора одной или нескольких опций списка, то для вывода этого поля используется тот же самый список.</p>

<p>Механизм работы со списками зависит от типа списка – постоянный или переменный. </p>

<p>Рассмотрим разницу работы с постоянными и переменными списками на следующем примере.</p>

<p>Пусть в форме используется элемент ввода с типом ввода select. Если тип списка опций постоянный, конфигуратор создает спецификацию этого элемента со списком опций, который и используется фреймворком. Если же тип списка переменный, то спецификация содержит только параметры списка. Загрузка опций осуществляется объектом <b>ListLoader</b>, которому передаются параметры списка. <b>ListLoader</b> по переданным параметрам формирует Sql запрос на выборку опций из таблицы и, если он ранее не загружал список с таким SQL запросом, выполняет загрузку списка. В противном случае он возвращает ранее сформированный список.</p>

<p>Поскольку один и тот же самый список может использоваться разными компонентами, то данный механизм минимизирует количество SQL запросов к базе данных при формировании динамических списков.</p>

<h1>Условия и утверждения</h1>

<p>Компоненты ввода автоматически осуществляют простейшие проверки вводимых данных.</p>

<p>Для более сложной валидации вводимых данных введены понятия условие (condition) и утверждение (statement). Одно условие может содержать несколько утверждений. </p>

<p>Утверждение в общем случае представляет собой логическое выражение:</p>

<p>&lt;Операнд 1&gt; операция сравнения &lt; Операнд 2&gt; </p>

<p>Таким образом, валидация вводимых данных заключается в проверке правильности утверждений. </p>

<p>Условия можно применять также для ограничения действий над записями таблицы или вывода определенных полей. Например, можно разрешить редактирование и удаление только пользователям с определенной ролью. </p>

<p>Утверждения являются развитием понятия предикатов применительно к задаче валидации вводимых данных. Как и предикаты, утверждения могут быть объединены в логические группы. Различие между этими понятиями в том, что проверка предикатов осуществляется СУБД, а проверка утверждений компонентами фреймворка <b>ConditionTester</b> и <b>Validator</b>. При этом компонент <b>ConditionTester</b> осуществляет проверку стандартных утверждений, а <b>Validator</b> нестандартных.</p>

<p>Умело комбинируя и конфигурируя утверждения можно реализовать самые сложные условия проверки вводимых данных </p>

<h1>Поддержка Ajax</h1>

<p>Фреймворк имеет встроенную поддержку ввода полей ввода типа autocomplete, зависимых select (chained select’s), режима inline editing записей, выводимых компонентом <b>Grid</b> и автоматическую привязку jQuery плагина Datepicker к полям ввода дат. При этом никакого дополнительного кодирования на JavaScript, SQL или PHP не требуется.</p>

<p>Рассмотрим более подробно реализованный механизм поддержки Ajax.</p>

<p>Специальный компонент jQuery передает всю необходимую информации в JavaScript в формате JSON. </p>

<p>Для поддержки Ajax предназначены следующие файлы:</p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>файл</p></td>
<td valign="top" ><p>Назначение</p></td>
</tr>

<tr>
<td valign="top" ><p>fgs.js</p></td>
<td valign="top" ><p>Набор JavaScript функций</p></td>
</tr>

<tr>
<td valign="top" ><p>autocomplete.php</p></td>
<td valign="top" ><p>Обработчик Ajax запросов полей ввода типа autocomplete</p></td>
</tr>

<tr>
<td valign="top" ><p>cell_edit.php</p></td>
<td valign="top" ><p>Обработчик Ajax запросов при inline editing</p></td>
</tr>

<tr>
<td valign="top" ><p>list.php</p></td>
<td valign="top" ><p>Обработчик Ajax запросов для зависимых select (chained selects)</p></td>
</tr>

<tr>
<td valign="top" ><p>toggleDebug.php</p></td>
<td valign="top" ><p>Обработчик Ajax запросов для включения или отключения режима отладки</p></td>
</tr>

<tr>
<td valign="top" ><p>toggleFGS.php</p></td>
<td valign="top" ><p>Обработчик Ajax запросов для показа или скрытия компонентов типа <b>Form</b>, <b>Grid</b> или <b>Search</b></p></td>
</tr>

<tr>
<td valign="top" ><p>toggleMenu.php</p></td>
<td valign="top" ><p>Обработчик Ajax запросов для показа или скрытия меню</p></td>
</tr>

</tbody>
</table>

<p>Фреймворк использует фреймворк jQuery.</p>

<p>Компонент jQuery добавляет следующий кусочек кода на JavaScript для всех формируемых страниц:</p>

<p>$(document).ready(initControls)</p>

<p>Функция initControls находится в файле fgs.js и вызывает последовательно функции:</p>

<ul>
<li>initDataPicker для привязки плагина jQuery Datepicker к полям ввода дат</li>
<li>initAutocomplete для привязки плагина jQuery autocomplete к полям ввода типа autocomplete</li>
<li>inlineEdit – для привязки необходимых JavaScript событий к полям, редактируемым в режиме inline editing (компонент <b>Grid</b>)</li>
</ul>

<p>Обработчик Ajax запросов полей ввода типа autocomplete (autocomplete.php) получает в качестве одного из параметров системный код элемента ввода. По этому коду загружается спецификация данного элемента, на основе которой и создается объект компонента ввода. Затем загрузчик списков <b>ListLoader</b>, используя атрибуты созданного объекта, формирует необходимый список. Далее список трансформируется в нужный формат и передается клиенту. </p>

<p>Обработчик Ajax запросов для зависимых select (chained selects) (list.php) получает в качестве одного из параметров системный код элемента ввода. По этому системному коду загружается спецификация данного элемента, на основе которой и создается объект компонента ввода. Затем созданный объект формирует свой HTML код и передает его клиенту. </p>

<p>Обработчик Ajax запросов при inline editing (cell_edit.php) получает в качестве одного из параметров системный код колонки ввода. По этому коду загружается спецификация данной колонки, на основе которой и создается объект колонки ввода. Затем полученное значение редактируемого поля проверяется и, в случае отсутствия ошибок, записывается измененное значение в базу данных.</p>

<h1>Использование расширений стандартных компонент</h1>

<p>При разработке реального веб- приложения будут возникать проблемы, которые нельзя будет решить использованием стандартных компонент фреймворка. </p>

<p>Спецификации компонент содержат атрибуты, определяющие названия расширений компонент, реализующих нужный функционал. Например, в спецификации компонента <b>Unit</b> можно указывать собственные классы контроллера, компонент форм ввода, грида, формы поиска или набора данных, а также собственные классы шаблонов компонент. В спецификации списка можно указать свой класс загрузчика опций списка. Можно использовать свои классы валидаторов, условий и предикатов. </p>

<p>При необходимости использования нестандартных визуализаторов компонент нужно конфигурировать свойство «визуализатор» компонент. При этом значение свойства «визуализатор» используется как название класса со статичным методом «render».</p>

<p>Расширения стандартных компонент должны соответствовать некоторым условиям. В описании каждого компонента приводится информация о возможности добавления отсутствующего функционала и условия, которым должны удовлетворять пользовательские классы компонент.</p>

<p>Нужно подчеркнуть, что единственным способом расширения фреймворка является написание расширений стандартных компонент.</p>

<h1>Компонент Evaluator</h1>

<p>Компонент <b>Evaluator</b> является важнейшим компонентом, обеспечивающим другим компонентам фреймворка доступ к данным, которые становятся известны только в момент исполнения скрипта. Можно привести в качестве примера идентификатор, роль пользователя или данные, введенные пользователем.</p>

<p>Компонент <b>Evaluator</b> используется для вычисления значения выражений во время исполнения скриптов. </p>

<p>Компонент имеет единственный статический метод «get», которому передаются в качестве аргументов оцениваемое выражение и необязательный параметр вычисления выражения. Если нужно передать несколько параметров, то их нужно передавать в одном массиве.</p>

<p>Выражения, передаваемые в метод get, должны оформляться по строго определенным правилам. Некоторые символы служат как директивы для вычисления выражения.</p>

<p>Если первым символом оцениваемого выражения является символ «#», то для оценки выражения используется функция eval.</p>

<p>Если первым символом оцениваемого выражения является символ «@», то оцениваемое выражение, начиная со второго символа, рассматривается как функция в случае существования такой функции или как название статического класса с методом «get». </p>

<p>Если первым символом оцениваемого выражения является символ «&amp;», то из оцениваемого выражения выделяются идентификатор источника данных (три символа со второго по четвертый) и название переменной (остальная часть без концевых пробелов). </p>

<p>Если первый символ выражения не равен «#»,«@» и «&amp;», то возвращается само оцениваемое выражение.</p>

<p>Расшифровка источника данных приведена в таблице:</p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>Id источника данных</p></td>
<td valign="top" ><p>Источник данных</p></td>
<td valign="top" ><p>Значение переменной</p></td>
</tr>

<tr>
<td valign="top" ><p>ses</p></td>
<td valign="top" ><p>$_SESSION</p></td>
<td valign="top" ><p>Индекс массива</p></td>
</tr>

<tr>
<td valign="top" ><p>glb</p></td>
<td valign="top" ><p>$GLOBALS</p></td>
<td valign="top" ><p>Индекс массива</p></td>
</tr>

<tr>
<td valign="top" ><p>srv</p></td>
<td valign="top" ><p>$_SERVER</p></td>
<td valign="top" ><p>Индекс массива</p></td>
</tr>

<tr>
<td valign="top" ><p>env</p></td>
<td valign="top" ><p>$_ENV</p></td>
<td valign="top" ><p>Индекс массива</p></td>
</tr>

<tr>
<td valign="top" ><p>req</p></td>
<td valign="top" ><p>$_REQUEST</p></td>
<td valign="top" ><p>Индекс массива</p></td>
</tr>

<tr>
<td valign="top" ><p>coo</p></td>
<td valign="top" ><p>$_COOKIE</p></td>
<td valign="top" ><p>Индекс массива</p></td>
</tr>

<tr>
<td valign="top" ><p>rgv</p></td>
<td valign="top" ><p>Массив $globals компонента <b>Registry</b></p></td>
<td valign="top" ><p>Индекс массива</p></td>
</tr>

<tr>
<td valign="top" ><p>arg</p></td>
<td valign="top" ><p>Массив параметров, переданный в метод </p></td>
<td valign="top" ><p>Индекс массива</p></td>
</tr>

<tr>
<td valign="top" ><p>usr</p></td>
<td valign="top" ><p>Массив данных залогиненного пользователя </p></td>
<td valign="top" ><p>Индекс массива</p></td>
</tr>

</tbody>
</table>
<br>
<h1>Компонент Registry</h1>

<p>Компонент <b>Registry</b> играет важную роль во фреймворке. Он обеспечивает:</p>

<ul>
<li>обмен информации между компонентами, являясь, фактически, хранилищем данных приложения, имеющих глобальную область видимости</li>
<li>сохранение и восстановление состояния компонент</li>
<li>имитацию разных сессий в одном окне браузера</li>
<li>интерфейс к глобальным данным приложения</li>
<li>интерфейс к данным залогиненного пользователя</li>
<li>хранение отладочной информации (при установке хранения отладочной информации в <b>Registry</b>)</li>
<li>формирование обязательных параметров для однозначной идентификации GET и POST запросов (fgsw, fgsc, fgsu,fgst)</li>
</ul>

<p>Параметры состояния компонент <b>Registry</b> сохраняет в элементе массива $_SESSION с ключом, равным константе FGS_SESSION_KEY. FGS_SESSION_KEY не должен совпадать с существующими сессионными переменными. </p>

<p><b>Registry</b> использует еще одну константу FGS_CONTROLLER_KEY, со значением которой не должны совпадать коды создаваемых <b>Unit</b>. FGS_CONTROLLER_KEY также не должен быть равен controller, form, grid, search, element, operator, connector, argument, argumentMin или argumentMax.</p>

<p>Рассмотрим, какие параметры и где хранит <b>Registry</b>.</p>

<p>Код контроллера текущего окна <b>Registry</b>: </p>

<p>$_SESSION[FGS_SESSION_KEY][ код окна][FGS_CONTROLLER_KEY] ['controller']</p>

<p>Признак успешного завершения скрипта</p>

<p>$_SESSION[FGS_SESSION_KEY][ код окна][FGS_CONTROLLER_KEY] ['end']</p>

<p>Параметры контроллера:</p>

<p>$_SESSION[FGS_SESSION_KEY][ код окна] ['controller'] [название параметра]</p>

<p>Параметры состояния <b>Unit</b>:</p>

<p>$_SESSION[FGS_SESSION_KEY][ код окна] [код Unit] ['controller'] [название параметра]</p>

<p>Параметры состояния <b>Form</b>:</p>

<p>$_SESSION[FGS_SESSION_KEY][ код окна] [код Unit] [‘form’] [название параметра]</p>

<p>Значения элементов <b>Form</b>:</p>

<p>$_SESSION[FGS_SESSION_KEY][ код окна] [код Unit] [‘element] [атрибут rowid]</p>

<p>Параметры состояния <b>Grid</b>:</p>

<p>$_SESSION[FGS_SESSION_KEY][ код окна] [код Unit] [‘grid’] [название параметра]</p>

<p>Параметры состояния <b>Search</b>:</p>

<p>$_SESSION[FGS_SESSION_KEY][ код окна] [код Unit] [‘search’] [название параметра]</p>

<p>Значения коннекторов <b>Search</b>:</p>

<p>$_SESSION[FGS_SESSION_KEY][ код окна] [код Unit] [‘connector’] [атрибут rowid]</p>

<p>Значения операторов <b>Search</b>:</p>

<p>$_SESSION[FGS_SESSION_KEY][ код окна] [код Unit] [‘operator’] [атрибут rowid]</p>

<p>Значения аргументов <b>Search</b>:</p>

<p>$_SESSION[FGS_SESSION_KEY][ код окна] [код Unit] [‘argument’] [атрибут rowid]</p>

<p>Значение минимального аргумента для предиката типа «диапазон» <b>Search</b>:</p>

<p>$_SESSION[FGS_SESSION_KEY][ код окна] [код Unit] [‘argumentMin’] [атрибут rowid]</p>

<p>Значение максимального аргумента для предиката типа «диапазон» <b>Search</b>:</p>

<p>$_SESSION[FGS_SESSION_KEY][ код окна] [код Unit] [‘argumentMax’] [атрибут rowid]</p>

<p>Компонент <b>Registry</b> разработан с использованием шаблона проектирования <b>Singleton</b>.</p>

<p>Свойства <b>Registry</b></p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>свойство</p></td>
<td valign="top" ><p>назначение</p></td>
</tr>

<tr>
<td valign="top" ><p>window</p></td>
<td valign="top" ><p>Код окна текущего запроса</p></td>
</tr>

<tr>
<td valign="top" ><p>store</p></td>
<td valign="top" ><p>Многомерный массив, служащий для обмена данными между компонентами </p></td>
</tr>

<tr>
<td valign="top" ><p>globals</p></td>
<td valign="top" ><p>Массив глобальных данных скрипта</p></td>
</tr>

<tr>
<td valign="top" ><p>vars</p></td>
<td valign="top" ><p>Массив для хранения значений отслеживаемых переменных при отладке</p></td>
</tr>

<tr>
<td valign="top" ><p>requests</p></td>
<td valign="top" ><p>Массив для хранения вызовов методов обработчиков запросов и событий при отладке</p></td>
</tr>

<tr>
<td valign="top" ><p>sql</p></td>
<td valign="top" ><p>Метод хранения результатов выполнения SQL запросов при отладке</p></td>
</tr>

<tr>
<td valign="top" ><p>class</p></td>
<td valign="top" ><p>Массив для хранения используемых классов при отладке</p></td>
</tr>

<tr>
<td valign="top" ><p>exportErrors</p></td>
<td valign="top" ><p>Массив для хранения ошибок в спецификациях при экспорте</p></td>
</tr>

</tbody>
</table>

<p>Методы <b>Registry</b></p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>метод</p></td>
<td valign="top" ><p>назначение</p></td>
</tr>

<tr>
<td valign="top" ><p>getInstance</p></td>
<td valign="top" ><p>Получение единственного экземпляра класса</p></td>
</tr>

<tr>
<td valign="top" ><p>__construct</p></td>
<td valign="top" ><p>Конструктор класса должен быть типа private.</p></td>
</tr>

<tr>
<td valign="top" ><p>setGlobal($var,$value)</p></td>
<td valign="top" ><p>метод записывает значение ($value) переменной $var в массив globals компонента</p></td>
</tr>

<tr>
<td valign="top" ><p>getGlobal($var)</p></td>
<td valign="top" ><p>Метод возвращает значение переменной $var из массива globals компонента</p></td>
</tr>

<tr>
<td valign="top" ><p>getController()</p></td>
<td valign="top" ><p>Метод определения кода контроллера запроса</p></td>
</tr>

<tr>
<td valign="top" ><p>newController()</p></td>
<td valign="top" ><p>Метод для самого первого выполнения контроллера </p></td>
</tr>

<tr>
<td valign="top" ><p>getWindow()</p></td>
<td valign="top" ><p>Метод определения кода окна запроса</p></td>
</tr>

<tr>
<td valign="top" ><p>set($unit, $component,$variable,$value)</p></td>
<td valign="top" ><p>Метод записи в массив store значения $value переменной $variable, относящейся к компоненту $component в <b>Unit</b> с кодом $unit</p></td>
</tr>

<tr>
<td valign="top" ><p>get($unit, $component,$variable)</p></td>
<td valign="top" ><p>Метод для получения из массива store значения переменной $variable, относящейся к компоненту $component в <b>Unit</b> с кодом $unit</p></td>
</tr>

<tr>
<td valign="top" ><p>saveState($obj,$component,$unit=null)</p></td>
<td valign="top" ><p>Метод для сохранения состояния компонента $obj типа $component из <b>Unit</b> с кодом $unit </p></td>
</tr>

<tr>
<td valign="top" ><p>restoreState(&amp;$obj,$component,$unit=null)</p></td>
<td valign="top" ><p>Метод для восстановления состояния компонента $obj типа $component из <b>Unit</b> с кодом $unit</p></td>
</tr>

<tr>
<td valign="top" ><p>fgsHidden($unit, $component)</p></td>
<td valign="top" ><p>Метод для получения HTML-кода для дополнительных скрытых полей ввода, которые необходимо добавлять в формы компонент $sid из <b>Unit</b> с кодом $unit</p></td>
</tr>

<tr>
<td valign="top" ><p>fgsRef($unit $component)</p></td>
<td valign="top" ><p>Метод для получения дополнительных параметров, которые необходимо добавлять в гиперссылки, формируемые компонентом $component из <b>Unit</b> с кодом $unit</p></td>
</tr>

<tr>
<td valign="top" ><p>fgsToggle($unit,$sid $component)</p></td>
<td valign="top" ><p>Метод показа/скрытия компонента $component с кодом $sid из <b>Unit</b> с кодом $unit</p></td>
</tr>

<tr>
<td valign="top" ><p>checkLogin()</p></td>
<td valign="top" ><p>Метод проверки факт логина пользователя</p></td>
</tr>

<tr>
<td valign="top" ><p>setUser($a)</p></td>
<td valign="top" ><p>Метод записи данных залогиненного пользователя в сессионных переменных</p></td>
</tr>

<tr>
<td valign="top" ><p>getUser()</p></td>
<td valign="top" ><p>Метод получения данных залогиненного пользователя из сессионных переменных</p></td>
</tr>

<tr>
<td valign="top" ><p>getUserRole()</p></td>
<td valign="top" ><p>Метод получения роли залогиненного пользователя</p></td>
</tr>

<tr>
<td valign="top" ><p>getUserId()</p></td>
<td valign="top" ><p>Метод получения id залогиненного пользователя</p></td>
</tr>

</tbody>
</table>
<br>
<h1>Абстрактный компонент Component</h1>

<p>Компоненты <b>Form</b>, <b>Grid</b>, <b>Search</b> и <b>Dataset</b> являются расширениями компонента <b>Component</b></p>

<p>Свойства <b>Component</b></p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>свойство</p></td>
<td valign="top" ><p>назначение</p></td>
</tr>

<tr>
<td valign="top" ><p>$unit</p></td>
<td valign="top" ><p>Код <b>Unit</b></p></td>
</tr>

<tr>
<td valign="top" ><p>$sid</p></td>
<td valign="top" ><p>Код компонента </p></td>
</tr>

<tr>
<td valign="top" ><p>$type</p></td>
<td valign="top" ><p>Тип компонента</p></td>
</tr>

<tr>
<td valign="top" ><p>$session</p></td>
<td valign="top" ><p>Массив для хранения переменных состояния компонента, подлежащих хранению и восстановлению</p></td>
</tr>

<tr>
<td valign="top" ><p>$initial</p></td>
<td valign="top" ><p>Ассоциативный массив для хранения начальных значений свойств компонента</p></td>
</tr>

<tr>
<td valign="top" ><p>$errors</p></td>
<td valign="top" ><p>Массив ошибок компонента</p></td>
</tr>

<tr>
<td valign="top" ><p>$table</p></td>
<td valign="top" ><p>Базовая таблица компонента</p></td>
</tr>

<tr>
<td valign="top" ><p>$display</p></td>
<td valign="top" ><p>Признак показа/скрытия компонента</p></td>
</tr>

</tbody>
</table>

<p>Методы <b>Component</b></p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>метод</p></td>
<td valign="top" ><p>назначение</p></td>
</tr>

<tr>
<td valign="top" ><p>__construct($unit,$sid,$hide)</p>

</td>
<td valign="top" ><p>Конструктор компонента с кодом $sid из <b>Unit</b> с кодом $unit и массивом $hide, определяющим логику показа/скрытия компонента</p></td>
</tr>

<tr>
<td valign="top" ><p>saveState()</p></td>
<td valign="top" ><p>Метод сохранения состояния компонента</p></td>
</tr>

<tr>
<td valign="top" ><p>restoreState()</p></td>
<td valign="top" ><p>Метод восстановления состояния компонента</p></td>
</tr>

<tr>
<td valign="top" ><p>hide()</p></td>
<td valign="top" ><p>Метод показа/скрытия компонента</p></td>
</tr>

</tbody>
</table>
<br>
<h1>Компонент Form</h1>

<p>Компонент <b>Form</b> является аналогом HTML элемента «form» и предназначен для ввода данных в таблицы (форма ввода). С помощью формы ввода можно вводить данные только в одну таблицу, которая называется базовой.</p>

<p>Форма ввода является контейнером для компонент 2 видов:</p>

<p>Элементы ввода </p>

<p>Кнопки </p>

<p>Форма ввода и принадлежащие ей компоненты обладают свойствами «текущий режим ввода» (mode) и «возможные режимы ввода» (modes). Например, для стандартной формы ввода обычно существуют следующие режимы:</p>

<p>Режим вставки новой записи (insert)</p>

<p>Режим редактирования записи (update)</p>

<p>Режим удаления записи (remove)</p>

<p>Режим просмотра записи (Read)</p>

<p>Режим поиска записи (seek)</p>

<p>Режим «поиск записи» обычно используется для форм входа на сайт, когда пользователь вводит логии и пароль для входа.</p>

<p>Также для формы ввода возможны так называемые режимы для последовательной обработки набора записей:</p>

<p>Режим последовательного редактирования набора записей (MultiUpdate)</p>

<p>Режим последовательного удаления набора записей (MultiRemove)</p>

<p>Режим последовательного просмотра набора записей (MultiRead)</p>

<p>Режимы последовательной обработки набора записей возникают при выборе пользователем действия над выбранными записями в компоненте <b>Grid</b> общего <b>Unit</b>. Пользователь может последовательно выполнить редактирование или удаление выбранных записей. </p>

<p>Следует отметить, что режимов редактирования у формы ввода может быть несколько. Приведем пример целесообразности использования дополнительного режима редактирования на примере таблицы пользователей. В стандартном режиме редактирования можно редактировать все поля, кроме полей логина и пароля пользователя, а редактировать эти поля только в специальном режиме редактирования update_partial.</p>

<p>Возможные режимы формы ввода позволяют иметь различный набор элементов ввода при вводе новой записи, при редактировании существующих записей, при удалении и просмотре записей, используя одну и ту же спецификацию формы ввода. </p>

<p>Также для формы ввода вводится понятие стартового режима, т.е. режима, который устанавливается при инициализации формы ввода. Понятие стартового режима введено для форм ввода, предназначенных исключительно для выполнения только одного действия над данными (редактирование, удаление, поиск и т.п.).</p>

<p>Свойство «session» компонента <b>Form</b> зависит от текущего режима. </p>

<p>При удалении записи мастер таблицы удаляются все соответствующие записи detail таблиц (cascade removing).</p>

<p>При изменении первичного ключа таблицы изменяются все соответствующие ему внешние ключи (cascade updating) зависимых таблиц.</p>

<p>Форма ввода может иметь так называемые триггеры, т.е. действия, выполняемые до и после действия:</p>

<p>Триггер before insert</p>

<p>Триггер after insert</p>

<p>Триггер before update</p>

<p>Триггер after update</p>

<p>Триггер before remove</p>

<p>Триггер after remove</p>

<p>Триггер before seek</p>

<p>Триггер after seek</p>

<p>Стандартный компонент <b>Form</b> содержит функции - заглушки вместо триггеров. Поэтому при необходимости использования триггеров потребуется написание расширения стандартного компонента <b>Form</b> и указания названия своего компонента формы ввода в спецификации <b>Unit</b>, в состав которого входит данная форма ввода. </p>

<p>В некоторых случаях в SQL запросе на выборку записи необходимо выполнять объединение таблиц (table join). Для этого при конфигурировании нужно использовать специальный псевдо компонент <b>ElementTableJoiner</b>. Этот псевдо компонент нужен конфигуратору только для формирования свойства joins формы ввода. Компонент <b>Form</b> использует свойство joins для объединения нужных таблиц для целевого SQL запроса. Тип объединения таблиц всегда left join. Пример использования объединения таблиц приведен в Руководстве Конфигуратора.</p>

<p>Форма ввода входит в состав компонента <b>Unit</b>. Форма ввода может взаимодействовать только с контроллером и гридом этого же <b>Unit</b>. При генерации события гридом, форма ввода по данным события устанавливает соответствующий режим ввода. Данные события обязательно содержат также массив первичных ключей записей, подлежащих обработке. После завершения действия, форма генерирует событие, обработчиком которого является контроллер. </p>

<p>В интерфейсах <b>MasterDetail</b> и <b>UnitSet</b>, master <b>Grid</b> может генерировать событие «detail», обработчиком которого является detail <b> Form </b>и detail Grid. Для того чтобы detail <b> Form </b>могла добавлять новые записи, необходимо чтобы detail <b> Form </b>была сконфигурирована со специальным псевдо компонентом InputForeignKey. При экспорте InputForeignKey трансформируется в компонент <b>InputSystem</b> со свойством «foreign_key». </p>

<p>В связи с принятым алгоритмом обработки запросов, рендеринг формы должен включать добавление системных скрытых полей ввода fgsw, fgsc, fgsu и fgst. HTML код этих переменных формируется методом fgsHidden компонента <b>Registry</b>, в который нужно передавать в качестве аргументов код <b>Unit</b> формы и значение «form». </p>

<p>Кнопки формы</p>

<p>Кнопкам формы соответствует компонент <b>InputButton</b>. Основными атрибутами этого компонента являются следующие атрибуты:</p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>Поле </p></td>
<td valign="top" ><p>Ярлык </p></td>
<td valign="top" ><p>Назначение </p></td>
</tr>

<tr>
<td valign="top" ><p>element_action</p></td>
<td valign="top" ><p>Действие</p></td>
<td valign="top" ><p>Действие, осуществляемое при нажатии на кнопку</p></td>
</tr>

<tr>
<td valign="top" ><p>element_event</p></td>
<td valign="top" ><p>Событие</p></td>
<td valign="top" ><p>Событие, генерируемое формой по завершении действия.</p></td>
</tr>

<tr>
<td valign="top" ><p>element_confirm</p></td>
<td valign="top" ><p>Подтвердить ?</p></td>
<td valign="top" ><p>Признак подтверждения действия при нажатии на кнопку</p></td>
</tr>

<tr>
<td valign="top" ><p>element_name</p></td>
<td valign="top" ><p>Атрибут name</p></td>
<td valign="top" ><p>Атрибут name кнопки</p></td>
</tr>

<tr>
<td valign="top" ><p>element_value</p></td>
<td valign="top" ><p>Значение</p></td>
<td valign="top" ><p>Атрибут value кнопки</p></td>
</tr>

</tbody>
</table>

<p>Формы ввода регистрируют в качестве запросов компоненты <b>InputButton</b>. </p>

<p>Элементы ввода формы</p>

<p>Элементам ввода формы соответствуют компоненты</p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>компонент</p></td>
<td valign="top" ><p>назначение</p></td>
</tr>

<tr>
<td valign="top" ><p><b>InputAutocomplete</b></p></td>
<td valign="top" ><p>Для ввода значений с помощью autocomplete</p></td>
</tr>

<tr>
<td valign="top" ><p><b>InputMultipleAutocomplete</b></p></td>
<td valign="top" ><p>Для ввода значений с помощью autocomplete</p></td>
</tr>

<tr>
<td valign="top" ><p><b>InputDate</b></p></td>
<td valign="top" ><p>Для ввода значений типа date в локальном формате</p></td>
</tr>

<tr>
<td valign="top" ><p><b>InputDatetime</b></p></td>
<td valign="top" ><p>Для ввода значений типа datetime в локальном формате</p></td>
</tr>

<tr>
<td valign="top" ><p><b>InputFile</b></p></td>
<td valign="top" ><p>Для загрузки файлов на сервер</p></td>
</tr>

<tr>
<td valign="top" ><p><b>InputHidden</b></p></td>
<td valign="top" ><p>Для полей ввода типа hidden</p></td>
</tr>

<tr>
<td valign="top" ><p><b>InputMultipleSelect</b></p></td>
<td valign="top" ><p>Для ввода значений путем выбора нескольких опций из списка</p></td>
</tr>

<tr>
<td valign="top" ><p><b>InputSecret</b></p></td>
<td valign="top" ><p>Для полей ввода типа password</p></td>
</tr>

<tr>
<td valign="top" ><p><b>InputSingleSelect</b></p></td>
<td valign="top" ><p>Для ввода значений путем выбора одной опции из списка</p></td>
</tr>

<tr>
<td valign="top" ><p><b>InputSystem</b></p></td>
<td valign="top" ><p>Для скрытого ввода служебных полей</p></td>
</tr>

<tr>
<td valign="top" ><p><b>InputText</b></p></td>
<td valign="top" ><p>Для полей ввода типа text</p></td>
</tr>

<tr>
<td valign="top" ><p><b>InputTextarea</b></p></td>
<td valign="top" ><p>Для ввода данных с помощью textarea</p></td>
</tr>

<tr>
<td valign="top" ><p><b>InputTime</b></p></td>
<td valign="top" ><p>Для ввода значений типа time</p></td>
</tr>

<tr>
<td valign="top" ><p><b>SelectBooleanCheckbox</b></p></td>
<td valign="top" ><p>Для ввода булевских значений true/false</p></td>
</tr>

</tbody>
</table>

<p>Все компоненты элементов ввода наследуются от абстрактного класса <b>InputElement</b>. Значения элементов ввода сохраняются в сессионных переменных.</p>

<p>Некоторые компоненты имеют свой внутренний формат хранения значения. Для таких компонент при получении данных из базы данных происходит декодирование, а при записи данных в базу данных – кодирование значения компонента. Операции кодирования и декодирования значений выполняет драйвер базы данных.</p>

<p>Компонент <b>InputMultipleAutocomplete</b> предназначен для ввода нескольких значений, разделенных токеном, а <b>InputAutocomplete</b> только одного с помощью autocomplete. </p>

<p>Для компонентов <b>InputDate</b>, <b>InputDatetime</b> и <b>InputTime</b> внутренним форматом хранения значений выбран ассоциативный массив элементов дата или времени (год, месяц, день, час, минута, секунда).</p>

<p>Иногда необходимо значения компонент ввода поместить в глобальную область видимости. Для этого каждый компонент имеет свойство register. Если этот свойство установлено, то значение компонента помещается в массив globals компонента <b>Registry</b> с индексом, равным этому свойству register. </p>

<p>Под компонентом <b>InputMultipleSelect</b> скрываются 3 компонента <b>SelectManyCheckbox</b>, <b>SelectManyListbox</b> и <b>SelectManyMenu</b>. Поскольку с точки зрения обработки они ничем не отличаются, а отличаются только формированием HTML кода, т.е. рендерингом, то, в зависимости от требований к форме ввода, выбирается и конфигурируется один из этих трех компонент. Однако при создании в качестве компонента используется именно <b>InputMultipleSelect</b> с соответствующим значением свойства renderer. Для компонента <b>InputMultipleSelect</b> внутренним форматом хранения значения является массив значений выбранных опций списка.</p>

<p>Аналогично под компонентом <b>InputSingleSelect</b> скрываются 3 компонента <b>SelectOneListbox</b>, <b>SelectOneMenu</b> и <b>SelectOneRadio</b>. В зависимости от требований к форме, выбирается и конфигурируется соответствующий компонент, а при создании в качестве компонента используется <b>InputSingleSelect</b> с соответствующим значением свойства renderer. </p>

<p>Компонент <b>InputSecret</b> при записи в базу данных использует преобразование введенного значения с помощью функции md5. </p>

<p>Компонент <b>InputFile</b> предназначен для загрузки файлов на сервер. Основными обязательными атрибутами этого компонента являются следующие:</p>

<ul>
<li>Каталог хранения загружаемых файлов</li>
<li>Максимальный размер загружаемых файлов</li>
<li>Допустимые расширения загружаемых файлов</li>
</ul>

<p>Стандартный компонент <b>InputFile</b> осуществляет загрузку файлов следующим образом:</p>

<ul>
<li>Загружаемый файл записывается в нужный каталог</li>
<li>Название файла записывается в поле таблицы без изменения</li>
<li>Если поле ввода обязательное, то в режиме «insert» при отсутствии загрузки выдается ошибка, а в режиме «update»-нет. </li>
</ul>

<p>Поскольку загрузка файлов на сервер может быть сопровождаться различными действиями, то для компонента <b>InputFile</b> предусмотрен необязательный атрибут «extension» для ввода названия своего класса компонента. Также для выполнения необходимых действий можно использовать триггеры форм ввода. </p>

<p>Компонент <b>InputSystem</b> используется для ввода информации в служебные поля таблиц. </p>

<p>Примеры таких полей:</p>

<ul>
<li>Код пользователя, инициировавшего обновление записи </li>
<li>Дата и время добавления записи</li>
<li>IP-адрес компьютера, с которого осуществляется доступ на сайт</li>
</ul>

<p>Еще одним применением <b>InputSystem</b>, является ввод внешних ключей таблиц в detail Form.</p>

<p>Элементы ввода можно объединять в группы с помощью установки свойства «fieldset». </p>

<p>Компоненты ввода автоматически осуществляют следующие проверки вводимых данных:</p>

<p>-для обязательных элементов ввода проверяется было, введено значение или нет</p>

<p>-для элементов ввода даты или времени проверяется правильность формата введенных данных</p>

<p>-для элементов, выбираемых из списков, проверяется существование выбранных опций во множестве опций списка </p>

<p>Для более сложной валидации вводимых данных предназначены валидаторы. При конфигурировании валидатора обычно вводят:</p>

<ul>
<li>Проверяемое поле</li>
<li>Условие, которому должно удовлетворять вводимые значения</li>
<li>Параметры условия</li>
<li>Тип параметра условия</li>
</ul>

<p>В качестве параметра условия можно указывать значения «элемент ввода», «массив» или «скалярное значение». В свою очередь скалярное значение может быть либо конкретным значением, либо значением, определяемым во время исполнения скрипта. </p>

<p>Используя «массив» как тип параметра условия можно использовать условия, использующие два параметра. Например, условие нахождения значения поля в неком диапазоне.</p>

<p>Используя «элемент ввода» как тип параметра условия можно выполнять проверки значений одного поля ввода с другими полями ввода. Например, при вводе пароля и подтверждения пароля проверять их равенство.</p>

<p>Проверка стандартных условий осуществляется компонентом <b>ConditionTester</b>.</p>

<p>При необходимости использования нестандартных условий в спецификации валидатора нужно указывать:</p>

<ul>
<li>класс нестандартного условия</li>
<li>тип метода проверки (статичный или нестатичный).</li>
</ul>

<p>Название метода проверки должно быть равно «test».</p>

<p>Проверка нестандартных условий осуществляется компонентом <b>Validator</b>. </p>

<p>Для одного поля ввода можно задавать произвольное количество валидаторов. Порядок использования валидаторов задается при конфигурировании.</p>

<p>Фреймворк содержит набор стандартных условий </p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>Код условия</p></td>
<td valign="top" ><p>Условие</p></td>
</tr>

<tr>
<td valign="top" ><p>AlphabeticDigit</p></td>
<td valign="top" ><p>Значение должно содержать только буквы и цифры</p></td>
</tr>

<tr>
<td valign="top" ><p>Digits</p></td>
<td valign="top" ><p>Значение должно содержать только цифры </p></td>
</tr>

<tr>
<td valign="top" ><p>EmailAddress</p></td>
<td valign="top" ><p>Значение должно быть Email адресом</p></td>
</tr>

<tr>
<td valign="top" ><p>Equal</p></td>
<td valign="top" ><p>Значение должно быть равно некоторому значению</p></td>
</tr>

<tr>
<td valign="top" ><p>Float</p></td>
<td valign="top" ><p>Значение должно быть числом с плавающей запятой</p></td>
</tr>

<tr>
<td valign="top" ><p>Greater</p></td>
<td valign="top" ><p>Значение должно быть больше некоторого значения</p></td>
</tr>

<tr>
<td valign="top" ><p>GreaterOrEqual</p></td>
<td valign="top" ><p>Значение должно быть больше или равно некоторому значению</p></td>
</tr>

<tr>
<td valign="top" ><p>InArray</p></td>
<td valign="top" ><p>Значение должно быть элементом массива</p></td>
</tr>

<tr>
<td valign="top" ><p>Integer</p></td>
<td valign="top" ><p>Значение должно быть целым числом</p></td>
</tr>

<tr>
<td valign="top" ><p>Less</p></td>
<td valign="top" ><p>Значение должно быть меньше некоторого значения</p></td>
</tr>

<tr>
<td valign="top" ><p>LessOrEqual</p></td>
<td valign="top" ><p>Значение должно быть меньше ли равно некоторому значению</p></td>
</tr>

<tr>
<td valign="top" ><p>NotInArray</p></td>
<td valign="top" ><p>Значение не должно быть элементом массива</p></td>
</tr>

<tr>
<td valign="top" ><p>OutOfRange</p></td>
<td valign="top" ><p>Значение должно быть вне диапазона</p></td>
</tr>

<tr>
<td valign="top" ><p>Range</p></td>
<td valign="top" ><p>Значение должно быть внутри диапазона</p></td>
</tr>

<tr>
<td valign="top" ><p>Regex</p></td>
<td valign="top" ><p>Строка должна содержать некий шаблон</p></td>
</tr>

<tr>
<td valign="top" ><p>StringLength</p></td>
<td valign="top" ><p>Длина строки должна быть внутри диапазона</p></td>
</tr>

<tr>
<td valign="top" ><p>URL</p></td>
<td valign="top" ><p>Значение должно валидным URL</p></td>
</tr>

</tbody>
</table>

<p>Компонент <b>Form</b> в цикле вызывает метод валидации (validate) всех своих элементов ввода. Аргументом этого метода служит formValue - ассоциативный массив значений всех элементов ввода, а также код формы в элементе массива с индексом «xxx_sid» и режим формы в элементе массива с индексом «xxx_mode». Эти индексы выбраны с целью избежать </p>

<p>совпадения с названиями полей ввода. Элемент ввода в свою очередь организует цикл проверки по всем своим валидаторам. Если указан класс нестандартного валидатора , то вызывается статический метод «test» компонента <b>Validator</b> и компонента <b>ConditionTester</b> в противном случае. При этом в метод «test» компонента <b>Validator</b> передается данные самого валидатора и массив formValue, а в в метод «test» компонента <b>ConditionTester</b> массив утверждений и массив formValue. </p>

<p>Для фильтрации вводимых данных предназначены фильтры ввода.</p>

<p>. Основными атрибутами спецификации фильтры является:</p>

<ul>
<li>Фильтруемое поле</li>
<li>Конвертер значения поля</li>
<li>Параметры фильтрации</li>
<li>Тип параметра фильтрации</li>
</ul>

<p>Как и для валидаторов в качестве параметра фильтрации можно указывать элемент ввода, массив или скалярное значение. </p>

<p>Нужно учесть, что конвертер значения поля является названием класса фильтра.</p>

<p>Фреймворк содержит набор стандартных фильтров </p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>Фильтр</p></td>
<td valign="top" ><p>Условие</p></td>
</tr>

<tr>
<td valign="top" ><p>FilterAlphabeticDigit</p></td>
<td valign="top" ><p>Фильтр удаляет все символы кроме букв и цифр</p></td>
</tr>

<tr>
<td valign="top" ><p>FilterDigits</p></td>
<td valign="top" ><p>Фильтр удаляет все символы кроме цифр</p></td>
</tr>

</tbody>
</table>

<p>Если фильтр должен использоваться при выполнении неких условий, в спецификации фильтра указываются атрибуты, совпадающие с атрибутами для валидаторов:</p>

<ul>
<li>Проверяемое поле</li>
<li>Условие, которому должно удовлетворять вводимые значения</li>
<li>Параметры условия</li>
<li>Тип параметра условия</li>
</ul>

<p>Фреймворк содержит компонент <b>FgsFormView</b> для рендеринга формы ввода и компонент <b>FormKit</b> для рендеринга полей ввода.</p>

<p>Для использования своего компонента для рендеринга формы ввода необходимо указывать название нужного компонента в спецификации <b>Unit</b>, в состав которого входит данная форма ввода. </p>

<p>Если необходим нестандартный рендеринг поля ввода, то необходимо в спецификации поля ввода ввести в атрибут «Визуализатор» название класса, осуществляющего формирование нужного HTML кода поля ввода с помощью статичного метода «render». </p>

<p>Кроме свойств и методов, унаследованных от <b>Component</b>, <b>Form</b> имеет свои свойства и методы.</p>

<p>Свойства <b>Form</b></p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>свойство</p></td>
<td valign="top" ><p>назначение</p></td>
</tr>

<tr>
<td valign="top" ><p>e</p></td>
<td valign="top" ><p>Массив элементов ввода</p></td>
</tr>

<tr>
<td valign="top" ><p>b</p></td>
<td valign="top" ><p>Массив кнопок </p></td>
</tr>

<tr>
<td valign="top" ><p>mode</p></td>
<td valign="top" ><p>Текущий режим ввода </p></td>
</tr>

<tr>
<td valign="top" ><p>apk</p></td>
<td valign="top" ><p>Массив значений первичных ключей редактируемых записей</p></td>
</tr>

<tr>
<td valign="top" ><p>foreign_key</p></td>
<td valign="top" ><p>Значение внешнего ключа для detail таблиц</p></td>
</tr>

<tr>
<td valign="top" ><p>primary_key</p></td>
<td valign="top" ><p>Массив названий полей, являющихся первичными ключами базовой таблицы</p></td>
</tr>

<tr>
<td valign="top" ><p>select</p></td>
<td valign="top" ><p>Предложение select SQL запроса для чтения данных записи</p></td>
</tr>

<tr>
<td valign="top" ><p>from</p></td>
<td valign="top" ><p>Предложение from SQL запроса для чтения данных записи</p></td>
</tr>

<tr>
<td valign="top" ><p>irow</p></td>
<td valign="top" ><p>Индекс текущей записи </p></td>
</tr>

<tr>
<td valign="top" ><p>err</p></td>
<td valign="top" ><p>Массив ошибок при вводе </p></td>
</tr>

<tr>
<td valign="top" ><p>query</p></td>
<td valign="top" ><p>SQL запрос для выборки записи для обработки</p></td>
</tr>

<tr>
<td valign="top" ><p>row</p></td>
<td valign="top" ><p>Данные текущей записи</p></td>
</tr>

<tr>
<td valign="top" ><p>aSession</p></td>
<td valign="top" ><p>Массив переменных состояния в зависимости от режима ввода</p></td>
</tr>

<tr>
<td valign="top" ><p>reference</p></td>
<td valign="top" ><p>Массив полей, являющихся внешними ключами по отношению к базовой таблице </p></td>
</tr>

<tr>
<td valign="top" ><p>descendant</p></td>
<td valign="top" ><p>Массив полей, являющихся внешними ключами по отношению к базовой таблице, а базовая таблица является мастер таблицей</p></td>
</tr>

<tr>
<td valign="top" ><p>dependent</p></td>
<td valign="top" ><p>Массив полей, являющихся внешними ключами по отношению к базовой таблице, а базовая таблица является таблицей справочником </p></td>
</tr>

<tr>
<td valign="top" ><p>eventTrigger</p></td>
<td valign="top" ><p>Массив триггеров событий </p></td>
</tr>

<tr>
<td valign="top" ><p>failure</p></td>
<td valign="top" ><p>Признак ошибки ввода</p></td>
</tr>

<tr>
<td valign="top" ><p>affected_rows</p></td>
<td valign="top" ><p>Количество измененных записей</p></td>
</tr>

<tr>
<td valign="top" ><p>formValue</p></td>
<td valign="top" ><p>Массив значение элементов ввода</p></td>
</tr>

<tr>
<td valign="top" ><p>type</p></td>
<td valign="top" ><p>Тип компонента. Всегда равен 'form'</p></td>
</tr>

</tbody>
</table>

<p>Массивы reference, descendant иdependent используются для обеспечения ссылочной целостности для баз данных, не поддерживающих данных механизм валидации данных перед вводом в базу данных.</p>

<p>Если меняется соответствующий первичный ключ таблицы, то все соответствующие внешние ключи также должны поменяться.</p>

<p>Массив reference используется для выполнения каскадного изменения внешних ключей при изменении первичного ключа базовой таблицы.</p>

<p>Если удаляется запись мастер таблицы, то все записи таблицы detail также должны удаляться. </p>

<p>Если базовая таблица компонента <b> Form </b>является master таблицей, то массив descendant используется для выполнения каскадного удаления записей из detail таблиц при удалении записи из базовой таблицы.</p>

<p>Перед удалением записи справочной таблицы должна происходить проверка наличия записей, ссылающихся на удаляемую запись. Если такие записи существуют, то удаление запрещается. </p>

<p>Если базовая таблица компонента <b> Form </b>является таблицей справочником, то массив dependent используется для проверки выполнения каскадного удаления записей из detail таблиц при удалении записи из базовой таблицы.</p>

<p>Каскадное изменение и удаление и проверка существования ссылок выполняется драйвером конкретной базы данных. Если СУБД поддерживает ссылочную целостность данных, то соответствующие методы не должны выполнять данные операции. </p>

<p>Основные методы Form</p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>метод</p></td>
<td valign="top" ><p>назначение</p></td>
</tr>

<tr>
<td valign="top" ><p>__construct($unit,$sid,$hide)</p></td>
<td valign="top" ><p>Конструктор класса</p>

<p>$unit –код <b>Unit</b></p>

<p>$sid-код формы</p>

<p>$hide – признак показа/скрытия</p></td>
</tr>

<tr>
<td valign="top" ><p>initState($s=null)</p></td>
<td valign="top" ><p>метод установки начальных значений свойств </p>

<p>$s - признак показа/скрытия и его начальное значение</p></td>
</tr>

<tr>
<td valign="top" ><p>saveState()</p></td>
<td valign="top" ><p>Метод сохранения состояния </p></td>
</tr>

<tr>
<td valign="top" ><p>restoreState()</p></td>
<td valign="top" ><p>Метод восстановления состояния</p></td>
</tr>

<tr>
<td valign="top" ><p>replaceConfig($sid)</p></td>
<td valign="top" ><p>Метод замены спецификации компонента на спецификацию компонента с кодом ($sid</p></td>
</tr>

<tr>
<td valign="top" ><p>row($ipk)</p></td>
<td valign="top" ><p>Метод загрузки записи с индексом $ipk</p></td>
</tr>

<tr>
<td valign="top" ><p>go($args)</p></td>
<td valign="top" ><p>Метод обработки запроса на выполнение действия над определенной записью из набора записей </p>

<p>$args – параметры обрабатываемой записи</p></td>
</tr>

<tr>
<td valign="top" ><p>processEvent($event,$args=null)</p></td>
<td valign="top" ><p>Метод обработки событий</p>

<p>$event – параметры события</p>

<p>$args – дополнительные параметры события</p></td>
</tr>

<tr>
<td valign="top" ><p>subscribe()</p></td>
<td valign="top" ><p>Метод регистрации внутренних возможных запросов и событий</p></td>
</tr>

<tr>
<td valign="top" ><p>processRequest($args)</p></td>
<td valign="top" ><p>Метод обработки запросов</p>

<p>$args –параметры запроса</p></td>
</tr>

<tr>
<td valign="top" ><p>fire($obj)</p></td>
<td valign="top" ><p>Метод генерации события при нажатии на кнопку</p>

<p>$obj- экземпляр компонента <b>InputButton</b></p></td>
</tr>

<tr>
<td valign="top" ><p>initElements()</p></td>
<td valign="top" ><p>Метод инициализации значений элементов ввода</p></td>
</tr>

<tr>
<td valign="top" ><p>validate()</p></td>
<td valign="top" ><p>Метод валидации введенных значений элементов ввода</p></td>
</tr>

<tr>
<td valign="top" ><p>ApplyRequestValues()</p></td>
<td valign="top" ><p>Присвоение введенных значений элементам ввода</p></td>
</tr>

<tr>
<td valign="top" ><p>seek($args=null)</p></td>
<td valign="top" ><p>Метод обработки запроса на поиск записи</p>

<p>$args- параметры запроса</p></td>
</tr>

<tr>
<td valign="top" ><p>insert($args=null)</p></td>
<td valign="top" ><p>Метод обработки запроса на добавление записи</p>

<p>$args- параметры запроса</p></td>
</tr>

<tr>
<td valign="top" ><p>update($args=null)</p></td>
<td valign="top" ><p>Метод обработки запроса на изменение записи</p>

<p>$args- параметры запроса</p></td>
</tr>

<tr>
<td valign="top" ><p>remove($args=null)</p></td>
<td valign="top" ><p>Метод обработки запроса на удаление записи</p>

<p>$args- параметры запроса</p></td>
</tr>

<tr>
<td valign="top" ><p>multi_remove($args=null)</p></td>
<td valign="top" ><p>Метод обработки запроса на удаление записи при удалении набора записей</p>

<p>$args- параметры запроса</p></td>
</tr>

<tr>
<td valign="top" ><p>hasReferences($i)</p></td>
<td valign="top" ><p>Метод проверки наличия записей, ссылающихся на удаляемую запись с индексом $i</p></td>
</tr>

<tr>
<td valign="top" ><p>removeDescendants($i)</p></td>
<td valign="top" ><p>Метод проверки удаления записей detail таблицы, соответствующих удаляемой записи мастер таблицы с индексом $i</p></td>
</tr>

<tr>
<td valign="top" ><p>setQuery()</p></td>
<td valign="top" ><p>Метод формирования SQL запроса на выборку записи</p></td>
</tr>

<tr>
<td valign="top" ><p>before_seek()</p></td>
<td valign="top" ><p>Метод, выполняемый до обработки запроса на поиск записи</p></td>
</tr>

<tr>
<td valign="top" ><p>before_insert()</p></td>
<td valign="top" ><p>Метод, выполняемый до обработки запроса на добавление записи</p></td>
</tr>

<tr>
<td valign="top" ><p>before_update()</p></td>
<td valign="top" ><p>Метод, выполняемый до обработки запроса на изменение записи</p></td>
</tr>

<tr>
<td valign="top" ><p>before_remove()</p></td>
<td valign="top" ><p>Метод, выполняемый до обработки запроса на удаление записи</p></td>
</tr>

<tr>
<td valign="top" ><p>after_seek()</p></td>
<td valign="top" ><p>Метод, выполняемый после обработки запроса на поиск записи</p></td>
</tr>

<tr>
<td valign="top" ><p>after_insert()</p></td>
<td valign="top" ><p>Метод, выполняемый после обработки запроса на добавление записи</p></td>
</tr>

<tr>
<td valign="top" ><p>after_update()</p></td>
<td valign="top" ><p>Метод, выполняемый после обработки запроса на изменение записи</p></td>
</tr>

<tr>
<td valign="top" ><p>after_remove()</p></td>
<td valign="top" ><p>Метод, выполняемый после обработки запроса на удаление записи</p></td>
</tr>

</tbody>
</table>
<br>
<h1>Компонент Grid</h1>

<p>Компонент <b>Grid</b> является аналогом HTML элемента «table» и предназначен, в основном, для вывода записей таблицы в табличном виде. Эта таблица называется базовой. Компонент <b>Grid</b> предоставляет пользователю возможность навигации по записям, изменять сортировку записей, а также действий над отдельными или группами выбранных записей. </p>

<p>В общем случае компонент <b>Grid</b> состоит из колонок для вывода ли редактирования полей, колонок действий над отдельными записями, колонки выбора записи с помощью checkbox и кнопок действий над отмеченными записями. Для целей навигации служит ссылки постраничной навигации, а также поля ввода номера первой выводимой записи и количества записей, выводимых на одной странице. </p>

<p>Компонент <b>Grid</b> может содержать компоненты 6 видов:</p>

<p>компоненты вывода полей (<b>Column</b>)</p>

<p>компоненты выбора действий над отдельными записями (<b>RowAction</b>)</p>

<p>компоненты выбора действий над группами (наборами) записей (<b>RowSetAction</b>)</p>

<p>компонент выбора записи (<b>RowSelector</b>)</p>

<p>компоненты ввода полей (<b>InputColumn</b>)</p>

<p>компоненты кнопок грида (<b>GridButton</b>)</p>

<p>Для упрощения конфигурирования выводимых данных, в зависимости от характера вывода, в системе предусмотрены следующие компоненты вывода:</p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>Конфигурируемый компонент</p></td>
<td valign="top" ><p>назначение</p></td>
</tr>

<tr>
<td valign="top" ><p><b>ColumnText</b></p></td>
<td valign="top" ><p>Для вывода значений поля без изменений</p></td>
</tr>

<tr>
<td valign="top" ><p><b>ColumnDate</b></p></td>
<td valign="top" ><p>Для вывода значений типа date в локальном формате</p></td>
</tr>

<tr>
<td valign="top" ><p><b>ColumnDatetime</b></p></td>
<td valign="top" ><p>Для вывода значений типа datetime в локальном формате</p></td>
</tr>

<tr>
<td valign="top" ><p><b>ColumnLink</b></p></td>
<td valign="top" ><p>Для вывода данных в виде ссылок </p></td>
</tr>

<tr>
<td valign="top" ><p><b>ColumnLookup</b></p></td>
<td valign="top" ><p>Для вывода значения полей, вводимых с помощью списков</p></td>
</tr>

</tbody>
</table>

<p>Все эти компоненты экспортируются в один и тот же компонент <b>Column</b> с нужным визуализатором (renderer).</p>

<p>Компоненты вывода или вода полей </p>

<p>Компонент <b>ColumnLink</b> всегда должен иметь атрибут «визуализатор». Этот атрибут должен быть равен названию класса со статичным методом «render», формирующим гиперссылку. </p>

<p>Компонент <b>RowSelector</b> представляет собой элемент ввода типа checkbox для выбора строк таблицы. Отметив checkbox нужных строк и кликнув мышкой на компоненте <b>RowSetAction</b>, можно организовать редактирование, удаление или просмотр выбранных записей.</p>

<p>Компоненты <b>RowAction</b> оформляются обычно как иконки - гиперссылки, содержащие обязательно первичный ключ записи (параметр key) и действие над записью, равное номеру строки. Если первичный ключ состоит из нескольких полей, то значения полей объединяются с помощью знака подчеркивания.</p>

<p>Компоненты <b>RowSetAction</b> оформляются как кнопки типа «submit» формы, включающей также checkbox-ы компонента <b>RowSelector</b>.</p>

<p>Компоненты <b>RowAction</b> и <b>RowSetAction</b> могут иметь в качестве атрибута условие на выполнение действия над записью или группой записей соответственно. Для проверки этих условий компонент <b>Grid</b> использует компонент <b>ConditionTester</b> или Valdator для нестандартных условий. В качестве параметров передается параметры условия и данные проверяемой записи.</p>

<p>Компоненты <b>RowAction</b> и <b>RowSetAction</b> обычно передают параметры выбранных записей для компонента Form. Однако можно сконфигурировать эти компоненты для выполнения действий самим компонентом <b>Grid</b>. В качестве примера можно организовать удаление записей как через компонент <b> Form </b>так самим компонентом <b>Grid</b>. В первом случае компонент <b> Form </b>выводит данные удаляемой записи, и пользователь удаляет запись, кликнув на кнопке «Удалить». Во втором случае при клике на иконке «Удалить» нужной записи удаление происходит сразу компонентом <b>Grid</b>.</p>

<p>Для установки вывода произвольного числа записей на странице, начиная с произвольной записи, служат вспомогательные формы.</p>

<p>В соответствие с принятым алгоритмом обработки запросов, все формы и гиперссылки, относящиеся к компоненту <b>Grid</b>, должны передавать в качестве параметров переменные запроса fgsc, fgsu , fgst. Также в случае необходимости можно передавать параметр fgsw. Для добавления этих переменных в форму нужно использовать метод fgsHidden компонента <b>Registry</b>, в который нужно передавать в качестве аргументов код <b>Unit</b> грида и значение «grid», а для добавления этих переменных в гиперссылки метод fgsRef компонента <b>Registry</b> с такими же аргументами.</p>

<p>Компонент <b>Grid</b> регистрирует в качестве своих запросов компоненты <b>RowAction</b>, <b>RowSetAction</b>, <b>GridButton</b> и запросы на изменение атрибутов offset, pagesize, order и direction</p>

<p>Кроме вывода данных, компонент <b>Grid</b> позволяет организовать также редактирование существующих записей таблиц двух видов. </p>

<p>В первом виде переход к редактированию может осуществляться путем двойного клика мышкой на нужном поле нужной записи (режим inline editing). В режиме inline editing сохранение измененных данных происходит при нажатии кнопки Enter в поле редактирования типа «text» или изменении опции в поля, редактируемых с помощью списков. </p>

<p>Редактирование второго вида позволяет редактировать нужные поля нужных строк без всяких дополнительных действий со стороны пользователя. Для сохранения измененных данных пользователю нужно нажать на кнопку грида (<b>GridButton</b>)</p>

<p>Компонент <b>Grid</b> входит в состав компонента <b>Unit</b>. При выборе действий над записями компонент <b>Grid</b> генерирует соответствующие события. Detail <b>Grid</b> является обработчиком события «detail», генерируемое master <b>Grid</b> Компонент <b>Grid</b> также является обработчиком события «search», генерируемого компонентом <b>Search</b> при установке нового или сбросе фильтра на записи.</p>

<p>Компонент <b>Grid</b> при выборке записей использует фильтры, устанавливаемые как компонентом <b>Dataset</b>, так и компонентом <b>Search</b>.</p>

<p>В некоторых случаях в SQL запросе на выборку записей необходимо выполнять различные объединения нескольких таблиц (table join). Для этого в спецификацию грида нужно добавлять специальный псевдо компонент <b>ColumnTableJoiner</b>. Этот псевдо компонент нужен конфигуратору только для формирования свойства «joins» грида. Компонент <b>Grid</b> использует свойство «joins» для объединения нужных таблиц для целевого SQL запроса. В отличие от компонента <b> Form </b>тип объединения нужно указывать.</p>

<p>При определенных условиях компонент <b>Grid</b> для вывода полей с компонентом <b>ColumnLookup</b>, использующим переменный список, выполняет объединение типа left join с таблицей списка.</p>

<p>Компонент <b>Grid</b> позволяет формировать многострочные заголовки. Это достигается путем конфигурирования свойства «Headerspan» самого грида и конфигурирования свойств «Заголовок» и «Span» колонок.</p>

<p>Компонент <b>Grid</b> позволяет суммировать значения колонок и выводить итоговые суммы колонок. Для этого необходимо при конфигурировании колонок установить атрибут «Суммировать?».</p>

<p>Компонент <b>Grid</b> позволяет осуществлять сортировку записей как полям базовой так и не базовой таблиц. Также можно сконфигурировать грид для сортировки с добавлением постоянной части либо в начало, либо в конец выражения «order by» SQL запроса для выборки выводимых записей. </p>

<p>Кроме свойств и методов, унаследованных от <b>Component</b>, <b>Grid</b> имеет свои свойства и методы.</p>

<p>Свойства, определяющие состояние компонента <b>Grid</b></p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>свойство</p></td>
<td valign="top" ><p>назначение</p></td>
</tr>

<tr>
<td valign="top" ><p>pagesize</p></td>
<td valign="top" ><p>Текущий размер страницы, т.е. количество записей выводимых на странице</p></td>
</tr>

<tr>
<td valign="top" ><p>direction</p></td>
<td valign="top" ><p>Текущее направление сортировки</p></td>
</tr>

<tr>
<td valign="top" ><p>order</p></td>
<td valign="top" ><p>Текущее значение сортировки</p></td>
</tr>

<tr>
<td valign="top" ><p>offset</p></td>
<td valign="top" ><p>Текущий номер записи, начиная с которой происходит вывод записей</p></td>
</tr>

<tr>
<td valign="top" ><p>hide</p></td>
<td valign="top" ><p>Признак скрытия грида после выбора операции над записью, выполняемой компонентом Form</p></td>
</tr>

<tr>
<td valign="top" ><p>multimode_hide</p></td>
<td valign="top" ><p>Признак скрытия грида после выбора операции над набором записей, выполняемой компонентом <b> Form </b></p></td>
</tr>

<tr>
<td valign="top" ><p>display</p></td>
<td valign="top" ><p>Признак показа грида</p></td>
</tr>

<tr>
<td valign="top" ><p>apk</p></td>
<td valign="top" ><p>Массив первичных ключей выводимых записей </p></td>
</tr>

<tr>
<td valign="top" ><p>adk</p></td>
<td valign="top" ><p>Массив дополнительных полей выводимых записей</p></td>
</tr>

<tr>
<td valign="top" ><p>foreign_key</p></td>
<td valign="top" ><p>Значение внешнего ключа для таблиц типа detail</p></td>
</tr>

</tbody>
</table>

<p>Массив первичных ключей выводимых записей позволяет выполнять действия только над выводимыми записями.</p>

<p>Массив дополнительных полей выводимых записей формируется только при конфигурировании свойства «Сохранить» колонок. Он необходим для передачи дополнительных параметров в событиях, генерируемых компонентом <b>Grid</b> при обработке запросов, формируемых при нажатии пользователя на компонентах <b>RowAction</b> или <b>RowSetAction</b>. </p>

<p>Значение внешнего ключа для таблиц типа detail необходимо для добавления условия равенства внешнего ключа таблицы detail первичному ключу таблицы master в SQL запросе для выборки выводимых записей</p>

<p>Свойства, не определяющие состояние компонента <b>Grid</b></p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>свойство</p></td>
<td valign="top" ><p>назначение</p></td>
</tr>

<tr>
<td valign="top" ><p>c</p></td>
<td valign="top" ><p>Массив выводимых компонент- колонок </p></td>
</tr>

<tr>
<td valign="top" ><p>ra</p></td>
<td valign="top" ><p>Массив компонент – выборов действий над отдельными записями</p></td>
</tr>

<tr>
<td valign="top" ><p>rsa</p></td>
<td valign="top" ><p>Массив компонент – выборов действий над набором выбранных записей</p></td>
</tr>

<tr>
<td valign="top" ><p>b</p></td>
<td valign="top" ><p>Массив компонент - кнопок </p></td>
</tr>

<tr>
<td valign="top" ><p>nrows</p></td>
<td valign="top" ><p>Количество выводимых записей</p></td>
</tr>

<tr>
<td valign="top" ><p>total</p></td>
<td valign="top" ><p>Общее количество записей</p></td>
</tr>

<tr>
<td valign="top" ><p>query</p></td>
<td valign="top" ><p>Текст SQL запроса для выборки выводимых записей</p></td>
</tr>

<tr>
<td valign="top" ><p>set</p></td>
<td valign="top" ><p>Массив выводимых записей</p></td>
</tr>

<tr>
<td valign="top" ><p>err</p></td>
<td valign="top" ><p>Массив ошибок при редактировании записей</p></td>
</tr>

<tr>
<td valign="top" ><p>editable</p></td>
<td valign="top" ><p>Признак редактируемости записей</p></td>
</tr>

<tr>
<td valign="top" ><p>type</p></td>
<td valign="top" ><p>Тип компонента. Всегда равен 'grid'</p></td>
</tr>

</tbody>
</table>

<p>Методы <b>Grid</b></p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>метод</p></td>
<td valign="top" ><p>назначение</p></td>
</tr>

<tr>
<td valign="top" ><p>__construct($unit,$sid,$hide)</p></td>
<td valign="top" ><p>Конструктор класса</p>

<p>$unit –код <b>Unit</b></p>

<p>$sid-код грида</p>

<p>$hide – признак показа/скрытия</p></td>
</tr>

<tr>
<td valign="top" ><p>initState($s=null)</p></td>
<td valign="top" ><p>метод установки начальных значений свойств </p>

<p>$s - признак показа/скрытия и его начальное значение</p></td>
</tr>

<tr>
<td valign="top" ><p>saveState()</p></td>
<td valign="top" ><p>Метод сохранения состояния </p></td>
</tr>

<tr>
<td valign="top" ><p>restoreState()</p></td>
<td valign="top" ><p>Метод восстановления состояния</p></td>
</tr>

<tr>
<td valign="top" ><p>replaceConfig($sid)</p></td>
<td valign="top" ><p>Метод замены спецификации компонента на спецификацию компонента с кодом ($sid</p></td>
</tr>

<tr>
<td valign="top" ><p>row($irow=0)</p></td>
<td valign="top" ><p>Метод загрузки записи с индексом $ipk</p></td>
</tr>

<tr>
<td valign="top" ><p>page($saveKeyes=false,$rowPK=null)</p></td>
<td valign="top" ><p>Метод загрузки набора выводимых записей </p>

<p>$saveKeyes – признак формирования массивов первичных ключей и дополнительных полей выводимых записей </p></td>
</tr>

<tr>
<td valign="top" ><p>saveKeyes($setGlobal=false)</p></td>
<td valign="top" ><p>Метод формирования массивов первичных ключей и дополнительных полей выводимых записей</p>

<p>$setGlobal- признак записи значений отдельных полей в массив globals компонента <b>Registry</b></p></td>
</tr>

<tr>
<td valign="top" ><p>processEvent($event,$args=null)</p></td>
<td valign="top" ><p>Метод обработки событий</p>

<p>$event – параметры события</p>

<p>$args – дополнительные параметры события</p></td>
</tr>

<tr>
<td valign="top" ><p>subscribe()</p></td>
<td valign="top" ><p>Метод регистрации внутренних возможных запросов и событий</p></td>
</tr>

<tr>
<td valign="top" ><p>processRequest($args)</p></td>
<td valign="top" ><p>Метод обработки запросов</p>

<p>$args –параметры запроса</p></td>
</tr>

<tr>
<td valign="top" ><p>RowAction($args)</p></td>
<td valign="top" ><p>Метод обработки запроса на выполнение действия над отдельной записью</p>

<p>$args –параметры запроса</p></td>
</tr>

<tr>
<td valign="top" ><p>isValidAction($args)</p></td>
<td valign="top" ><p>Метод валидации действия над отдельной записью</p>

<p>$args –параметры действия</p></td>
</tr>

<tr>
<td valign="top" ><p>RowSetAction($args)</p></td>
<td valign="top" ><p>Метод обработки запроса на выполнение действия над набором выбранных записей</p>

<p>$args –параметры запроса</p>

<p>$loadRow - признак загрузки </p></td>
</tr>

<tr>
<td valign="top" ><p>isValidRowSetAction($args)</p></td>
<td valign="top" ><p>Метод валидации действия над набором выбранных записей</p>

<p>$args –параметры действия</p></td>
</tr>

<tr>
<td valign="top" ><p>setQuery($search_filter)</p></td>
<td valign="top" ><p>Метод формирования SQL запроса для выборки выводимых записей</p>

<p>$search_filter- признак наличия условия поиска</p></td>
</tr>

<tr>
<td valign="top" ><p>setOffset($args)</p></td>
<td valign="top" ><p>Метод обработки запроса на изменение свойства offset</p>

<p>$args –параметры запроса</p></td>
</tr>

<tr>
<td valign="top" ><p>setPagesize($args)</p></td>
<td valign="top" ><p>Метод обработки запроса на изменение свойства pagesize</p>

<p>$args –параметры запроса</p></td>
</tr>

<tr>
<td valign="top" ><p>setOrder($args)</p></td>
<td valign="top" ><p>Метод обработки запроса на изменение свойства order</p>

<p>$args –параметры запроса</p></td>
</tr>

<tr>
<td valign="top" ><p>getOrder()</p></td>
<td valign="top" ><p>Метод формирования предложения order by SQL запроса для выборки выводимых записей</p></td>
</tr>

<tr>
<td valign="top" ><p>save()</p></td>
<td valign="top" ><p>Метод обработки запроса на сохранение измененных записей при редактировании</p></td>
</tr>

</tbody>
</table>
<br>
<h1>Компонент Search</h1>

<p>Компонент <b>Search</b> является аналогом HTML элемента «form» и предназначен для ввода фильтров на записи, выводимые в компоненте <b>Grid</b> (форма поиска). Сами фильтры могут состоять из нескольких условий поиска (предикатов) для полей разных таблиц, одна из которых является базовой.</p>

<p>Обычно предикат состоит из коннектора, оператора сравнения и аргумента. Структура предиката обычно следующая:</p>

<p>&lt;поле таблицы&gt; &lt; оператор сравнения &gt; &lt; аргумент&gt;</p>

<p>Однако можно создать и предикат вида:</p>

<p>&lt;SQL функция (поле 1 + поле 2)&gt; &lt; оператор сравнения &gt; &lt; аргумент&gt;</p>

<p>Коннектор служит для соединения предиката с предыдущим предикатом:</p>

<p>&lt; предикат &gt; &lt; коннектор &gt; &lt; предикат &gt;</p>

<p>Все операторы сравнения можно разделить на 5 групп:</p>

<ul>
<li>Тест сравнения (Comparison test)</li>
<li>Тест на соответствие шаблону (Pattern matching test)</li>
<li>Тест на принадлежность диапазону (Range test)</li>
<li>Тест на членство во множестве (Set inclusion test)</li>
<li>Тест на NULL (NULL TEST)</li>
</ul>

<p>Форма поиска является контейнером для компонент 2 видов:</p>

<p>Кнопки формы поиска</p>

<p>Компоненты ввода предикатов</p>

<p>Кнопки формы поиска</p>

<p>Кнопкам формы поиска соответствует компонент <b>InputButton</b>. </p>

<p>Компонент <b>Search</b> регистрирует компоненты <b>InputButton</b> в качестве возможных запросов.</p>

<p>Компоненты ввода предикатов могут быть 2 типов <b>Predicate</b> и <b>PredicateRange</b>.</p>

<p>Компоненты <b>Predicate</b> служит для ввода предикатов со всеми условиями сравнения, кроме входящих в группу «Тест на принадлежность диапазону» и является контейнером для трех элементов ввода:</p>

<p>Элемент ввода коннектора условия</p>

<p>Элемент ввода оператора сравнения условия</p>

<p>Элемент ввода значения аргумента условия</p>

<p>Компонент <b>PredicateRange</b> служит для ввода предикатов с условиями сравнения, входящих в группу «Тест на принадлежность диапазону» и является контейнером для 4 элементов ввода:</p>

<p>Элемент ввода коннектора условия</p>

<p>Элемент ввода оператора сравнения условия</p>

<p>Элемент ввода нижней границы диапазона условия</p>

<p>Элемент ввода верхней границы диапазона условия</p>

<p>Элемент ввода коннектора является компонентом типа <b>SelectOneRadio</b> и может принимать только два значения «AND» или «OR»</p>

<p>Элемент ввода оператора сравнения является компонентом типа <b>SelectOneMenu</b>. </p>

<p>При использовании условий сравнения из группы Тест на NULL компонент ввода аргумента не используется. </p>

<p>Значения элементов ввода коннектора, оператора и аргумента сохраняются в сессионных переменных.</p>

<p>Компоненты ввода предикатов можно объединять в группы с помощью установки свойства «fieldset». В этом случае введенный коннектор первого предиката будет служить коннектором группы с предыдущим предикатом или предыдущей группой предикатов.</p>

<p>Компонент <b>Search</b> позволяет создавать условия поиска с SQL функциями. </p>

<p>Компонент <b>Search</b> использует вспомогательный компонент <b>PredicateBuilder</b> для формирования SQL кода фильтра на записи на основе введенных пользователем данных.</p>

<p>При необходимости формирования предикатов нестандартным способом, нужно указывать свой компонент в спецификации компонента ввода предиката – атрибут «Специальный предикат». Этот компонент должен иметь статический метод getPredicate, формирующий SQL кода предиката.</p>

<p>Компонент <b>Search</b> входит в состав компонента <b>Unit</b>. При установке нового фильтра на записи или отмене фильтра компонент <b>Search</b> генерирует событие «search». Компонент <b>Search</b> записывает фильтр на записи в компоненте <b>Registry</b> либо при установке нового фильтра либо при восстановлении своего состояния.</p>

<p>В связи с принятым алгоритмом обработки запросов, при рендеринге формы поиска нужно добавлять скрытые поля ввода fgsw, fgsc, fgsu и fgst. Для получения HTML кода этих переменных нужно вызвать метод fgsHidden компонента <b>Registry</b> с аргументами:</p>

<ul>
<li>код <b>Unit</b> формы поиска</li>
<li>значение «search». </li>
</ul>

<p>Кроме свойств и методов, унаследованных от <b>Component</b>, <b>Search</b> имеет свои свойства и методы.</p>

<p>Свойства <b>Search</b></p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>свойство</p></td>
<td valign="top" ><p>назначение</p></td>
</tr>

<tr>
<td valign="top" ><p>p</p></td>
<td valign="top" ><p>Массив компонент для ввода предикатов</p></td>
</tr>

<tr>
<td valign="top" ><p>b</p></td>
<td valign="top" ><p>Массив кнопок </p></td>
</tr>

<tr>
<td valign="top" ><p>formValue</p></td>
<td valign="top" ><p>Массив введенных значений аргументов предикатов</p></td>
</tr>

<tr>
<td valign="top" ><p>aliases</p></td>
<td valign="top" ><p>Массив алиасов полей</p></td>
</tr>

<tr>
<td valign="top" ><p>type</p></td>
<td valign="top" ><p>Тип компонента. Всегда равен «search»</p></td>
</tr>

</tbody>
</table>

<p>Методы <b>Search</b></p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>метод</p></td>
<td valign="top" ><p>назначение</p></td>
</tr>

<tr>
<td valign="top" ><p>__construct($unit,$sid,$hide)</p></td>
<td valign="top" ><p>Конструктор класса</p>

<p>$unit –код <b>Unit</b></p>

<p>$sid-код формы поиска</p>

<p>$hide – признак показа/скрытия</p></td>
</tr>

<tr>
<td valign="top" ><p>initState($s=null)</p></td>
<td valign="top" ><p>метод установки начальных значений свойств </p>

<p>$s - признак показа/скрытия и его начальное значение</p></td>
</tr>

<tr>
<td valign="top" ><p>saveState()</p></td>
<td valign="top" ><p>Метод сохранения состояния </p></td>
</tr>

<tr>
<td valign="top" ><p>restoreState()</p></td>
<td valign="top" ><p>Метод восстановления состояния</p></td>
</tr>

<tr>
<td valign="top" ><p>processEvent($event,$args=null)</p></td>
<td valign="top" ><p>Метод обработки событий</p>

<p>$event – параметры события</p>

<p>$args – дополнительные параметры события</p></td>
</tr>

<tr>
<td valign="top" ><p>subscribe()</p></td>
<td valign="top" ><p>Метод регистрации внутренних возможных запросов и событий</p></td>
</tr>

<tr>
<td valign="top" ><p>processRequest($args)</p></td>
<td valign="top" ><p>Метод обработки запросов</p>

<p>$args –параметры запроса</p></td>
</tr>

<tr>
<td valign="top" ><p>set<b>Registry</b>()</p></td>
<td valign="top" ><p>Метод передачи фильтра на записи в компонент <b>Registry</b></p></td>
</tr>

<tr>
<td valign="top" ><p>formFilter($having)</p></td>
<td valign="top" ><p>Получение SQL кода из массива введенных предикатов для предложения where или having в зависисимости от признака $having</p></td>
</tr>

<tr>
<td valign="top" ><p>getFieldsetPredicate($aSet)</p></td>
<td valign="top" ><p>Получение SQL кода для группы предикатов</p></td>
</tr>

<tr>
<td valign="top" ><p>validate()</p></td>
<td valign="top" ><p>Метод валидации введенных значений элементов ввода</p></td>
</tr>

<tr>
<td valign="top" ><p>ApplyRequestValues()</p></td>
<td valign="top" ><p>Присвоение введенных значений элементам ввода</p></td>
</tr>

<tr>
<td valign="top" ><p>validInput()</p></td>
<td valign="top" ><p>Метод проверки введенных данных поиска</p></td>
</tr>

<tr>
<td valign="top" ><p>setFilter()</p></td>
<td valign="top" ><p>Метод обработки запроса на ввод фильтра на записи</p></td>
</tr>

<tr>
<td valign="top" ><p>dropFilter()</p></td>
<td valign="top" ><p>Метод обработки запроса на удаление фильтра на записи</p></td>
</tr>

</tbody>
</table>

<p>Компонент <b>Search</b> позволяет пользователю формировать самые сложные фильтры для компонента <b>Grid</b>. </p>

<h1>Компонент Dataset</h1>

<p>Компонент <b>Dataset</b> является невизуальным компонентом и необходим для установки скрытых фильтров на записи, выводимые в компоненте <b>Grid</b> или при формировании списков. </p>

<p>В отличие от компонент <b>Form</b>, <b>Grid</b> и <b>Search</b>, у <b>Dataset</b> нет свойств, требующих сохранения в сессионных переменных.</p>

<p>Компонент <b>Dataset</b> состоит из либо известных предикатов, либо определяемых во время исполнения скрипта. </p>

<p>Компонент <b>Dataset</b> как и компонент <b>Search</b> использует вспомогательный компонент <b>PredicateBuilder</b> для формирования SQL кода фильтра на записи на основе своих предикатов.</p>

<p>При необходимости формирования условий нестандартным способом, нужно указывать свой компонент в спецификации предиката – атрибут «Custom». Этот компонент должен иметь статический метод getPredicate, формирующий SQL код предиката.</p>

<p>Компонент <b>Dataset</b> записывает фильтр на записи в компоненте <b>Registry</b> сразу после своего создания.</p>

<p>Для использования своего класса компонента <b>Dataset</b> нужно указать в спецификации соответствующего <b>Unit</b> название своего класса.</p>

<p>Кроме свойств, унаследованных от <b>Component</b>, <b>Dataset</b> имеет свойство $predicates, являющимся массивом предикатов, и единственный метод setRegistry() для передачи компоненту <b>Grid</b> фильтра, сформированного из предикатов</p>

<h1>Контроллеры Crud, MasterDetail, UnitSet</h1>

<p>Контроллеры <b>Crud</b>, <b>MasterDetail</b>, <b>UnitSet</b> наследуются от абстрактного класса Controller.</p>

<p>Общие свойства контроллеров</p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>свойство</p></td>
<td valign="top" ><p>назначение</p></td>
</tr>

<tr>
<td valign="top" ><p>sid</p></td>
<td valign="top" ><p>Системный код контроллера</p></td>
</tr>

<tr>
<td valign="top" ><p>title</p></td>
<td valign="top" ><p>Название контроллера</p></td>
</tr>

<tr>
<td valign="top" ><p>initial</p></td>
<td valign="top" ><p>Массив начальных значений свойств контроллера</p></td>
</tr>

<tr>
<td valign="top" ><p>session</p></td>
<td valign="top" ><p>Массив названий свойств, определяющих состояние контроллера</p></td>
</tr>

<tr>
<td valign="top" ><p>acl</p></td>
<td valign="top" ><p>Массив ролей пользователей, которым разрешен доступ к контроллеру </p></td>
</tr>

<tr>
<td valign="top" ><p>template</p></td>
<td valign="top" ><p>Название файла шаблона для рендеринга страницы контроллера</p></td>
</tr>

<tr>
<td valign="top" ><p>type</p></td>
<td valign="top" ><p>Тип компонента. Всегда равен 'controller'</p></td>
</tr>

</tbody>
</table>

<p>Контроллер <b>Crud</b> имеет один компонент <b>Unit</b> (свойство unit).</p>

<p>Контроллер <b>MasterDetail</b> имеет мастер <b>Unit</b> (свойство master) и <b>Unit</b> типа detail (свойство detail). Контроллер <b>MasterDetail</b> может быть в 2 режимах (свойство mode): master или detail</p>

<p>Контроллер <b>UnitSet</b> имеет мастер <b>Unit</b> (свойство master) и массив остальных <b>Unit</b> типа detail (свойство units). Контроллер <b>UnitSet</b> может быть в режимах (свойство mode): master или режиме, равным коду соответствующего <b>Unit</b>.</p>

<p>Методы контроллеров</p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>Метод</p></td>
<td valign="top" ><p>назначение</p></td>
</tr>

<tr>
<td valign="top" ><p>__construct($sid,$config,$template)</p></td>
<td valign="top" ><p>Конструктор класса</p>

<p>$sid- Системный код контроллера</p>

<p>$config-спецификация контроллера</p>

<p>$template- Название файла шаблона</p></td>
</tr>

<tr>
<td valign="top" ><p>initState()</p></td>
<td valign="top" ><p>метод установки начальных значений свойств</p></td>
</tr>

<tr>
<td valign="top" ><p>saveState()</p></td>
<td valign="top" ><p>Метод сохранения состояния </p></td>
</tr>

<tr>
<td valign="top" ><p>restoreState()</p></td>
<td valign="top" ><p>Метод восстановления состояния</p></td>
</tr>

<tr>
<td valign="top" ><p>subscribe()</p></td>
<td valign="top" ><p>Метод регистрации возможных запросов и событий</p></td>
</tr>

<tr>
<td valign="top" ><p>processRequest($args)</p></td>
<td valign="top" ><p>Метод обработки запросов</p>

<p>$args –параметры запроса</p></td>
</tr>

<tr>
<td valign="top" ><p>processEvent($event,$args)</p></td>
<td valign="top" ><p>Метод обработки событий</p>

<p>$event – параметры события</p>

<p>$args – дополнительные параметры события</p></td>
</tr>

<tr>
<td valign="top" ><p>loadData()</p></td>
<td valign="top" ><p>Метод загрузки данных для визуализации</p></td>
</tr>

<tr>
<td valign="top" ><p>renderJavaScript()</p></td>
<td valign="top" ><p>Метод формирования данных для JavaScript</p></td>
</tr>

</tbody>
</table>
<br>
<h1>Компонент PredicateBuilder</h1>

<p>Компонент <b>PredicateBuilder</b> предназначен для формирования SQL код фильтра на записи из переданного ему массива предикатов.</p>

<p>Компоненты <b>Search</b>, <b>Dataset</b> и <b>ListLoader</b> используют <b>PredicateBuilder</b> для фильтра на записи. </p>

<p><b>PredicateBuilder</b> может возвратить:</p>

<p>-пустую строку, означающую, что фильтра нет </p>

<p>-SQL код фильтра</p>

<p>- строку «empty», означающую фильтр не может быть выполнен и не может быть записей, которые ему могут удовлетворить</p>

<p>В условии поиска может использоваться SQL функции. Если SQL функция является агрегатной, то условие поиска является частью предложения having SQL запроса. Если же SQL функция не является агрегатной, то условие поиска является частью предложения where.</p>

<p>Поэтому <b>PredicateBuilder</b> возвращает фильтр на записи в виде ассоциативного массива, содержащего SQL код для предложений where и having SQL запроса.</p>

<p><b>PredicateBuilder</b> формирует SQL код для предложений where и having SQL запроса путем последовательного вызова метода getFilter.</p>

<p><b>PredicateBuilder</b> имеет только статичные методы и не имеет свойств</p>

<p>Методы <b>PredicateBuilder</b></p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>метод</p></td>
<td valign="top" ><p>назначение</p></td>
</tr>

<tr>
<td valign="top" ><p>getFilter($predicates)</p></td>
<td valign="top" ><p>Получение SQL кода фильтра на записи из массива предикатов $predicates</p></td>
</tr>

<tr>
<td valign="top" ><p>formFilter($predicates,$having)</p></td>
<td valign="top" ><p>Получение SQL кода из массива предикатов $predicates для предложения where или having в зависисимости от признака $having</p></td>
</tr>

<tr>
<td valign="top" ><p>getFieldsetPredicate($aSet)</p></td>
<td valign="top" ><p>Получение общего SQL кода для группы предикатов</p></td>
</tr>

<tr>
<td valign="top" ><p>getPredicate($a)</p></td>
<td valign="top" ><p>Формирование SQL кода условия для предиката $a</p></td>
</tr>

</tbody>
</table>
<br>
<h1>Вспомогательные компоненты</h1>

<p>К вспомогательным компонентам относятся компоненты <b>debug</b> и <b>Timer</b>.</p>

<p>Компонент <b>debug</b> предназначен для сбора и вывода следующих видов отладочной информации:</p>

<ul>
<li>Значения отслеживаемых переменных</li>
<li>Результаты выполнения SQL запросов</li>
<li>Вызовы методов <b>RequestHandler</b> и <b>EventHandler</b>.</li>
<li>Инициализируемые классы</li>
<li>Журнал экспорта спецификаций</li>
</ul>

<p>Компонент <b>debug</b>, в зависимости от настройки, хранит отладочную информацию либо в специальной системной таблице (fgs_debug), либо в специальных массивах компонента <b>Registry</b>. </p>

<p>Компонент <b>debug</b> имеет только статичные методы. Для каждого вида отладочной информации предназначен отдельный метод.</p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>метод</p></td>
<td valign="top" ><p>назначение</p></td>
</tr>

<tr>
<td valign="top" ><p>Write</p>

</td>
<td valign="top" ><p>Значение переменной</p>

<p>Параметры</p>

<p>$value –значение переменоой</p>

<p>$var –название переменной</p>

<p>$point – необязательная точка отладки</p>

<p>$error – необязательный признак отладки</p></td>
</tr>

<tr>
<td valign="top" ><p>writeSql</p></td>
<td valign="top" ><p>Результат выполнения SQL запроса</p>

<p>Параметры </p>

<p>$q – текст SQL запроса</p>

<p>$result – результат SQL запроса</p>

<p>$type – тип SQL запроса</p></td>
</tr>

<tr>
<td valign="top" ><p>writeListeners</p></td>
<td valign="top" ><p>Вызовы методов обработчиков <b>RequestHandler</b> и <b>EventHandler</b>.</p>

<p>Параметры</p>

<p>$args –массив аргументов, переданных в метод</p>

<p>$type – тип операции над запросом или событием</p></td>
</tr>

<tr>
<td valign="top" ><p>writeClass</p></td>
<td valign="top" ><p>Инициализация класса</p>

<p>Параметры</p>

<p>$class –имя класса</p>

<p>$path – путь к файлу класса</p></td>
</tr>

<tr>
<td valign="top" ><p>writeExport</p></td>
<td valign="top" ><p>Сообщение об ошибке при экспорте спецификации</p>

<p>$component – тип экспортируемого компонента</p>

<p>$sid – код экспортируемого компонента</p>

<p>$error – код ошибки экспорта</p>

<p>$detail – необязательный тип child элемента</p>

<p>$detail_sid необязательный код child элемента</p></td>
</tr>

<tr>
<td valign="top" ><p>render</p></td>
<td valign="top" ><p>Метод вывода отладочной информации</p></td>
</tr>

</tbody>
</table>

<p>Для использования компонента <b>debug</b> режим отладки должен быть включен. </p>

<p>Компонент <b>Timer</b> реализован с использованием шаблона проектирования <b>Singleton</b>. и служит для профилирования времени исполнения скриптов. Для получения статистики выполнения SQL запросов все методы драйвера базы данных для манипулирования данными должны включать код учета времени выполнения метода.</p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>метод</p></td>
<td valign="top" ><p>назначение</p></td>
</tr>

<tr>
<td valign="top" ><p>start</p></td>
<td valign="top" ><p>Запуск таймера</p>

<p>Параметр</p>

<p>$point–аббревиатура точки старта</p></td>
</tr>

<tr>
<td valign="top" ><p>mark</p></td>
<td valign="top" ><p>Добавление промежуточной точки профилирования</p>

<p>$point– точки профилирования</p></td>
</tr>

<tr>
<td valign="top" ><p>addSql</p></td>
<td valign="top" ><p>Добавление времени исполнения SQL запроса</p>

<p>Параметр</p>

<p>$time –время исполнения в микросекундах</p></td>
</tr>

<tr>
<td valign="top" ><p>render</p></td>
<td valign="top" ><p>Метод вывода времени профилирования</p></td>
</tr>

</tbody>
</table>
<br>
<h1>Шаблоны фреймворка</h1>

<p>В состав фреймворка входит три файла шаблона:</p>

<p>admin_crud.php- шаблон для контроллеров типа <b>Crud</b> </p>

<p>admin_md.php- шаблон для контроллеров типа <b>MasterDetail</b></p>

<p>admin_universal.php- шаблон для контроллеров типа <b>UnitSet</b></p>

<p>Эти шаблоны используются совместно с управляющим скриптом application.php. Данные шаблоны используют класс <b>svm</b> для создания двух- уровнего вертикального меню.</p>

