<h1 align="center">FGS Factory Framework Guide</h1>

<p>FGS Factory Framework (the Framework) is a part of FGS Tools software package. This document presents main features, architecture and interaction between different parts of FGS Factory Framework.</p>

<h2>Component architecture of the Framework</h2>

<p>The Framework is based on three visual components <b>Form</b>, <b>Grid</b>, <b>Search</b> and one non-visual component <b>Dataset</b>. The <b>Form</b> enables a user to add, edit, delete and view table rows. The <b>Grid</b> enables the user to view, navigate, and edit individual table rows in a tabular manner or in a</p>

<p>spreadsheet-like format. The <b>Search</b> enables the user to enter row filters which are used by the <b>Grid</b>. The <b>Dataset</b> creates hidden filters for table rows. </p>

<p>Components <b>Form</b>, <b>Grid</b>, <b>Search</b> and <b>Dataset</b> which create user interface to one common database table are united in a component <b>Unit</b>. The <b>Unit</b> component serves to make interaction among its components and, therefore, serves as a controller. </p>

<p>Components interact among themselves in the following ways:</p>

<ul>
<li><b>Dataset</b> sets hidden row filters for <b>Grid</b></li>
<li><b>Search</b> sets explicit (entered by the user) row filters for <b>Grid</b></li>
<li><b>Grid</b> transfers necessary data to <b>Form</b> for editing, deleting or viewing table rows</li>
</ul>

<p>Such interaction of components imposes the following constraints on composition of one <b>Unit</b>:</p>

<ul>
<li>There maybe be only one component of each type</li>
<li>There must be at least one component <b>Form</b> or <b>Grid</b></li>
<li>If there is no a <b>Grid </b>in a<b> Unit</b>, then components <b>Search</b> and <b>Dataset</b> are useless</li>
<li>Components <b>Search</b> and <b>Dataset</b> are optional components</li>
</ul>

<p>Components have a set of attributes, defining its state. These attributes are stored / restored in/from session variables.</p>

<p>The Framework presents three types of user interface to database tables:</p>

<ul>
<li>interface to one database table (controller <b>Crud</b>)</li>
<li>interface to two database tables associated by «master-detail» relationship (controller <b>MasterDetail</b>)</li>
<li>Interface to a number of database tables associated or not by «master-detail» relationship. One of these tables must be master table and the rest must have or have not relationship master- detail with the master table (controller <b>UnitSet</b>)</li>
</ul>

<p>Each interface has got its own controller. A name of a controller is used as a name of the corresponding interface. So interface to one database table is named as <b>Crud</b> interface and interfaces presented by the <b>MasterDetail</b> and <b>UnitSet</b> controllers are called <b>MasterDetail</b> and <b>UnitSet</b> interfaces accordingly. </p>

<p><b>The Crud</b> controller consists only of one <b>Unit</b>. </p>

<p><b>The MasterDetail</b> controller consists of two Units (the master <b>Unit</b> and the detail <b>Unit)</b> and performs interaction between components of different Units. </p>

<p><b>The UnitSet</b> controller consists of two or more Units (one master Unit and the rest are detail or auxiliary Unit) and performs interaction among components of different Units.</p>

<p>Interactions among components are performed by requests and events. A request arises when the user clicks on a hyperlink (GET request) or presses on a HTML form button (GET or POST request). Events are generated by components in response to requests but this is not mandatory. </p>

<p>Registration of possible requests and dispatching of incoming requests are handled by a request handler (<b>RequestHandler</b> component). Registration of possible events and dispatching of generated events are handled by an event handler (<b>EventHandler</b>  component). </p>

<p>Each type of controllers is a descendent of an abstract class <b>Controller</b>.</p>

<p>Data exchange among components, saving and restoring of components state are handled by the <b>Registry</b> component.</p>

<p>Accesses to data are handled by t<b>he</b> <b>AccessHandler</b>  component.</p>

<p>Connecting to a database, querying and data manipulation are performed by a special database driver.</p>

<p>The <b>Timer</b>  component is used for profiling execution time of scripts.</p>

<p><b>The Form</b> component is called also as input form and consists of input elements and buttons.</p>

<p><b>The Grid</b> component consists of output or input elements of <b>the</b> <b>Column</b> type and elements to choose action on an individual row or a rows’ set. <b>The Grid</b> component may also be used for editing rows.</p>

<p><b>The Search</b> component is called also as search form and consists of components for entering search conditions or predicates by the user.</p>

<p><b>The Dataset</b> component consists of predicates, which are not entered by the user but are known earlier or can be known only at run time. </p>

<p>Input and output elements can use dynamic lists having database table’s rows as options. Loading such lists is handled by a list loader (<b>the</b> <b>ListLoader</b> component). Using of <b>ListLoader</b> makes it possible to load a list only once and use it by different components.</p>

<p>Components files have extension<b> inc</b>. Paths to components files are defined in the “classes.php” file in the $cp array of elements. This array of elements uses Function __autoload.</p>

<p>Some helper components realize <b>Singleton</b> design pattern. These components are created at the very start of operation of a control script by including a bootstrap script. Access to instances of these components is performed through global variables:</p>

<p>$timer is the only instance of <b>the</b> <b>Timer</b> component</p>

<p>$db is the only instance of the current database driver</p>

<p>$registry is the only instance of <b>the</b> <b>Registry</b> component</p>

<p>$requestHandler is the only instance of <b>the</b> <b>RequestHandler</b> component</p>

<p>$eventHandler is the only instance of <b>the</b> <b>EventHandler</b>  component </p>

<p>$<b>ListLoader</b> is the only instance of <b>the</b> <b>ListLoader</b> component</p>

<p>$accessHandler is the only instance of <b>the</b> <b>AccessHandler</b>  component</p>

<h2>Concept of specifications</h2>

<p>The Framework uses concept of specification: appearance and behavior of a component are ruled by its specification. The Framework creates instances of components from its specifications. To change a component’s appearance or behavior, we have to change its specification. </p>

<p>Component’s specification is understood as a set of attributes, defining appearance and behavior. These attributes can be conventionally divided into three groups:</p>

<ul>
<li>HTML attributes </li>
<li>HTML events</li>
<li>System attributes</li>
</ul>

<p>HTML attributes and HTML events are defined by HTML standard for the corresponding HTML element if such exists. System attributes are the attributes, which determine the behavior of the components operation. </p>

<p>For example, a specification for <b>the</b> <b>Form</b> component consists of the attributes:</p>

<ul>
<li>HTML attributes: method, enctype, action, name and others related to HTML element «form»</li>
<li>HTML events: onreset, onsubmit related to HTML element «form»</li>
<li>System attributes: system ID, array of input elements, buttons, name of database table etc </li>
</ul>

<p>Specifications are stored in special database tables. These tables are used only by the Configurator and called as “system tables”. A “system” means using a database table only by the Configurator. A Developer uses <b>the</b> <b>Configurator</b> to create and to change specifications. To speed up operation, the data from these tables is exported to specification’s files. The Framework uses these files to create instances of components. Each interface language (English, Russian etc) has its own set of specifications, which are stored in a separate directory. Besides, the specifications of different types of components are stored in separate directories. </p>

<p>To define the path to components specifications, the Framework uses the following constants:</p>

<table border="1" cellpadding="2" cellspacing="0" >
<tbody>
<tr>
<td valign="top" ><p>component</p></td>
<td valign="top" ><p>Contant of a path</p></td>
</tr>

<tr>
<td valign="top" ><p>controller</p></td>
<td valign="top" ><p>CONTROLLER_PATH</p></td>
</tr>

<tr>
<td valign="top" ><p>Input form</p></td>
<td valign="top" ><p>FORM_PATH</p></td>
</tr>

<tr>
<td valign="top" ><p>Grid</p></td>
<td valign="top" ><p>GRID_PATH</p></td>
</tr>

<tr>
<td valign="top" ><p>Search form</p></td>
<td valign="top" ><p>SEARCH_PATH</p></td>
</tr>

<tr>
<td valign="top" ><p>Dataset </p></td>
<td valign="top" ><p>DATASET_PATH</p></td>
</tr>

<tr>
<td valign="top" ><p>List</p></td>
<td valign="top" ><p>LIST_PATH</p></td>
</tr>

<tr>
<td valign="top" ><p>database table</p></td>
<td valign="top" ><p>TABLE_PATH</p></td>
</tr>

<tr>
<td valign="top" ><p>menu</p></td>
<td valign="top" ><p>MENU_PATH</p></td>
</tr>

<tr>
<td valign="top" ><p>Input element</p></td>
<td valign="top" ><p>ELEMENT_PATH</p></td>
</tr>

<tr>
<td valign="top" ><p>Output column</p></td>
<td valign="top" ><p>COLUMN_PATH</p></td>
</tr>

</tbody>
</table>

<p>A path to a component’s specification file is defined as follows:</p>

<p>Path constant of a component/ Interface language</p>

<p>Structures of specifications are developed to minimize coding. Creation of components’ specifications is described in the «The Confgurator Manager guide» document.</p>

<p>Every component has a set of properties stipulating its state. These state properties and its initial values properties are defined by its specification. A specification and state of a component determine a set of requests and events that it can process. For example if an input form (<b>Form)</b> is in mode «insert» of a new row, then it cannot update or remove a row. In addition, if an input form’s specification has only «update» mode, then all requests to insert or to delete a row are ignored.</p>

<p>As every controller provides an interface to a database access, so therefore there should be some access control mechanizm. For this purpose, a controller’s specification has so called Access Control List (the “acl” attribute) or a list to control an access. The list may include roles and users who can have database access given by this controller.</p>

<p>It’s necessary to note that some system attributes are not entered explicitly by the developer but are created only during specification’s exporting based on the data already eneterd. <b>The</b> <b>Configurator</b> makes some checks of entered data and displays warning of discovered errors but there can’t be guarantee of other errors. So the developer should follow rules of specifications’ input and update specifications according to <b>the</b> <b>Configurator’s </b>warnings. </p>

<p><b>Requests processing algorithm</b></p>

<p>To successfully use the Framework, it’s necessary to know how the Framework processes an HTTP request from a client (browser), what operations and in what sequence the Framework does. </p>

<p>The FGS Tools package includes two examples of control scripts: configurator.php and application.php. The script configurator.php is the control script for the specifications’ Configurator and the application.php script is the control script for applications developing based on the package.</p>

<p>At first we need to define concept of a request’s «window».</p>

<p>To imitate different sessions in one window of a browser and to perform concurrent running of instances of the same controller, the Framework uses concept of a request’s «window». Each instance of the controller is running in its own «window».</p>

<p>At the beginning, a control script (for example configurator.php) tries to set an incoming request’s «window» or the current request window. If the fgsw parameter is passed in the request then the window with id equal to the fgsw parameter is set as the current request window. But if there is not the fgsw parameter in the request then the window with id equal to «main» is set as the current request window. </p>

<p>On the second step, the control script tries to set the current controller, which should be run in the current request window. If there is the fgsc parameter in the request, then the controller with id equal to the fgsc parameter is set as the current controller. But if there is no the fgsc parameter in the request and if a controller was already run in the current request window, then the previous controller is set as the current controller. If there is no the fgsc parameter in the request and if there was no any running controller in the current request window then the control script just displays the menu of <b>Configurator </b>or a an application. </p>

<p>On the third step, the control script creates the current controller.</p>

<p>We need to consider the last part of controller’s constructor (<b>Crud</b>, <b>MasterDetail</b> or <b>UnitSet</b>):</p>

<pre>
if($registry->newController())
{
    $this->initState();
}
else
{
    $this->restoreState();
}
</pre>

<p>This code performs the following actions:</p>

<p>If the current controller was not run earlier in the current request window, then the constructor initiates the controller’s state. If the current controller was run earlier in the current request window then the constructor restores the controller’s state.</p>

<p>If there is the fgsinit parameter in the request, then the constructor also initiates the controller’s state.</p>

<p>Remember that a controller contains Unit components, which themselves can consist of components <b>Form</b>, <b>Grid</b>, <b>Search</b> and <b>Dataset</b>. The last listed components also are containers. Therefore, saving and restoring a controller’s state means also saving and restoring state of all its child’s components.</p>

<p>After creation of the current controller the control script invokes the method «run» of the controller. </p>

<p>Let’s consider code of the method «run» of <b>the</b> <b>Controller</b> component. </p>

<p>Checking of access control to the controller is performed on Step 4. This is performed by <b>the</b> <b>AccessHandler</b>  component using Access Control List. The Access Control List is an attribute of a controller’s specification and has roles and users that have permission to run the controller.</p>

<p>Registration of possible request and events is performed on Step 5. </p>

<p>Usually a GET request is created via clicking on a hyperlink and a POST request via pressing on a submit button. The Framework processes GET or POST requests initiated or triggered only by <b>a</b> <b>Form</b>, <b>Grid</b>, <b>Search</b> components and <b>Controllers</b>.</p>

<p><b>A Form</b>, <b>Grid or</b> <b>Search</b> component register possible requests and events taking into account only its own specification. A <b>Unit</b> component registers possible request and events triggered or processed by itself or its components. A <b>MasterDetail</b> or <b>UnitSet</b> component registers possible requests and events that triggered or processed by components of different Units. </p>

<p>Registration of possible requests and events is performed by the «subscribe» method.</p>

<p>The Framework identifies unambiguously a GET or POST request triggered by a component by four parameters:</p>

<p>Id of a request window (the fgsw parameter)</p>

<p>Id of a controller (the fgsc parameter)</p>

<p>Id of a request’s triggers (the fgst parameter)</p>

<p>Id of a Unit which contains a request initiator or trigger (the fgsu parameter)</p>

<p>All components have to add these parameters fgsc, fgst and fgsu to their requests. The fgsw parameter is optional and it has to be added if it’s necessary to run a request in a window, which is different from of the «main» window. Components make this either by adding hidden fields to HTML forms or adding these parameters to hyperlinks. </p>

<p>Dispatching of a GET or a POST request is performed on step 6. There maybe generated events during processing the request. For example, a <b>Form</b> component generates the event «done» after successfully executed inserting, updating or removing a row.</p>

<p>It’s necessary to note that there can be only one incoming/processing request and a number of generated events. </p>

<p>Dispatching of generated events is performed on step 7. During processing of events, components can also generate events.</p>

<p>Loading data for rendering is performed on step 8. Usually it’s loading rows to display in a <b>Grid</b> component and/or loading a row for a <b> Form </b>component. </p>

<p>Saving of the current controller’s state and all its components is performed on step 9</p>

<p>HTML-code generating or page rendering is performed on the last step 10. The Framework has standard classes <b>FgsFormView</b>, <b>FgsGridView</b>, <b>FgsSearchView</b> to render <b>Form</b>, <b>Grid</b> and <b>Search</b> components accordingly. To render input fields and buttons of <b> Form </b>and <b>Search</b> components, the Framework uses the <b>FormKit</b> component, while to render input/output elements of a <b>Grid</b>, it uses <b>GridKit</b> component.</p>

<p>So processing of a request includes 10 steps:</p>

<p>1. Setting the request current window</p>

<p>2. Setting the current controller</p>

<p>3. Creation of the current controller, initialization or restoring of the controller’s state </p>

<p>4. Access control checking</p>

<p>5. Registration of possible requests and events</p>

<p>6. Dispatching the request to process</p>

<p>7. Dispatching generated events to process</p>

<p>8. Data loading for page rendering</p>

<p>9. Saving the controller’s state</p>

<p>10. Page rendering</p>

<h1>Interaction among components of a Unit</h1>

<p>Let’s consider interaction among <b><b>Grid</b>, Form and Unit</b> components during a row editing.</p>

<p>A row editing is performed in two steps. Usually a component <b> Form </b>is in mode «insert». Therefore the <b> Form </b>component has to be set in mode «update»</p>

<p>At first consider transition of <b>the Form</b> component to «update» mode.</p>

<p>Each row in the <b>Grid</b> component has the icon to update this row. </p>

<p><b>The</b> <b>Grid</b> component registers as a possible request the request to update a row. This request is triggered by the <b>Grid</b> component itself. </p>
<p><b>The</b> <b>Form</b> component registers as a possible event the event to update a row. This event is generated by the <b>Grid</b> component.</p>

<p>After the user clicks on the icon to update a row <b>the</b> <b>RequestHandler </b> component discovers the request to update and sends it to process for the <b>Grid</b> component.</p>

<p>The <b>Grid</b> component validates the incoming request and if everything is OK generates the event to update the chosen row.</p>

<p>The <b>EventHandler</b> component discovers this event and sends it to process for the <b>Form</b>component (step 7).</p>

<p>Using the event’s arguments, the <b> Form </b>component changes its mode to «update», loads the chosen row and initiate values of its input elements.</p>

<p>After that the control script performs the rest steps of request processing. So the first step of a row editing is completed. </p>

<p>Let’s consider the stage of real of row editing.</p>

<p>As <b>the Form</b> is now in the «update» mode, it registers as a possible request the request to save the updated row. The request is triggered by the <b> Form </b>component itself.</p>

<p>The <b>Unit</b> component registers as a possible event the event of successful execution of the update operation that generated by the <b> Form </b>component.</p>

<p>After the user edited the chosen row and pressed on the «Save» button <b>the</b> <b>RequestHandler </b> component discovers the request to save updated row and sends it to process for the <b> Form </b>component (step 6).</p>

<p>After validation of input data<b> the Form</b> component forms data for SQL query and sends this data to the current database driver to perform row updating. If row updating is successfully executed then the <b> Form </b>component generates the event «done» about successful execution of updating. After that the <b> Form </b>component changes its mode to the «insert» mode and initiates values of its input elements.</p>

<p><b>The</b> <b>EventHandler</b> </b>component discovers this event and sends it to process for the <b>Unit</b> component (step 7).</p>

<p><b>The Unit</b> component processes the received event by setting visibility attributes of its components.</p>

<p>After that the control script performs the rest steps of request processing. </p>

<p>Let’s consider interaction between <b>Grid</b> and <b>Search</b> components during setting of a new row filter for the <b>Grid</b> component.</p>

<p>The <b>Search</b> component is always ready to input a new row filter. Therefore setting of the new row filter is performed at once.</p>

<p>The <b>Unit</b> component registers as a possible event for the <b>Grid</b> component the event of setting a new row filter which generated by the <b>Search</b> component.</p>

<p>The <b>Search</b> component registers as a possible request the request to set a new row filter. The request is triggered by the <b>Search</b> component itself.</p>

<p>After the user typed data of a new row filter and pressed on the «Set Filter» button the <b>RequestHandler </b> component discovers the request to set the new row filter and sends this request to process for the <b>Search</b> component (step 6).</p>

<p>After successful validation of entered data the <b>Search</b> component generates the event «search» about setting the new row filter. </p>

<p>The <b>Grid</b> component processes the received event by setting value 0 for its «offset» attribute.</p>

<p>Using the event’s arguments, the <b>Form</b> component changes its mode to «update», loads the chosen row and initiate values of its input elements.</p>

<p>After that the control script performs the rest steps of request processing. </p>

<h1>Interaction between components of different Units</h1>

<p>Let’s consider interaction of components of different Units for a <b>MasterDetail</b> controller which contains master Unit and detail Unit. Remember that this controller presents user interface to two database tables with master- detail relationship. These tables are called the master and detail tables.</p>

<p>At the very beginning of operation of the controller of the type <b>MasterDetail</b>, the user has access only to the master table (master mode of the controller) interface.</p>

<p>Each row in the <b>Grid</b> of the master Unit (master <b>Grid</b>) has got the icon to activate user interface to detail table (detail mode of the controller). </p>

<p>The master <b>Grid</b> component registers as a possible request the request to activate user interface to detail table. This request is triggered by the master <b>Grid</b> itself. </p>

<p>In master mode the controller registers for itself and for <b> Form </b>and <b>Grid</b> components from the detail Unit as a possible event the event «detail», which is generated by the master <b>Grid</b> component.</p>

<p>After the user clicked on the icon to activate user interface to detail table on the step 6, the <b>RequestHandler </b> component discovers the request to activate and sends it to process for the master <b>Grid</b>.</p>

<p>The master <b>Grid</b> validates the incoming request and if everything is OK it generates the event «detail» to activate interface to the detail table for the chosen row. The value of the primary key of the chosen row is sent as a parameter of the event.</p>

<p>The <b>EventHandler</b> </b>component discovers this event and sends it to process for the controller, the detail <b> Form </b>and the detail <b>Grid</b> (step 7).</p>

<p>The controller changes its mode to the «detail» mode. In this mode the controller displays only the master <b>Grid</b> with the chosen row and components of the detail Unit. </p>

<p>Using the event’s arguments, the detail <b> Form </b>component changes its mode to the «insert» mode and initiate values of its input elements. Also the detail <b> Form </b>stores the received primary key and uses it as foreign key value for the detail table. </p>

<p>The detail <b>Grid</b> also processes the received event. The detail <b>Grid</b> stores the received primary key and uses it as foreign key value for the detail table. </p>

<p>After that the control script performs the rest steps of request processing. </p>

<p>In the «detail» mode possible requests and events are registered only for components of the detail Unit and the request to return to the «master» mode for the controller. </p>

<h1>Database drivers</h1>

<p>The Framework was developed to use with different database management systems (DBMS).</p>

<p>The Framework interacts with a database through special drivers which takes into account peculiarities of the database. </p>

<p>The FGS Tools package needs two drivers to use a database:</p>

<ul>
<li>A driver for data manipulation</li>
<li>A driver for loading tables’ structure into system tables of the Configurator</li>
</ul>

<p>A driver for data manipulation has to be coded with <b>Singleton</b> design pattern and have the following methods:</p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>method</p></td>
<td valign="top" ><p>Comments</p></td>
</tr>

<tr>
<td valign="top" ><p>getInstance</p></td>
<td valign="top" ><p>To get the only instance of a driver</p></td>
</tr>

<tr>
<td valign="top" ><p>__construct</p></td>
<td valign="top" ><p>Constructor must be of private type</p></td>
</tr>

<tr>
<td valign="top" ><p>table_join</p></td>
<td valign="top" ><p>Method of making table join</p></td>
</tr>

<tr>
<td valign="top" ><p>connect</p></td>
<td valign="top" ><p>Method to create database connection</p></td>
</tr>

<tr>
<td valign="top" ><p>value</p></td>
<td valign="top" ><p>Method to select only one value from a table</p></td>
</tr>

<tr>
<td valign="top" ><p>page</p></td>
<td valign="top" ><p>Method to select rows with the limit clause</p></td>
</tr>

<tr>
<td valign="top" ><p>set</p></td>
<td valign="top" ><p>Method to select rows without the limit clause</p></td>
</tr>

<tr>
<td valign="top" ><p>row</p></td>
<td valign="top" ><p>Method to select only one row from a table by primary key</p></td>
</tr>

<tr>
<td valign="top" ><p>record</p></td>
<td valign="top" ><p>Method to select one row by a SQL query</p></td>
</tr>

<tr>
<td valign="top" ><p>execute</p></td>
<td valign="top" ><p>Method to execute a SQL query</p></td>
</tr>

<tr>
<td valign="top" ><p>insert</p></td>
<td valign="top" ><p>Method to insert a new row by a array of fields and theirs values</p></td>
</tr>

<tr>
<td valign="top" ><p>update</p></td>
<td valign="top" ><p>Method to update a row by a array of fields and theirs values and its primary key</p></td>
</tr>

<tr>
<td valign="top" ><p>remove</p></td>
<td valign="top" ><p>Method to remove a row by its primary key</p></td>
</tr>

<tr>
<td valign="top" ><p>code</p></td>
<td valign="top" ><p>Method to code values before storing them in database</p></td>
</tr>

<tr>
<td valign="top" ><p>decode</p></td>
<td valign="top" ><p>Method to decode values retrieved from database </p></td>
</tr>

<tr>
<td valign="top" ><p>IsTime</p></td>
<td valign="top" ><p>Method to determine that a field type is of «time» type</p></td>
</tr>

<tr>
<td valign="top" ><p>IsText</p></td>
<td valign="top" ><p>Method to determine that a field type is of «text» type</p></td>
</tr>

<tr>
<td valign="top" ><p>IsNumber</p></td>
<td valign="top" ><p>Method to determine that a field type is of «number» type </p></td>
</tr>

<tr>
<td valign="top" ><p>IsBlob</p></td>
<td valign="top" ><p>Method to determine that a field type is of «binary» type</p></td>
</tr>

<tr>
<td valign="top" ><p>IsAggregateFunction</p></td>
<td valign="top" ><p>Method to determine that a SQL function is a aggregate function</p></td>
</tr>

<tr>
<td valign="top" ><p>localdatetime</p></td>
<td valign="top" ><p>Method to format a date and time in local format</p></td>
</tr>

<tr>
<td valign="top" ><p>localdate</p></td>
<td valign="top" ><p>Method to format a date in local format</p></td>
</tr>

</tbody>
</table>

<p>The class constructor also has to create an array of comparison conditions codes and theirs SQL equivalents of a database. </p>

<p>Components <b> Form </b>and <b>Grid</b> create all necessary SQL queries and the developer does not need to manually code SQL queries for standard operations such as inserting, updating, removing and searching rows. </p>

<h1>Handling of lists</h1>

<p>Lists can be constant or variable (dynamic). Options of constant lists are stored in the system table fgs_list. A variable list is created from a table rows. List’s specifications are stored in the “fgs_list” and options of constant lists are stored in the “fgs_option” system tables.</p>

<p>Examples of a constant list: </p>

<ul>
<li>List consisting of the two options: Yes and No</li>
<li>List consisting of the days of a week</li>
<li>List consisting of month names</li>
</ul>

<p>A variable list is based on the rows of a database table. The primary key of the table is used as option value and a text field as option description. To restrict a list’s options, you can use a dataset. </p>

<p>List are used to input or output data.</p>

<p>To input data, you can use components of selecting a single option (<b>InputSingleSelect</b>) or multiple options (<b>InputMultipleSelect</b>) of a list.</p>

<p>Lists are used to display a table’s field with the <b>ColumnLookup</b> component. For example you can display a company name instead of its code. If a field can have only two values, 0 and 1, you can display Yes or No instead of them. </p>

<p>Usually if a field is entered by selection of one or multiple list’s options then the same list is used to display the field.</p>

<p>List’s handling depends on a list type – constant or dynamic. Let’s consider difference between a constant list and a dynamic list operation on the following example. </p>

<p>Let’s suppose that an input form has got an input element of select type. If the list’s type is constant, then the <b>Configurator</b> creates the element’s specification with the list’s options. If a list’s type is variable. then the <b>Configurator</b> creates the element’s specification with the list’s specification only. The list’s options are loaded by the <b>ListLoader</b> component at run time when the input element sends the list’s attributes to <b>ListLoader</b> to load the list. If the list was loaded earlier then the <b>ListLoader</b> returns the list’s options. If the list was not loaded then the <b>ListLoader</b> loads the list and returns the list’s options.</p>

<p>A list can be used by different components, so such list handling minimizes number of SQL queries to load dynamic lists.</p>

<h1>Conditions and statements</h1>

<p>Input components have built-in simple validation of input data.</p>

<p>To make more complex validation, the Framework uses conditions and statements. One condition can have a number of statements. </p>

<p>A statement is a logical expression which can be presented as:</p>

<p>&lt;Operand 1&gt; comparison operator &lt; Operand 2&gt; </p>

<p>So to validate input data means to check statements of a condition. </p>

<p>A condition can be used to restrict actions for table rows or displaying certain fields. For example, we can allow updating and removing table rows only for the users with certain roles. </p>

<p>The statement is the evolution of the predicate idea with regard to validation of input data. Statements, like predicates, can also be united in logical groups. Difference between these two notions lies in that predicates’ checking is preformed by DBMS and statements’ checking is preformed by the components <b>ConditionTester</b> or <b>Validator</b> of the Framework. The <b>ConditionTester</b> is used to check standard statements and <b>Validator</b> for custom ones.</p>

<p>By skillfully combining and using appropriate configuration of statements you can do very complex validation of input data.</p>

<h1>Ajax support</h1>

<p>The Framework has built-in support of autocomplete input fields, chained select’s, inline editing of rows. Also the jQuery <em>Datepicker</em> can be use to input dates. You can use these features without any coding on JavaScript, SQL or PHP. </p>

<p>Let’s consider how the Framework does this.</p>

<p>The special jQuery component sends all necessary data in JSON format for JavaScript.</p>

<p>The following files are for Ajax support:</p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>file</p></td>
<td valign="top" ><p>comments</p></td>
</tr>

<tr>
<td valign="top" ><p>fgs.js</p></td>
<td valign="top" ><p>Library of JavaScript functions</p></td>
</tr>

<tr>
<td valign="top" ><p>autocomplete.php</p></td>
<td valign="top" ><p>Handler of Ajax request for autocomplete input fields</p></td>
</tr>

<tr>
<td valign="top" ><p>cell_edit.php</p></td>
<td valign="top" ><p>Handler of Ajax request for inline editing of rows</p></td>
</tr>

<tr>
<td valign="top" ><p>list.php</p></td>
<td valign="top" ><p>Handler of Ajax request for chained selects</p></td>
</tr>

<tr>
<td valign="top" ><p>toggleDebug.php</p></td>
<td valign="top" ><p>Handler of Ajax request for On/Off of debug mode</p></td>
</tr>

<tr>
<td valign="top" ><p>toggleFGS.php</p></td>
<td valign="top" ><p>Handler of Ajax request for show/hide the Form, <b>Grid</b> or <b>Search</b> components</p></td>
</tr>

<tr>
<td valign="top" ><p>toggleMenu.php</p></td>
<td valign="top" ><p>Handler of Ajax request for show/hide of a menu</p></td>
</tr>

</tbody>
</table>

<p>The Framework uses the jQuery Framework.</p>

<p>The jQuery component adds next JavaScript code for all pages:</p>

<p>$(document).ready(initControls)</p>

<p>The initControls function can be found in the fgs.js file. It executes this sequence of functions:</p>

<ul>
<li>initDataPicker to tie the jQuery Datepicker to input fields for dates</li>
<li>initAutocomplete to tie the jQuery autocomplete to autocomplete input fields</li>
<li>inlineEdit to tie all necessary JavaScript events to rows’ fields for inline editing </li>
</ul>

<p>The handler of Ajax requests for autocomplete input fields (autocomplete.php) receives system id of an input element as an argument. The handler creates the object using the specification of the input element. Using this object’s attributes the <b>ListLoader</b> loads the required list. The handler transforms the list to JSON format and sends it to the client.</p>

<p>The handler of Ajax requests for chained selects (list.php) receives system id of the next select element as an argument. The handler creates the object using the specification of the next select element. The handler gets rendering of the object and sends it to the client.</p>

<p>Handler of Ajax requests for inline editing of rows (cell_edit.php) receives system id of an input column and updated value as arguments. The handler creates the object using the specification of the column. If validation of the updated value is successful then it is stored in database.</p>

<h1>Using standard components extensions</h1>

<p>During development of a real application you will get problems that cannot be resolved by using standard components of the Framework. </p>

<p>A component’s specification can include attributes which indicate using custom components. For example, in a Unit’s specification you can set a custom controller, Form, <b>Grid</b>, <b>Search</b>, <b>Dataset</b> and renderers. For a list you can set custom list loader. You can also use custom validators, conditions, predicates etc. </p>

<p>If you need to use a custom renderer it is necessary to configure the «renderer» attribute. The value of this attribute means a custom renderer with a static method «render».</p>

<p>Extension of standard components has to meet some requirements. You can find information about possibility of adding new features and necessary requirements in a component description n this Guide.</p>

<h1>The Evaluator component</h1>

<p>The <b>Evaluator</b> plays important role and provides other components with access to data which will become known only at run time. These data can be the user’s id, role or data entered by the user.</p>

<p>The <b>Evaluator</b> is used to calculate expressions at run time. It has got only the «get» static method which receives an expression to evaluate and an optional parameter as arguments. If you need to call the method with multiple parameters then you should pass them as an array.</p>

<p>An expression that you passed in the method has to be in certain format. The <b>Evaluator</b> treats some symbols as calculation instructions. </p>

<p>If the «#» symbol is the first symbol of an expression then the <b>eval</b> function is used to evaluate the expression.</p>

<p>If the «@» symbol is the first symbol of an expression then the expression without this first symbol is considered as a function if such function exists or as name of a class with the «get» static method. </p>

<p>If the «&amp;» symbol is the first symbol of the estimated expression then three following symbols of the expression that starting from 1 are considered as the source array id and the rest of the part of the expression without the beginning and ending whitespaces is considered as name of a variable.</p>

<p>If the first symbol of an expression is not «#», «@» and «&amp;» then the method returns the expression itself.</p>

<p>A source array id may indicate the following array sources:</p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>source array id</p></td>
<td valign="top" ><p>source array</p></td>
<td valign="top" ><p>variable name is treated as:</p></td>
</tr>

<tr>
<td valign="top" ><p>ses</p></td>
<td valign="top" ><p>$_SESSION</p></td>
<td valign="top" ><p>Index of an element of the array</p></td>
</tr>

<tr>
<td valign="top" ><p>glb</p></td>
<td valign="top" ><p>$GLOBALS</p></td>
<td valign="top" ><p>Index of an element of the array</p></td>
</tr>

<tr>
<td valign="top" ><p>srv</p></td>
<td valign="top" ><p>$_SERVER</p></td>
<td valign="top" ><p>Index of an element of the array</p></td>
</tr>

<tr>
<td valign="top" ><p>env</p></td>
<td valign="top" ><p>$_ENV</p></td>
<td valign="top" ><p>Index of an element of the array</p></td>
</tr>

<tr>
<td valign="top" ><p>req</p></td>
<td valign="top" ><p>$_REQUEST</p></td>
<td valign="top" ><p>Index of an element of the array</p></td>
</tr>

<tr>
<td valign="top" ><p>coo</p></td>
<td valign="top" ><p>$_COOKIE</p></td>
<td valign="top" ><p>Index of an element of the array</p></td>
</tr>

<tr>
<td valign="top" ><p>rgv</p></td>
<td valign="top" ><p>The $globals array of the <b>Registry</b></p></td>
<td valign="top" ><p>Index of an element of the array</p></td>
</tr>

<tr>
<td valign="top" ><p>arg</p></td>
<td valign="top" ><p>Passed array of parameters</p></td>
<td valign="top" ><p>Index of an element of the array</p></td>
</tr>

<tr>
<td valign="top" ><p>usr</p></td>
<td valign="top" ><p>Data array of the logged user</p></td>
<td valign="top" ><p>Index of an element of the array</p></td>
</tr>

</tbody>
</table>
<br>
<h1>The Registry component</h1>

<p>The <b>Registry</b> plays important role for the Framework. It provides:</p>

<ul>
<li>information exchange among components and in fact is the storage of applications data with global scope</li>
<li>saving and restoring components’ state</li>
<li>imitation of different session in one browser</li>
<li>interface to global data of an application</li>
<li>interface to data of the logged user</li>
<li>storage of debug information if debug information is set to be stored by the <b>Registry</b></li>
<li>forming of mandatory parameters for unambiguously identification of a GET or POST request (fgsw, fgsc, fgsu,fgst)</li>
</ul>

<p>The <b>Registry</b> stores components’ state parameters in the element with index FGS_SESSION_KEY of the $_SESSION array. FGS_SESSION_KEY must not be equal to other session variables.</p>

<p>The <b>Registry</b> uses one more constant FGS_CONTROLLER_KEY and system ids of the created Units must not be equal of this constant. FGS_CONTROLLER_KEY should not be also equal to «controller», «form», «grid», «search», «element», «operator», «connector», «argument», «argumentMin» or «argumentMax».</p>

<p>Let’s consider what parameters are and where the <b>Registry</b> stores them.</p>

<p>The current controller id of the current request window: </p>

<p>$_SESSION[FGS_SESSION_KEY][ window id][FGS_CONTROLLER_KEY] ['controller']</p>

<p>Token of successful ending of a control script</p>

<p>$_SESSION[FGS_SESSION_KEY][ window id][FGS_CONTROLLER_KEY] ['end']</p>

<p>A controller’s parameter:</p>

<p>$_SESSION[FGS_SESSION_KEY][ window id] ['controller'] [parameter name]</p>

<p>A Unit’s state parameter:</p>

<p>$_SESSION[FGS_SESSION_KEY][ window id] [Unit id] ['controller'] [parameter name]</p>

<p>A Form’s state parameter:</p>

<p>$_SESSION[FGS_SESSION_KEY][ window id] [Unit id] [‘form’] [parameter name]</p>

<p>A Form’s input element value:</p>

<p>$_SESSION[FGS_SESSION_KEY][ window id] [Unit id] [‘element] [attribute rowid]</p>

<p>A Grid’s state parameter:</p>

<p>$_SESSION[FGS_SESSION_KEY][ window id] [Unit id] [‘grid’] [parameter name]</p>

<p>A Search’s state parameter:</p>

<p>$_SESSION[FGS_SESSION_KEY][ window id] [Unit id] [‘search’] [parameter name]</p>

<p>A Search’s connector value:</p>

<p>$_SESSION[FGS_SESSION_KEY][ window id] [Unit id] [‘connector’] [attribute rowid]</p>

<p>A Search’s operators values:</p>

<p>$_SESSION[FGS_SESSION_KEY][ window id] [Unit id] [‘operator’] [attribute rowid]</p>

<p>A Search’s arguments values:</p>

<p>$_SESSION[FGS_SESSION_KEY][ window id] [Unit id] [‘argument’] [attribute rowid]</p>

<p>A Search’s argumentMin of the «range» predicate value:</p>

<p>$_SESSION[FGS_SESSION_KEY][ window id] [Unit id] [‘argumentMin’] [attribute rowid]</p>

<p>A Search’s argumentMax of the «range» predicate value:</p>

<p>$_SESSION[FGS_SESSION_KEY][ window id] [Unit id] [‘argumentMax’] [attribute rowid]</p>

<p>The <b>Registry</b> is coded by using <b>Singleton</b> design pattern.</p>

<p>Properties of the <b>Registry</b>:</p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>property</p></td>
<td valign="top" ><p>comments</p></td>
</tr>

<tr>
<td valign="top" ><p>window</p></td>
<td valign="top" ><p>Window id of the current request</p></td>
</tr>

<tr>
<td valign="top" ><p>store</p></td>
<td valign="top" ><p>Multifunctional array for date exchange between components</p></td>
</tr>

<tr>
<td valign="top" ><p>globals</p></td>
<td valign="top" ><p>Array for storing global variables of an application</p></td>
</tr>

<tr>
<td valign="top" ><p>vars</p></td>
<td valign="top" ><p>Array for storing debug variables’ values</p></td>
</tr>

<tr>
<td valign="top" ><p>requests</p></td>
<td valign="top" ><p>Array for storing the <b>RequestHandler </b>and the <b>EventHandler</b> methods’ calls for debugging</p></td>
</tr>

<tr>
<td valign="top" ><p>sql</p></td>
<td valign="top" ><p>Array for storing SQL queries’ result for debugging</p></td>
</tr>

<tr>
<td valign="top" ><p>class</p></td>
<td valign="top" ><p>Array for storing classes initialization for debugging</p></td>
</tr>

<tr>
<td valign="top" ><p>exportErrors</p></td>
<td valign="top" ><p>Array for storing specifications‘ errors during exporting of components’ specifications</p></td>
</tr>

</tbody>
</table>

<p>Methods of the <b>Registry</b></p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>method</p></td>
<td valign="top" ><p>Comments</p></td>
</tr>

<tr>
<td valign="top" ><p>getInstance</p></td>
<td valign="top" ><p>Getting of the only instance of the class</p></td>
</tr>

<tr>
<td valign="top" ><p>__construct</p></td>
<td valign="top" ><p>Class constructor must be of private type</p></td>
</tr>

<tr>
<td valign="top" ><p>setGlobal($var,$value)</p></td>
<td valign="top" ><p>Method to store value ($value) of the $var variable in the «globals» array of the component</p></td>
</tr>

<tr>
<td valign="top" ><p>getGlobal($var)</p></td>
<td valign="top" ><p>Method to return value of the $var variable from the «globals» array of the component</p></td>
</tr>

<tr>
<td valign="top" ><p>getController()</p></td>
<td valign="top" ><p>Method to set the current controller id</p></td>
</tr>

<tr>
<td valign="top" ><p>newController()</p></td>
<td valign="top" ><p>Method to determine if the controller runs the first time</p></td>
</tr>

<tr>
<td valign="top" ><p>getWindow()</p></td>
<td valign="top" ><p>Method to set the current request window id</p></td>
</tr>

<tr>
<td valign="top" ><p>set($unit, $component,$variable,$value)</p></td>
<td valign="top" ><p>Method to store value ($value) of the $var variable related to the $component component of the $unit Unit</p></td>
</tr>

<tr>
<td valign="top" ><p>get($unit, $component,$variable)</p></td>
<td valign="top" ><p>Method to return value of the $var variable related to the $component component of the $unit Unit </p></td>
</tr>

<tr>
<td valign="top" ><p>saveState($obj,$component,$unit=null)</p></td>
<td valign="top" ><p>Method to save state of the $obj object with $component type from the $unit Unit</p></td>
</tr>

<tr>
<td valign="top" ><p>restoreState(&amp;$obj,$component,$unit=null)</p></td>
<td valign="top" ><p>Method to restore state of the $obj object with $component type from the $unit Unit</p></td>
</tr>

<tr>
<td valign="top" ><p>fgsHidden($unit, $component)</p></td>
<td valign="top" ><p>Method to get HTML code for additional hidden fields which are necessary to add to forms of the $component component from the $unit Unit</p></td>
</tr>

<tr>
<td valign="top" ><p>fgsRef($unit $component)</p></td>
<td valign="top" ><p>Method to get additional parameters which are necessary to add to hyperlink of the $component component from the $unit Unit </p></td>
</tr>

<tr>
<td valign="top" ><p>fgsToggle($unit,$sid $component)</p></td>
<td valign="top" ><p>Method to show/hide the $component component from the $unit Unit</p></td>
</tr>

<tr>
<td valign="top" ><p>checkLogin()</p></td>
<td valign="top" ><p>Method of checking user’s login</p></td>
</tr>

<tr>
<td valign="top" ><p>setUser($a)</p></td>
<td valign="top" ><p>Method of storing of the logged user’s data in session variables</p></td>
</tr>

<tr>
<td valign="top" ><p>getUser()</p></td>
<td valign="top" ><p>Method of getting of the logged user’s data from session variables</p></td>
</tr>

<tr>
<td valign="top" ><p>getUserRole()</p></td>
<td valign="top" ><p>Method of getting of the logged user’s role</p></td>
</tr>

<tr>
<td valign="top" ><p>getUserId()</p></td>
<td valign="top" ><p>Method of getting of the logged user’s id</p></td>
</tr>

</tbody>
</table>
 <br>
<h1>The Abstract Component</h1>

<p>Components Form, <b>Grid</b>, <b>Search</b> and <b>Dataset</b> are descendants of the <b>Component</b> abstract class.</p>

<p>Properties of the <b>Component</b> </p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>property</p></td>
<td valign="top" ><p>comments</p></td>
</tr>

<tr>
<td valign="top" ><p>$unit</p></td>
<td valign="top" ><p>Unit id</p></td>
</tr>

<tr>
<td valign="top" ><p>$sid</p></td>
<td valign="top" ><p>Component id</p></td>
</tr>

<tr>
<td valign="top" ><p>$type</p></td>
<td valign="top" ><p>Type of component </p></td>
</tr>

<tr>
<td valign="top" ><p>$session</p></td>
<td valign="top" ><p>Array of component’s properties to save/restore</p></td>
</tr>

<tr>
<td valign="top" ><p>$initial</p></td>
<td valign="top" ><p>associative array of initial values of component’s properties</p></td>
</tr>

<tr>
<td valign="top" ><p>$errors</p></td>
<td valign="top" ><p>Array of component’s errors at run time</p></td>
</tr>

<tr>
<td valign="top" ><p>$table</p></td>
<td valign="top" ><p>Component’s base table</p></td>
</tr>

<tr>
<td valign="top" ><p>$display</p></td>
<td valign="top" ><p>Property to show/hide component</p></td>
</tr>

</tbody>
</table>

<p>Method of the <b>Component</b> </p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>method</p></td>
<td valign="top" ><p>comments</p></td>
</tr>

<tr>
<td valign="top" ><p>__construct($unit,$sid,$hide)</p>

</td>
<td valign="top" ><p>The <b>Component</b>’s constructor for the component with id equal $sid from the $unit Unit. $hide is the array of the show/hide parameters </p></td>
</tr>

<tr>
<td valign="top" ><p>saveState()</p></td>
<td valign="top" ><p>Method to save component’s state </p></td>
</tr>

<tr>
<td valign="top" ><p>restoreState()</p></td>
<td valign="top" ><p>Method to restore the component’s state</p></td>
</tr>

<tr>
<td valign="top" ><p>hide()</p></td>
<td valign="top" ><p>Method to show/hide the component </p></td>
</tr>

</tbody>
</table>
  <br>
<h1>The Form component</h1>

<p>The <b> Form </b>component is an analogue of the HTML element «form» and enables the user to input data in database tables (input form). With an input form you can input data into only one table. The table is the base table of the input form.</p>

<p>The <b> Form </b>is a container of components of two kinds:</p>

<ul>
<li>Input elements (input components)</li>
<li>Buttons </li>
</ul>

<p>The <b> Form </b>and its components have properties «current input mode» or «mode» and «possible input modes» or modes. For example a standard input form usually can have the following possible modes:</p>

<ul>
<li>Mode of inserting of a new row (insert)</li>
<li>Mode of updating of a row (update)</li>
<li>Mode of removing a row (remove)</li>
<li>Mode of viewing or reading a row (Read)</li>
<li>Mode of seeking of a row (seek)</li>
</ul>

<p>Mode «seek» is usually used for a site’s sign in form when the user types its own login and password.</p>

<p>An input form also can have so called modes for consecutive processing of row set:</p>

<ul>
<li>Mode of consecutive updating of a row set (MultiUpdate)</li>
<li>Mode of consecutive removing of a row set (MultiRemove)</li>
<li>Mode of consecutive viewing of a row set(MultiRead)</li>
</ul>

<p>Modes for consecutive processing of a row set arises when the user choose rows and an action for the chosen rows in the <b>Grid</b> component of the common Unit. The user can consecutively do editing or removing of chosen rows.</p>

<p>It’s necessary note that updating modes can be more than one. It can be useful for the user’s table. We can do updating the user’s all data excluding its login and password in the «update» mode and do updating only its login and password in the «update_partial» special mode. </p>

<p>Possible input modes permits to have different set of input elements and buttons for inserting, updating, removing or viewing a row and use for it only one specification of the <b>Form</b>.</p>

<p>Also the concept and property of starting mode are introduced for input forms. The starting mode is set at a form’s initialization. The concept is introduced for input forms used only for one kind of data processing (updating, removing, search etc).</p>

<p>The «session» property of an input form depends on its current mode. </p>

<p>The <b>Form</b> component executes cascade removing i.e. with removing of a master table row it removes also the correspondent rows of all detail tables.</p>

<p>After changing a row’s primary key the <b>Form</b> component updates all correspondent foreign keys of dependent tables (cascade updating).</p>

<p>The <b>Form</b> can have triggers i.e. actions executed before or after actions:</p>

<p>Trigger before insert</p>

<p>Trigger after insert</p>

<p>Trigger before update</p>

<p>Trigger after update</p>

<p>Trigger before remove</p>

<p>Trigger after remove</p>

<p>Trigger before seek</p>

<p>Trigger after seek</p>

<p>The standard <b>Form</b> component has got only mock functions instead of real triggers. So if you need to use triggers you have to develop an extension of the <b> Form </b>component and make appropriate configuration of the Unit that will use this custom form component. </p>

<p>Sometimes we need to join tables in SQL query for loading a row. For this purpose, there is the pseudo component <b>ElementTableJoiner</b> in the Framework. The Configurator only uses the <b>ElementTableJoiner</b> to set the «joins» property of the Form. The <b> Form </b>uses the «joins» property to make tables’ join for the SQL query. The tables’ join type is always «left join». An example of using tables’ join is described in the «Configurator guide» document.</p>

<p>A <b> Form </b>component is a part of a <b>Unit</b> component. The <b> Form </b>can interact only with the Unit itself and the <b>Grid</b> of this Unit. The <b> Form </b>changes its input mode in accordance with an event generated by the <b>Grid</b> of the common Unit. The event includes the array of primary keys of rows to process. After completion of an action the <b> Form </b>generates the «done» event and the Unit handles it.</p>

<p>In interfaces <b>MasterDetail</b> and <b>UnitSet</b> the master <b>Grid</b> can generate the «detail» event and the detail <b> Form </b>and detail <b>Grid</b> are the handlers of it. The detail <b> Form </b>can add new rows only if it configured with the special pseudo component InputForeignKey. The InputForeignKey is exported as the <b>InputSystem</b> component with the «foreign_key» property. </p>

<p>In accordance with accepted request processing algorithm the <b> Form </b>rendering must include adding of hidden fields fgsw, fgsc, fgsu and fgst. To get HTML code of these fields, you have to call the method fgsHidden of the <b>Registry</b> with the Unit id and value «form» as arguments. </p>

<p><b>Buttons of the Form</b></p>

<p>A button of an input form is an <b>InputButton</b> component. The main attributes of the <b>InputButton</b> are the following ones:</p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>Field </p></td>
<td valign="top" ><p>Label </p></td>
<td valign="top" ><p>Comments </p></td>
</tr>

<tr>
<td valign="top" ><p>element_action</p></td>
<td valign="top" ><p>Action </p></td>
<td valign="top" ><p>Action to be performed by pressing on a button</p></td>
</tr>

<tr>
<td valign="top" ><p>element_event</p></td>
<td valign="top" ><p>Event </p></td>
<td valign="top" ><p>Event generated by the <b> Form </b>after completion of an action</p></td>
</tr>

<tr>
<td valign="top" ><p>element_confirm</p></td>
<td valign="top" ><p>Confirm?</p></td>
<td valign="top" ><p>Sign to confirm pressing on a button</p></td>
</tr>

<tr>
<td valign="top" ><p>element_name</p></td>
<td valign="top" ><p>Attribute name</p></td>
<td valign="top" ><p>Attribute «name» of a button</p></td>
</tr>

<tr>
<td valign="top" ><p>element_value</p></td>
<td valign="top" ><p>Value </p></td>
<td valign="top" ><p>Attribute «value» of a button</p></td>
</tr>

</tbody>
</table>

<p>The <b> Form </b>registers actions of its <b>InputButton</b> components as possible requests. </p>

<p><b>Input elements of the Form</b></p>

<p>The following components are used for input elements of the Form</p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>component</p></td>
<td valign="top" ><p>Comments </p></td>
</tr>

<tr>
<td valign="top" ><p><b>InputAutocomplete</b></p></td>
<td valign="top" ><p>for autocomplete input fields</p></td>
</tr>

<tr>
<td valign="top" ><p><b>InputDate</b></p></td>
<td valign="top" ><p>For input of dates</p></td>
</tr>

<tr>
<td valign="top" ><p><b>InputDatetime</b></p></td>
<td valign="top" ><p>For input of date&amp;&amp;time </p></td>
</tr>

<tr>
<td valign="top" ><p><b>InputFile</b></p></td>
<td valign="top" ><p>For files uploading</p></td>
</tr>

<tr>
<td valign="top" ><p><b>InputHidden</b></p></td>
<td valign="top" ><p>for hidden fields</p></td>
</tr>

<tr>
<td valign="top" ><p><b>InputMultipleSelect</b></p></td>
<td valign="top" ><p>For input with multiple select</p></td>
</tr>

<tr>
<td valign="top" ><p><b>InputSecret</b></p></td>
<td valign="top" ><p>For input of passwords</p></td>
</tr>

<tr>
<td valign="top" ><p><b>InputSingleSelect</b></p></td>
<td valign="top" ><p>For input with single select</p></td>
</tr>

<tr>
<td valign="top" ><p><b>InputSystem</b></p></td>
<td valign="top" ><p>For input of system fields</p></td>
</tr>

<tr>
<td valign="top" ><p><b>InputText</b></p></td>
<td valign="top" ><p>For input field of the «text» type</p></td>
</tr>

<tr>
<td valign="top" ><p><b>InputTextarea</b></p></td>
<td valign="top" ><p>For input with textarea</p></td>
</tr>

<tr>
<td valign="top" ><p><b>InputTime</b></p></td>
<td valign="top" ><p>For input of times</p></td>
</tr>

<tr>
<td valign="top" ><p><b>SelectBooleanCheckbox</b></p></td>
<td valign="top" ><p>For input of Boolean true/false</p></td>
</tr>

</tbody>
</table>

<p>All components are descendant of the <b>InputElement</b> abstract class. </p>

<p>Input elements’ values are stored in session variables.</p>

<p>Some input components have internal storage format for its values. After getting its value from database such component decodes it to its internal format. The Framework makes coding from internal to storing format of these components’ values. These coding and decoding are performed by the current database driver.</p>

<p>The <b>InputMultipleAutocomplete</b> is used to input several values delimited with a token and the <b>InputAutocomplete</b> to input only one value with a autocomplete input field. </p>

<p>The <b>InputDate</b>, <b>InputDatetime</b> and <b>InputTime</b> components have an associative array of date and/or time parts (year, month, day, hour, minute and second) as internal format. </p>

<p>Sometimes an input component’s value has to be placed within global scope. For this purpose, the input component has got the «register» property. Such components store its values in the «globals» array of the <b>Registry</b> with the index equal to value of the «register» property.</p>

<p>Under the <b>InputMultipleSelect</b> there are hidden three components: <b>SelectManyCheckbox</b>, <b>SelectManyListbox</b> and <b>SelectManyMenu</b>. From processing point of view they are the same and differ only by HTML code i.e. rendering. Choice of one of these components and its configuring depends only on input form’s requirements. However, the <b> Form </b>creates all these components as the <b>InputMultipleSelect</b> component with the appropriate renderer. The <b>InputMultipleSelect</b> component has got an array of selected options as internal storage format of its value.</p>

<p>Also under the <b>InputSingleSelect</b> components are hidden three components: <b>SelectOneListbox</b>, <b>SelectOneMenu</b> and <b>SelectOneRadio</b>. Choice of one of these components and its configuring depends only from input form requirements. However the <b> Form </b>creates all these components as the <b>InputSingleSelect</b> component with the appropriate renderer. </p>

<p>The Framework uses MD5 hash of the <b>InputSecret</b> component value instead of its value to save in database.</p>

<p>The <b>InputFile</b> component serves to upload files to server. Main mandatory attributes of this component are:</p>

<ul>
<li>Path for loaded files</li>
<li>Maximum of file size for loaded files</li>
<li>Possible extensions for loaded files</li>
</ul>

<p>The <b>InputFile</b> component performs files loading as follows:</p>

<ul>
<li>A file to be loaded is stored in an appropriate directory</li>
<li>A file’s name is stored in a table field without any change</li>
<li>If an input field is mandatory and if a file to be loaded was not executed or failed to be then in the «insert» mode an error is fixed but in the «update» mode is not. </li>
</ul>

<p>Because files’ loading can be accompanied by other actions, the <b>InputFile</b> component has got the optional attribute «extension» for a custom component. Besides, you can use triggers of the <b> Form </b>component to perform required actions.</p>

<p>The <b>InputSystem</b> component is used to input data in special (system) fields of tables. </p>

<p>Examples of such fields:</p>

<ul>
<li>id of the current user who updated the current row </li>
<li>date and time of adding the current row</li>
<li>IP-address of the current computer from which the site was accessed</li>
</ul>

<p>Once more application of the <b>InputSystem</b> component is input of foreign keys for detail tables. Note that it’s necessary only for the detail Form.</p>

<p>Input elements can be united in groups by setting the «fieldset» property. </p>

<p>Input components have got built-in simple validation of input values:</p>

<p>-if non empty value was entered for required fields </p>

<p>-checking correct format of entered values for fields with date and time types </p>

<p>-if selected options are valid options for input components as <b>InputMultipleSelect</b> or <b>InputSingleSelect</b></p>

<p>There are validators to perform more complex validation in the Form. Usually a standard validator’s specification includes attributes:</p>

<ul>
<li>Field to be checked</li>
<li>Condition for input value of the field</li>
<li>Condition’s parameter</li>
<li>Condition parameter’s type </li>
</ul>

<p>Condition parameter’s type can have one of these values, i.e. «scalar value», «input element» or «array». Condition’s parameter with the «scalar value» type can be known at configuration time or calculated only at run time.</p>

<p>Using conditions with two or more parameters requires using the «array» type as parameter’s type. For example, the condition «input value must be within a range» requires two parameters: minimal and maximum limit of the range. </p>

<p>Using the «input element» type as parameter’s type makes it possible to compare values of two input fields. For example, you can check if values of the fields «password» and «confirm password» are equal.</p>

<p>Checking standard conditions is performed by the <b>ConditionTester</b> component.</p>

<p>If a validator uses a nonstandard condition then it’s necessary to set two additional attributes:</p>

<ul>
<li>class of the nonstandard condition</li>
<li>type of the class method to check: static or non static</li>
</ul>

<p>The class method to check must have name «test».</p>

<p>Checking nonstandard conditions is performed by the <b>Validator</b> component. </p>

<p>An input field can have any number of validators. The order of the validators’ checking is set at its configuration.</p>

<p>The Framework has set of standard conditions </p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>Condition ID</p></td>
<td valign="top" ><p>comments</p></td>
</tr>

<tr>
<td valign="top" ><p>AlphabeticDigit</p></td>
<td valign="top" ><p>Value must include only letters and numbers</p></td>
</tr>

<tr>
<td valign="top" ><p>Digits</p></td>
<td valign="top" ><p>Value must include only numbers</p></td>
</tr>

<tr>
<td valign="top" ><p>EmailAddress</p></td>
<td valign="top" ><p>Value must be a valid Email address</p></td>
</tr>

<tr>
<td valign="top" ><p>Equal</p></td>
<td valign="top" ><p>Value must be equal with some value</p></td>
</tr>

<tr>
<td valign="top" ><p>Float</p></td>
<td valign="top" ><p>Value must be number of float type</p></td>
</tr>

<tr>
<td valign="top" ><p>Greater</p></td>
<td valign="top" ><p>Value must be greater than certain value</p></td>
</tr>

<tr>
<td valign="top" ><p>GreaterOrEqual</p></td>
<td valign="top" ><p>Value must be greater or equal to certain value</p></td>
</tr>

<tr>
<td valign="top" ><p>InArray</p></td>
<td valign="top" ><p>Value must be an array element</p></td>
</tr>

<tr>
<td valign="top" ><p>Integer</p></td>
<td valign="top" ><p>Value must be a number of integer type</p></td>
</tr>

<tr>
<td valign="top" ><p>Less</p></td>
<td valign="top" ><p>Value must be less than some value</p></td>
</tr>

<tr>
<td valign="top" ><p>LessOrEqual</p></td>
<td valign="top" ><p>Value must be less or equal to certain value</p></td>
</tr>

<tr>
<td valign="top" ><p>NotInArray</p></td>
<td valign="top" ><p>Value must not be an array element</p></td>
</tr>

<tr>
<td valign="top" ><p>OutOfRange</p></td>
<td valign="top" ><p>value must be out of a range</p></td>
</tr>

<tr>
<td valign="top" ><p>Range</p></td>
<td valign="top" ><p>value must be within a range</p></td>
</tr>

<tr>
<td valign="top" ><p>Regex</p></td>
<td valign="top" ><p>Value must include a pattern</p></td>
</tr>

<tr>
<td valign="top" ><p>StringLength</p></td>
<td valign="top" ><p>Length of the value must be within a range</p></td>
</tr>

<tr>
<td valign="top" ><p>URL</p></td>
<td valign="top" ><p>Value must be a valid URL</p></td>
</tr>

</tbody>
</table>

<p>To make validation of input data, the <b> Form </b>component calls the “validate” validation method of its elements in a loop with the formValue associative array as an argument. The formValue is the array of the <b> Form </b>input components’ values plus elements for attributes:</p>

<ul>
<li>The <b> Form </b>system id with «xxx_sid» as index of the element</li>
<li>The <b> Form </b>mode «xxx_mode» as index of the element</li>
</ul>

<p>These indexes are chosen to avoid coinciding with input fields’ names.</p>

<p>An input component performs loop of checking its validators in turn. If a validator is nonstandard then the «test» method of the <b>Validator</b> is called and, otherwise, the «test» method of the <b>ConditionTester</b> if a validator is standard. The «test» method of the <b>Validator</b> receives the validator’s specification and the formValue array. The «test» method of the <b>ConditionTester</b> receives the validator’s array of statements specification and the formValue array.</p>

<p>There are input filters to filter input data in the Framework.</p>

<p>Main attributes of a filter’s specification are:</p>

<ul>
<li>Field to be filtered</li>
<li>Converter of a field value</li>
<li>Parameters of filtering</li>
<li>Type of parameter of filtering</li>
</ul>

<p>As for validators, you can chose one of these values «scalar value», «input element» or «array» as a type of parameter of filtering.</p>

<p>It’s necessary to note that a converter is also a name of a filter’s class. It means that any converter corresponds to its own class. </p>

<p>The Framework includes set of standard input filters </p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>Filter </p></td>
<td valign="top" ><p>Comments</p></td>
</tr>

<tr>
<td valign="top" ><p>FilterAlphabeticDigit</p></td>
<td valign="top" ><p>Filter removes all symbols excluding letters and numbers</p></td>
</tr>

<tr>
<td valign="top" ><p>FilterDigits</p></td>
<td valign="top" ><p>Filter removes all symbols excluding numbers</p></td>
</tr>

</tbody>
</table>

<p>If an input filter has to be used after checking of a condition then the filter’s specification has to have attributes as such for validators: </p>

<ul>
<li>field to be checked</li>
<li>Condition to be met by input value of the field</li>
<li>Condition’s parameters</li>
<li>Condition parameter’s type </li>
</ul>

<p>The Framework has the <b>FgsFormView</b> component to render input forms and the <b>FormKit</b> component to render input components.</p>

<p>To use a custom renderer, it’s necessary to set name of the custom renderer for input form renderer in Unit’s specification.</p>

<p>To use custom rendering of an input element, it’s necessary to set the “renderer” attribute in the element’s specification. The value of the “renderer” attribute must be a name of the class that performs HTML coding of the element with its static method «render». </p>

<p>Apart from the properties and methods inherited from the <b>Component</b> abstract class, the <b> Form </b>has its own properties and methods.</p>

<p>Properties of the Form</p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>property</p></td>
<td valign="top" ><p>comments</p></td>
</tr>

<tr>
<td valign="top" ><p>e</p></td>
<td valign="top" ><p>Array of input elements</p></td>
</tr>

<tr>
<td valign="top" ><p>b</p></td>
<td valign="top" ><p>Array of buttons</p></td>
</tr>

<tr>
<td valign="top" ><p>mode</p></td>
<td valign="top" ><p>Current input mode</p></td>
</tr>

<tr>
<td valign="top" ><p>apk</p></td>
<td valign="top" ><p>Array of primary keys of processing rows</p></td>
</tr>

<tr>
<td valign="top" ><p>foreign_key</p></td>
<td valign="top" ><p>Foreign key value for detail table</p></td>
</tr>

<tr>
<td valign="top" ><p>primary_key</p></td>
<td valign="top" ><p>Primary key of the Form’s base table</p></td>
</tr>

<tr>
<td valign="top" ><p>select</p></td>
<td valign="top" ><p>Clause select of SQL query for a row retrieval</p></td>
</tr>

<tr>
<td valign="top" ><p>from</p></td>
<td valign="top" ><p>Clause from of SQL query for a row retrieval</p></td>
</tr>

<tr>
<td valign="top" ><p>irow</p></td>
<td valign="top" ><p>Index of the current row in the “apk” array</p></td>
</tr>

<tr>
<td valign="top" ><p>err</p></td>
<td valign="top" ><p>Array of input errors</p></td>
</tr>

<tr>
<td valign="top" ><p>query</p></td>
<td valign="top" ><p>SQL query for a row retrieval</p></td>
</tr>

<tr>
<td valign="top" ><p>row</p></td>
<td valign="top" ><p>Array of the current row data</p></td>
</tr>

<tr>
<td valign="top" ><p>aSession</p></td>
<td valign="top" ><p>Array of the <b> Form </b>state’s parameters that depends on input mode</p></td>
</tr>

<tr>
<td valign="top" ><p>reference</p></td>
<td valign="top" ><p>Array of fields that are foreign keys corresponding to the <b> Form </b>base table’s primary key</p></td>
</tr>

<tr>
<td valign="top" ><p>descendant</p></td>
<td valign="top" ><p>Array of fields that are foreign keys corresponding to the <b> Form </b>base table’s primary key and the <b> Form </b>base table’s type equal to “master table” </p></td>
</tr>

<tr>
<td valign="top" ><p>dependent</p></td>
<td valign="top" ><p>Array of fields that are foreign keys corresponding to the <b> Form </b>base table’s primary key and the <b> Form </b>base table’s type equal to “reference table”</p></td>
</tr>

<tr>
<td valign="top" ><p>eventTrigger</p></td>
<td valign="top" ><p>Array of events’ triggers</p></td>
</tr>

<tr>
<td valign="top" ><p>failure</p></td>
<td valign="top" ><p>Sign of input error</p></td>
</tr>

<tr>
<td valign="top" ><p>affected_rows</p></td>
<td valign="top" ><p>Number of affected rows</p></td>
</tr>

<tr>
<td valign="top" ><p>formValue</p></td>
<td valign="top" ><p>Array of input components’ values</p></td>
</tr>

<tr>
<td valign="top" ><p>type</p></td>
<td valign="top" ><p>The <b> Form </b>component’s type. It is equal to 'form'</p></td>
</tr>

</tbody>
</table>

<p>The <b> Form </b>uses the “reference”, ” descendant” ,” dependent” attributes to provide referential integrity for database management systems (DBMS) which does not support this type of data validation before it is entered into the database. </p>

<p>If a value of a table’s primary key changed then all correspondent foreign keys have to be changed too. If the value of a Form’s base’s table primary key changed then the “reference” attribute is used to cascade updating of all correspondent foreign keys. </p>

<p>If a row of master table deleted then all correspondent rows of the detail table have to be deleted too. If of a Form’s base’s table is the master table then if a row of this table deleted then the ”descendant” attribute is used to cascade deleting of correspondent rows of detail tables.</p>

<p>Before removing a row of a reference table, there have to be made checking existence of rows, which refer to the removing row. If such rows were found then removing has to be cancelled. If of a Form’s base’s table is a reference table then if a row of this table is to be deleted then the ” dependent” attribute is used to check existence of rows, which refer to the removing row.</p>

<p>Cascade updating and deleting and checking existence is made by the DBMS driver. If DBMS supports referential integrity then correspondent methods of the driver do not have to execute these operations. </p>

<p>Main methods of the Form</p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>method</p></td>
<td valign="top" ><p>Comments</p></td>
</tr>

<tr>
<td valign="top" ><p>__construct($unit,$sid,$hide)</p></td>
<td valign="top" ><p>Class constructor</p>

<p>$unit –Unit id</p>

<p>$sid- input form id</p>

<p>$hide – parameter of show/hide logic</p></td>
</tr>

<tr>
<td valign="top" ><p>initState($s=null)</p></td>
<td valign="top" ><p>Method to set initiate properties’ values </p>

<p>$s – attribute show/hide and its initial value</p></td>
</tr>

<tr>
<td valign="top" ><p>saveState()</p></td>
<td valign="top" ><p>Method to save the Form’s state</p></td>
</tr>

<tr>
<td valign="top" ><p>restoreState()</p></td>
<td valign="top" ><p>Method to restore the Form’s state</p></td>
</tr>

<tr>
<td valign="top" ><p>replaceConfig($sid)</p></td>
<td valign="top" ><p>Method to replace the Form’s specification by specification with the $sid id </p></td>
</tr>

<tr>
<td valign="top" ><p>row($ipk)</p></td>
<td valign="top" ><p>Method to load a row with the $ipk index</p></td>
</tr>

<tr>
<td valign="top" ><p>go($args)</p></td>
<td valign="top" ><p>Method to handle a request to process a row from a row set </p>

<p>$args – parameters of a row to process</p></td>
</tr>

<tr>
<td valign="top" ><p>processEvent($event,$args=null)</p></td>
<td valign="top" ><p>Method to process events</p>

<p>$event – parameters of a event to process</p>

<p>$args – additional parameters of a event</p></td>
</tr>

<tr>
<td valign="top" ><p>subscribe()</p></td>
<td valign="top" ><p>Method to register internal possible request and events</p></td>
</tr>

<tr>
<td valign="top" ><p>processRequest($args)</p></td>
<td valign="top" ><p>Method to process requests</p>

<p>$args – parameters of a request</p></td>
</tr>

<tr>
<td valign="top" ><p>fire($obj)</p></td>
<td valign="top" ><p>Method to generate an event</p>

<p>$obj- an instance of the <b>InputButton</b> component</p></td>
</tr>

<tr>
<td valign="top" ><p>initElements()</p></td>
<td valign="top" ><p>Method to initiate input components’ values</p></td>
</tr>

<tr>
<td valign="top" ><p>validate()</p></td>
<td valign="top" ><p>Method to validate input components’ values</p></td>
</tr>

<tr>
<td valign="top" ><p>ApplyRequestValues()</p></td>
<td valign="top" ><p>Applying of input values </p></td>
</tr>

<tr>
<td valign="top" ><p>seek($args=null)</p></td>
<td valign="top" ><p>Method to process the request to seek a row</p>

<p>$args – parameters of the request</p></td>
</tr>

<tr>
<td valign="top" ><p>insert($args=null)</p></td>
<td valign="top" ><p>Method to process the request to insert a row</p>

<p>$args- parameters of the request</p></td>
</tr>

<tr>
<td valign="top" ><p>update($args=null)</p></td>
<td valign="top" ><p>Method to process the request to update a row</p>

<p>$args- parameters of the request</p></td>
</tr>

<tr>
<td valign="top" ><p>remove($args=null)</p></td>
<td valign="top" ><p>Method to process the request to remove a row</p>

<p>$args- parameters of the request</p></td>
</tr>

<tr>
<td valign="top" ><p>multi_remove($args=null)</p></td>
<td valign="top" ><p>Method to process the request to remove a row set</p>

<p>$args- parameters of the request</p></td>
</tr>

<tr>
<td valign="top" ><p>hasReferences($i)</p></td>
<td valign="top" ><p>Method to check existence of rows which refer to removing row with index $i</p></td>
</tr>

<tr>
<td valign="top" ><p>removeDescendants($i)</p></td>
<td valign="top" ><p>Method to remove rows of detail tables which correspond to a removing row of a master table with the $i index of the removing row</p></td>
</tr>

<tr>
<td valign="top" ><p>setQuery()</p></td>
<td valign="top" ><p>Method to construct a SQL query for a row retrieval</p></td>
</tr>

<tr>
<td valign="top" ><p>before_seek()</p></td>
<td valign="top" ><p>Method to be performed before processing of the request to a row seeking</p></td>
</tr>

<tr>
<td valign="top" ><p>before_insert()</p></td>
<td valign="top" ><p>Method to be performed before processing of the request to a row inserting</p></td>
</tr>

<tr>
<td valign="top" ><p>before_update()</p></td>
<td valign="top" ><p>Method to be performed before processing of the request to a row updating</p></td>
</tr>

<tr>
<td valign="top" ><p>before_remove()</p></td>
<td valign="top" ><p>Method to be performed before processing of the request to a row removing</p></td>
</tr>

<tr>
<td valign="top" ><p>after_seek()</p></td>
<td valign="top" ><p>Method to be performed after processing of the request to a row seeking</p></td>
</tr>

<tr>
<td valign="top" ><p>after_insert()</p></td>
<td valign="top" ><p>Method to be performed after processing of the request to a row inserting</p></td>
</tr>

<tr>
<td valign="top" ><p>after_update()</p></td>
<td valign="top" ><p>Method to be performed after processing of the request to a row updating</p></td>
</tr>

<tr>
<td valign="top" ><p>after_remove()</p></td>
<td valign="top" ><p>Method to be performed after processing of the request to a row removing</p></td>
</tr>

</tbody>
</table>
 <br>
<h1>The Grid component </h1>

<p>The <b>Grid</b> component has HTML element «table» as analog and is used mainly to display database table rows in HTML table. The database table is called the base table. The <b>Grid</b> component let the user to navigate through rows, change order and direction of rows and choose actions for a single row or a set of selected rows. </p>

<p>In common case, the <b>Grid</b> components consists of columns to display or input fields, columns of actions for a single row, a column to select rows via marking a checkbox and action buttons on selected rows. There are pages’ hyperlinks, input fields to change position within the set of selected rows for the first retrieving row and quantity of rows per page </p>

<p>The <b>Grid</b> component can have components of 6 types:</p>

<ul>
<li>Component to display or to input field’s value (<b>Column</b>)</li>
<li>Component to choose actions for a single row (<b>RowAction</b> )</li>
<li>Component to choose actions for a set of selected rows (<b>RowSetAction</b> )</li>
<li>Component to choose a row (<b>RowSelector</b> )</li>
<li>Component to input a field’s value (<b>InputColumn</b> )</li>
<li>Button (<b>GridButton</b> )</li>
</ul>

<p>To simplify configuration of displaying data, there are following Column components in the Framework:</p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>component</p></td>
<td valign="top" ><p>Comments</p></td>
</tr>

<tr>
<td valign="top" ><p><b>ColumnText</b> </p></td>
<td valign="top" ><p>To output a field’s value without changing</p></td>
</tr>

<tr>
<td valign="top" ><p><b>ColumnDate</b> </p></td>
<td valign="top" ><p>To output values of the “date” type in local format</p></td>
</tr>

<tr>
<td valign="top" ><p><b>ColumnDatetime</b></p></td>
<td valign="top" ><p>To output values of the “datetime” type in local format </p></td>
</tr>

<tr>
<td valign="top" ><p><b>ColumnLink</b></p></td>
<td valign="top" ><p>To output a field’s value as a hyperlink</p></td>
</tr>

<tr>
<td valign="top" ><p><b>ColumnLookup</b> </p></td>
<td valign="top" ><p>To output a field’s value with a list</p></td>
</tr>

</tbody>
</table>
       <br>
<p>The <b>Confugurator</b> exports all these components into the same component the <b>Column</b> with appropriate renderer.</p>

<p>Components for fields output or input </p>

<p>The <b>ColumnLink</b> component must always have the “renderer” attribute. This attribute must be equal to a name of the class with the «render» static method which constructs the hyperlink. </p>

<p>The <b>RowSelector</b>  component is rendered as checkboxes (one for a row) and is intended to choose a table row. Updating, removing or viewing of selected rows can be done by checking these rows’ checkboxes and clicking by mouse on an appropriate <b>RowSetAction</b>  component.</p>

<p>The <b>RowAction</b>  component is usually rendered as an icon - hyperlink which has the “key” and action name as its parameters. The “key” parameter has to be equal to the row primary key and action name to the row number.</p>

<p>If a primary key consists of several fields then these fields’ values are concatenated with underscore.</p>

<p>The <b>RowSetAction</b>  component is rendered as a submit button of the HTML form, which includes also checkboxes of the <b>RowSelector</b>  component.</p>

<p>The <b>RowAction</b>  or <b>RowSetAction</b>  component can have as an attribute a condition which validates of the component action. To check the condition the <b>Grid</b> component uses the <b>ConditionTester</b> or <b>Valdator</b> for non – standard conditions. The <b>ConditionTester</b> or Valdator receives the condition’s parameters and the tested row’s data.</p>


<p>The <b>RowAction</b>  and <b>RowSetAction</b>  components are used to send selected action and parameters of selected rows to the <b> Form </b>component. However, it’s possible to configure these components to perform actions by the <b>Grid</b> component itself. For example, it’s possible to perform removing rows by the <b> Form </b>component or by the <b>Grid</b> component. In first case the <b> Form </b>displays a removing row data and the user can remove the row by pressing on the button “Remove”. In second case, the user clicks on a row’s icon “Remove” and this row’s removing executes straight away. </p>

<p>For setting any number of displaying rows on a page and any starting number of rows an auxiliary HTML form is used.</p>

<p>In accordance with accepted request processing algorithm, all HTML forms and hyperlinks related to the <b>Grid</b> component must send fgsc, fgsu, fgst variables as parameters. The fgsw variable is an optional parameter and it should be sent only if necessary. To get HTML code of these parameters for a HTML form, you have to call the method fgsHidden of the <b>Registry</b> with the common <b>Unit</b> id and value «grid» as arguments. To get HTML code of these fields for a hyperlink, you have to call the “fgsRef” method of the <b>Registry</b> with the same arguments. </p>

<p>The <b>Grid</b> component registers <b>RowAction</b> , <b>RowSetAction</b> , <b>GridButton</b>  components as it’s possible request actions and registers requests to change attributes offset, pagesize, order and direction.</p>

<p>Apart from displaying rows, the <b>Grid</b> component can be used to perform rows’ editing of two types.</p>

<p>To perform editing rows of the first type, you have to double click by mouse on desired field of a desired row. Such editing is known as inline editing. In inline editing saving of updated data is performed after pressing key Enter in a input field with type “text” or after selecting an option in input field of “select” type.</p>

<p>Editing of the second type does not require any action from the user. The user can edit data in a spreadsheet-like format. To save updated data the user has to press on a button of the <b>Grid</b> component (<b>GridButton</b>). </p>

<p>The <b>Grid</b> is a part of a <b>Unit</b> component. Usually after the user chose an action on a single row or a set of rows the <b>Grid</b> component generates the appropriate event. The detail <b>Grid</b> is one of handlers of the «detail» event generated by the master <b>Grid</b>. The <b>Grid</b> component also processes the «search» event generated by the <b>Search</b> component after setting a new or dropping a row filter.</p>

<p>To load displaying rows, the <b>Grid</b> component uses row filters, which are set both by the <b>Dataset</b> and the <b>Search</b> component.</p>

<p>Sometimes a SQL query has to select data from several tables by using tables’ join. For this purpose, there is the pseudo component <b>ColumnTableJoiner</b> in the Framework. The Configurator only uses this component to set the property «joins» of the <b>Grid</b>. In turn the <b>Grid</b> component uses the «joins» property to do tables’ join for the target SQL query. Unlike of the <b> Form </b>component, it’s necessary to set a type of table join in a <b>ColumnTableJoiner</b>’s specification.</p>

<p>Usually, to display fields with the <b>ColumnLookup</b> using a dynamic list component, the <b>Grid</b> component does left join with the list’s table. But if there are reasons not to do so then you can prohibit the table join change for the <b>Grid</b> component.</p>

<p>The <b>Grid</b> component permits forming multirows headers. To do this, you should configure the «Headerspan» property of the <b>Grid</b> component and the «Header» and the «Span» properties of its columns.</p>

<p>To get sum of columns’ values and to display columns’ totals, it’s necessary to set the “Calculate” property of columns during configuration of them.</p>

<p>Rows’ sorting can be done by fields of the base or non-base tables. Besides, sorting can be done with a permanent part, which is added at the beginning or ending part of the clause “order by” in a SQL query for rows’ retrieval.</p>

<p>Apart from properties and methods inherited from the <b>Component,</b> the <b>Grid</b> has got its own properties and methods.</p>

<p>Properties related to the <b>Grid</b> component’s state</p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>property</p></td>
<td valign="top" ><p>Comments</p></td>
</tr>

<tr>
<td valign="top" ><p>pagesize</p></td>
<td valign="top" ><p>Number of displaying rows per page</p></td>
</tr>

<tr>
<td valign="top" ><p>direction</p></td>
<td valign="top" ><p>Current direction of rows’ sorting</p></td>
</tr>

<tr>
<td valign="top" ><p>order</p></td>
<td valign="top" ><p>Current value of sorting</p></td>
</tr>

<tr>
<td valign="top" ><p>offset</p></td>
<td valign="top" ><p>Current position within the set of selected rows for the first retrieving row</p></td>
</tr>

<tr>
<td valign="top" ><p>hide</p></td>
<td valign="top" ><p>Sign to hide the <b>Grid</b> after the user chooses an action on a single row to be performed by the <b> Form </b>component</p></td>
</tr>

<tr>
<td valign="top" ><p>multimode_hide</p></td>
<td valign="top" ><p>Sign to hide the <b>Grid</b> after the user choose an action on a set of rows to be performed by the <b> Form </b>component</p></td>
</tr>

<tr>
<td valign="top" ><p>display</p></td>
<td valign="top" ><p>Sign to display the <b>Grid</b></p></td>
</tr>

<tr>
<td valign="top" ><p>apk</p></td>
<td valign="top" ><p>Array of primary keys’ values for displayed rows</p></td>
</tr>

<tr>
<td valign="top" ><p>adk</p></td>
<td valign="top" ><p>Array of additional fields’ values keys for displayed rows</p></td>
</tr>

<tr>
<td valign="top" ><p>foreign_key</p></td>
<td valign="top" ><p>Foreign key’s value for a detail table</p></td>
</tr>

</tbody>
</table>

<p>Using an array of primary keys’ values for displayed rows permits the user to do an action only on the displayed rows.</p>

<p>To make the <b>Grid</b> to add a column field’s value into an array of additional fields’ values keys for displayed rows, it’s necessary to set the “Save” attribute of the column. The “adk” array is necessary to send additional parameters of events generated by the <b>Grid</b> component. </p>

<p>Foreign key’s value for a detail table is necessary to add the following condition to a SQL query for retrieval of displaying rows: </p>

<p><b>Foreign key of the detail table=primary key of the master table.</b></p>

<p>Properties not related to the <b>Grid</b> component’s state</p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>property</p></td>
<td valign="top" ><p>comments</p></td>
</tr>

<tr>
<td valign="top" ><p>c</p></td>
<td valign="top" ><p>Collection of the Column components</p></td>
</tr>

<tr>
<td valign="top" ><p>ra</p></td>
<td valign="top" ><p>Collection of the <b>RowAction</b> components and компонент </p></td>
</tr>

<tr>
<td valign="top" ><p>rsa</p></td>
<td valign="top" ><p>Collection of the <b>RowSetAction</b> components</p></td>
</tr>

<tr>
<td valign="top" ><p>b</p></td>
<td valign="top" ><p>Collection of the <b>GridButton</b> components</p></td>
</tr>

<tr>
<td valign="top" ><p>nrows</p></td>
<td valign="top" ><p>Number of displaying rows on the current page</p></td>
</tr>

<tr>
<td valign="top" ><p>total</p></td>
<td valign="top" ><p>Total number of rows to display</p></td>
</tr>

<tr>
<td valign="top" ><p>query</p></td>
<td valign="top" ><p>SQL query for retrieval of displaying rows on the current page</p></td>
</tr>

<tr>
<td valign="top" ><p>set</p></td>
<td valign="top" ><p>Collection of displaying rows in the current page</p></td>
</tr>

<tr>
<td valign="top" ><p>err</p></td>
<td valign="top" ><p>Collection of input errors</p></td>
</tr>

<tr>
<td valign="top" ><p>editable</p></td>
<td valign="top" ><p>Sign that there are editable columns in a <b>Grid</b></p></td>
</tr>

<tr>
<td valign="top" ><p>type</p></td>
<td valign="top" ><p>Type of the <b>Grid</b> component. It is equal to 'grid'</p></td>
</tr>

</tbody>
</table>

<p>Methods of the <b>Grid</b> component</p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>method</p></td>
<td valign="top" ><p>comments</p></td>
</tr>

<tr>
<td valign="top" ><p>__construct($unit,$sid,$hide)</p></td>
<td valign="top" ><p>Class constructor</p>

<p>$unit –Unit id</p>

<p>$sid- input form id</p>

<p>$hide – parameter of show/hide logic</p></td>
</tr>

<tr>
<td valign="top" ><p>initState($s=null)</p></td>
<td valign="top" ><p>Method to initiate properties’ values </p>

<p>$s – attribute show/hide and its initial values</p></td>
</tr>

<tr>
<td valign="top" ><p>saveState()</p></td>
<td valign="top" ><p>Method to save the <b>Grid</b>’s state</p></td>
</tr>

<tr>
<td valign="top" ><p>restoreState()</p></td>
<td valign="top" ><p>Method to restore the <b>Grid</b>’s state</p></td>
</tr>

<tr>
<td valign="top" ><p>row($irow=0)</p></td>
<td valign="top" ><p>Mthod to load the row with the $ipk index in the $apk array</p></td>
</tr>

<tr>
<td valign="top" ><p>page($saveKeyes=false,$rowPK=null)</p></td>
<td valign="top" ><p>Method to load a set of displaying rows on the current page</p>

<p>$saveKeyes – sign to create arrays $apk and $adk</p>

<p>$rowPK – condition for primary key’s value</p></td>
</tr>

<tr>
<td valign="top" ><p>saveKeyes($setGlobal=false)</p></td>
<td valign="top" ><p>Method to create arrays $apk and $adk for displaying rows on the current page</p>

<p>$setGlobal- sign to store some fields’ values into the “globals” array of the <b>Registry</b> component</p></td>
</tr>

<tr>
<td valign="top" ><p>processEvent($event,$args=null)</p></td>
<td valign="top" ><p>Method to process events</p>

<p>$event – parameters of a event to process</p>

<p>$args – additional parameters of a event</p></td>
</tr>

<tr>
<td valign="top" ><p>subscribe()</p></td>
<td valign="top" ><p>Method to register internal possible request and events</p></td>
</tr>

<tr>
<td valign="top" ><p>processRequest($args)</p></td>
<td valign="top" ><p>Method to process requests</p>

<p>$args – parameters of a request</p></td>
</tr>

<tr>
<td valign="top" ><p>RowAction($args)</p></td>
<td valign="top" ><p>Method to process a requests generated by the <b>RowAction</b> component </p>

<p>$args – parameters of a request</p></td>
</tr>

<tr>
<td valign="top" ><p>isValidAction($args)</p></td>
<td valign="top" ><p>Validation method of a requests generated by the <b>RowAction</b> component </p>

<p>$args – parameters of a request</p></td>
</tr>

<tr>
<td valign="top" ><p>RowSetAction($args)</p></td>
<td valign="top" ><p>Method to process a requests generated by the <b>RowSetAction</b> component </p>

<p>$args – parameters of a request</p></td>
</tr>

<tr>
<td valign="top" ><p>isValidRowSetAction($args)</p></td>
<td valign="top" ><p>Validation method of a requests generated by the <b>RowSetAction</b> component </p>

<p>$args – parameters of a request</p></td>
</tr>

<tr>
<td valign="top" ><p>setQuery($search_filter)</p></td>
<td valign="top" ><p>Method of creation a SQL query for retrieval of displaying rows on the current page</p>

<p>$search_filter- sign of a row filter </p></td>
</tr>

<tr>
<td valign="top" ><p>setOffset($args)</p></td>
<td valign="top" ><p>Method to process a requests to set the «offset” attribute</p>

<p>$args – parameters of a request</p></td>
</tr>

<tr>
<td valign="top" ><p>setPagesize($args)</p></td>
<td valign="top" ><p>Method to process a requests to set the «pagesize” attribute</p>

<p>$args – parameters of a request</p></td>
</tr>

<tr>
<td valign="top" ><p>setOrder($args)</p></td>
<td valign="top" ><p>Method to process a requests to set the «order” attribute</p>

<p>$args – parameters of a request</p></td>
</tr>

<tr>
<td valign="top" ><p>getOrder()</p></td>
<td valign="top" ><p>Method of creation the clause “order by” of a SQL query for retrieval of displaying rows </p></td>
</tr>

<tr>
<td valign="top" ><p>save()</p></td>
<td valign="top" ><p>Method to process a requests to save updated data</p></td>
</tr>

</tbody>
</table>
     <br>
<h1>The Search component</h1>

<p>The <b>Search</b> component is an analog of HTML element «form» and enables the user to input row filters for the <b>Grid</b> component. Such form is called a search form. A row filter itself can consists of several search conditions or predicates for fields of different tables, one of which is the base table of the <b>Search</b> component.</p>

<p>In common case a predicate consists of a connector, a comparison operator and an argument. Structure of a predicate is as follows:</p>

<p>&lt;Field of a database table&gt; &lt;comparison operator&gt; &lt;argument&gt;</p>

<p>However, it’s possible to create a predicate of the type:</p>

<p>&lt;SQL function (field 1 + field 2)&gt; &lt;comparison operator&gt; &lt;argument&gt;</p>

<p>A connector is used to connect a predicate with a previous one:</p>

<p>&lt;Predicate&gt; &lt;connector&gt; &lt;predicate&gt;</p>

<p>All comparison operators can be divided into 5 groups:</p>

<ul>
<li>Comparison test</li>
<li>Pattern matching test</li>
<li>Range test</li>
<li>Set inclusion test</li>
<li>NULL TEST</li>
</ul>

<p>The <b>Search</b> component is a container of two kinds of components:</p>

<ul>
<li>Button</li>
<li>Components to input predicates</li>
</ul>

<p>Buttons of the <b>Search</b> component </p>

<p>A button of the <b>Search</b> component corresponds to an <b>InputButton</b> component.</p>

<p>The <b>Search</b> component registers actions of its <b>InputButton</b> components as possible request.</p>

<p>Components to input predicates can be of two kinds: <b>Predicate</b> and <b>PredicateRange</b>.</p>

<p>The Predicate component serves to input predicates with all comparison operators excluding those of the group “Range test” and is a container of three input elements:</p>

<p>An input element of a predicate’s connector</p>

<p>An input element of a predicate’s comparison operator</p>

<p>An input element of a predicate’s argument</p>

<p>The <b>PredicateRange</b> component serves to input predicates with comparison operators of the group “Range test” and is a container of four input elements:</p>

<p>An input element of a predicate’s connector</p>

<p>An input element of a predicate’s comparison operator</p>

<p>An input element of a predicate range bottom limit or ArgumentMin</p>

<p>An input element of a predicate range top limit or ArgumentMax</p>

<p>An input element of a predicate’s connector is a <b>SelectOneRadio</b> input component and can have only two values «AND» or «OR»</p>

<p>An input element of a predicate’s comparison operator is a <b>SelectOneMenu</b> input component. </p>

<p>If a predicate uses comparison operators of the group “NULL TEST” then the input element of the predicate’s argument is not used.</p>

<p>Values of input elements of a predicate’s connector, comparison operator, argument are stored in session variables.</p>

<p>Predicate components can be united in groups by setting the «fieldset» property. In such case, the connector of the first predicate component in the group serves as the group connector with the previous predicate component or the previous group of predicate components.</p>

<p>The <b>Search</b> component permits to construct predicates with SQL functions.</p>

<p>The <b>Search</b> component uses the <b>PredicateBuilder</b> component to construct SQL code of row filters from data entered by the user.</p>

<p>To use nonstandard method of a predicate’s constructing, it’s necessary to set the custom component’s name as value of the “Custom predicate” attribute in specification of the predicate. </p>

<p>The custom component must have the “getPredicate” static method which constructs SQL code of the predicate.</p>

<p>The <b>Search</b> component is a part of a <b>Unit</b> component. The <b>Search</b> component generates the «search» event after setting a new row filter or dropping a row filter. The <b>Search</b> component stores a row filter in the <b>Registry</b> just after setting a new row filter or after restoring its state.</p>

<p>In accordance with accepted request processing algorithm, the <b>Search</b> component’s rendering must include adding hidden fields fgsw, fgsc, fgsu and fgst. To get HTML code of these fields, you have to call the “fgsHidden” method of the <b>Registry</b> with the Unit id and value « search» as arguments. </p>

<p>Apart from properties and methods inherited from the <b>Component</b> abstract class the <b>Search</b> has got its own properties and methods.</p>

<p>Properties of the <b>Search</b></p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>Property</p></td>
<td valign="top" ><p>comments</p></td>
</tr>

<tr>
<td valign="top" ><p>P</p></td>
<td valign="top" ><p>Collection of predicate components</p></td>
</tr>

<tr>
<td valign="top" ><p>B</p></td>
<td valign="top" ><p>Collection of buttons </p></td>
</tr>

<tr>
<td valign="top" ><p>aliases</p></td>
<td valign="top" ><p>Collection of field’s aliases</p></td>
</tr>

<tr>
<td valign="top" ><p>formValue</p></td>
<td valign="top" ><p>Collection of predicate arguments’ values</p></td>
</tr>

<tr>
<td valign="top" ><p>type</p></td>
<td valign="top" ><p>The <b>Search</b> component’s type. It is equal to “search”</p></td>
</tr>

</tbody>
</table>

<p>Methods of the <b>Search</b> component</p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>метод</p></td>
<td valign="top" ><p>Comments</p></td>
</tr>

<tr>
<td valign="top" ><p>__construct($unit,$sid,$hide)</p></td>
<td valign="top" ><p>Class constructor</p>

<p>$unit –Unit id</p>

<p>$sid- input form id</p>

<p>$hide – parameter of show/hide logic</p></td>
</tr>

<tr>
<td valign="top" ><p>initState($s=null)</p></td>
<td valign="top" ><p>Method to initiate properties’ values </p>

<p>$s – attribute show/hide and its initial value</p></td>
</tr>

<tr>
<td valign="top" ><p>saveState()</p></td>
<td valign="top" ><p>Method to save the <b>Search</b>’s state</p></td>
</tr>

<tr>
<td valign="top" ><p>restoreState()</p></td>
<td valign="top" ><p>Method to restore the <b>Search</b>’s state</p></td>
</tr>

<tr>
<td valign="top" ><p>processEvent($event,$args=null)</p></td>
<td valign="top" ><p>Method to process events</p>

<p>$event – parameters of a event to process</p>

<p>$args – additional parameters of a event</p></td>
</tr>

<tr>
<td valign="top" ><p>subscribe()</p></td>
<td valign="top" ><p>Method to register internal possible request and events</p></td>
</tr>

<tr>
<td valign="top" ><p>processRequest($args)</p></td>
<td valign="top" ><p>Method to process requests</p>

<p>$args – parameters of a request</p></td>
</tr>

<tr>
<td valign="top" ><p>setRegistry()</p></td>
<td valign="top" ><p>Storing a row filter in the <b>Registry</b> component</p></td>
</tr>

<tr>
<td valign="top" ><p>formFilter($having)</p></td>
<td valign="top" ><p>Construction of SQL code from predicate components for clause “where” or “having” which depends of $having argument</p></td>
</tr>

<tr>
<td valign="top" ><p>getFieldsetPredicate($aSet)</p></td>
<td valign="top" ><p>Construction SQL code for a group of predicates</p></td>
</tr>

<tr>
<td valign="top" ><p>validate()</p></td>
<td valign="top" ><p>Method to validate input components’ values</p></td>
</tr>

<tr>
<td valign="top" ><p>validInput()</p></td>
<td valign="top" ><p>Method to check input components’ values. This method is needed after restoring of the <b>Search</b> component’s state</p></td>
</tr>

<tr>
<td valign="top" ><p>ApplyRequestValues()</p></td>
<td valign="top" ><p>Applying input values</p></td>
</tr>

<tr>
<td valign="top" ><p>setFilter()</p></td>
<td valign="top" ><p>Method to process a request to set a new row filter</p></td>
</tr>

<tr>
<td valign="top" ><p>dropFilter()</p></td>
<td valign="top" ><p>Method process a request to drop a row filter</p></td>
</tr>

</tbody>
</table>

<p>The <b>Search</b> component permits the user to construct very complex row filters.</p>

<h1>The Dataset component</h1>

<p>The <b>Dataset</b> is nonvisual component and serves to set hidden row filters for <b>Grid</b> components or lists.</p>

<p>Unlike of the Form, <b>Grid</b> and <b>Search</b> component the <b>Dataset</b> component does not have properties to store in session variables.</p>

<p>The <b>Dataset</b> component consists of the predicates which are known or can become known only at run time.</p>

<p>The <b>Dataset</b> uses the <b>PredicateBuilder</b> component to construct SQL code of a row filter using its predicates.</p>

<p>To use nonstandard method of a predicate’s constructing, it’s necessary to set the custom component’s name as value of the “Custom predicate” attribute in the predicate’s specification. The custom component must have the “getPredicate” static method which constructs SQL code of the predicate.</p>

<p>The <b>Dataset</b> component stores a row filter in the <b>Registry</b> just after its own creation.</p>

<p>To use a custom class of the <b>Dataset</b> component, it’s necessary to set the custom class name in specification of an appropriate <b>Unit</b> component.</p>

<p>Apart from properties inherited from the <b>Component </b>abstract class<b>,</b> the <b>Dataset</b> has got the $predicates property which is an array of predicates and the only method “setRegistry” to store a row filter in the <b>Registry</b> component.</p>

<h1>The Crud, MasterDetail, UnitSet controllers</h1>

<p>The <b>Crud</b>, <b>MasterDetail</b>, <b>UnitSet</b> are descendants of the <b>Controller</b> abstract controller.</p>

<p>Common properties of controllers</p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>property</p></td>
<td valign="top" ><p>Comments</p></td>
</tr>

<tr>
<td valign="top" ><p>sid</p></td>
<td valign="top" ><p>Controller’s system id</p></td>
</tr>

<tr>
<td valign="top" ><p>title</p></td>
<td valign="top" ><p>Controller’s name</p></td>
</tr>

<tr>
<td valign="top" ><p>initial</p></td>
<td valign="top" ><p>Array of initial values of a controller’s properties</p></td>
</tr>

<tr>
<td valign="top" ><p>session</p></td>
<td valign="top" ><p>Array of a controller state’s properties</p></td>
</tr>

<tr>
<td valign="top" ><p>acl</p></td>
<td valign="top" ><p>Access Control List – an array or user roles that have access to a controller </p></td>
</tr>

<tr>
<td valign="top" ><p>template</p></td>
<td valign="top" ><p>Template to render a controller’s page</p></td>
</tr>

<tr>
<td valign="top" ><p>type</p></td>
<td valign="top" ><p>Component’s type. It is equal to 'controller'</p></td>
</tr>

</tbody>
</table>

<p>The <b>Crud</b> controller has got only one Unit (property”unit”).</p>

<p>The <b>MasterDetail</b> has got the master Unit (property “master”) and the detail Unit (property “detail”). The <b>MasterDetail</b> can be in two modes (property “mode”): master or detail.</p>

<p>The <b>UnitSet</b> controller has got the master Unit (property “master)” and collections of non-master Units (property “units”). The <b>UnitSet</b> can be in several modes (property “mode”): master or a mode equal to a non-master Unit’s system id.</p>

<p>Controller’s method</p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>method</p></td>
<td valign="top" ><p>comments</p></td>
</tr>

<tr>
<td valign="top" ><p>__construct($sid,$config,$template)</p></td>
<td valign="top" ><p>Class constructor</p>

<p>$sid- controller’s system id </p>

<p>$config-controller’s specification</p>

<p>$template- template</p></td>
</tr>

<tr>
<td valign="top" ><p>initState()</p></td>
<td valign="top" ><p>Method to initiate properties’ values</p></td>
</tr>

<tr>
<td valign="top" ><p>saveState()</p></td>
<td valign="top" ><p>Method to save a controller’s state</p></td>
</tr>

<tr>
<td valign="top" ><p>restoreState()</p></td>
<td valign="top" ><p>Method to restore a controller’s state</p></td>
</tr>

<tr>
<td valign="top" ><p>subscribe()</p></td>
<td valign="top" ><p>Method to register possible request and events</p></td>
</tr>

<tr>
<td valign="top" ><p>processRequest($args)</p></td>
<td valign="top" ><p>Method to process requests</p>

<p>$args – parameters of a request</p></td>
</tr>

<tr>
<td valign="top" ><p>processEvent($event,$args)</p></td>
<td valign="top" ><p>Method to process events</p>

<p>$event – parameters of a event to process</p>

<p>$args – additional parameters of a event</p></td>
</tr>

<tr>
<td valign="top" ><p>loadData()</p></td>
<td valign="top" ><p>Method to load data for a page rendering</p></td>
</tr>

<tr>
<td valign="top" ><p>renderJavaScript()</p></td>
<td valign="top" ><p>Method to form data to be transferred for JavaScript</p></td>
</tr>

</tbody>
</table>
    <br>
<h1>The PredicateBuilder component</h1>

<p>The <b>PredicateBuilder</b> component serves to construct SQL code of a row filter from received predicates.</p>

<p>The <b>Search</b>, <b>Dataset</b> and <b>ListLoader</b> components use the <b>PredicateBuilder</b> to construct SQL code of a row filter.</p>

<p>The <b>PredicateBuilder</b> can return:</p>

<p>-empty string that means that there is no any row filter </p>

<p>- SQL code of a row filter </p>

<p>- The string «empty» means that the row filter is evaluated to false or, in other words, that there are no rows to satisfy the row filter. </p>

<p>There can be used SQL functions in predicates. If a SQL function is aggregate then SQL code of the predicate is a part of the clause “having” of the SQL query. If a SQL function is not aggregate then SQL code of the predicate is a part of the clause “where” of the SQL query. </p>

<p>So the <b>PredicateBuilder</b> returns SQL code of a row filter as an associative array of SQL code for the clauses “having” and “where” of the SQL query.</p>

<p>The <b>PredicateBuilder</b> constructs SQL code for the clause “having” and for the clause “where” of the SQL query with the same “getFilter” method.</p>

<p>The <b>PredicateBuilder</b> has got only static methods and does not have properties.</p>

<p>The <b>PredicateBuilder</b>’s methods</p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>method</p></td>
<td valign="top" ><p>comments</p></td>
</tr>

<tr>
<td valign="top" ><p>getFilter($predicates)</p></td>
<td valign="top" ><p>Method to construct SQL code of a row filter from the $predicates received array of predicates </p></td>
</tr>

<tr>
<td valign="top" ><p>formFilter($predicates,$having)</p></td>
<td valign="top" ><p>Method to construct SQL code for the clause “having” or “where» of a SQL query from the $predicates received array of predicates and the $having sign of a clause type </p></td>
</tr>

<tr>
<td valign="top" ><p>getFieldsetPredicate($aSet)</p></td>
<td valign="top" ><p>Method to construct common SQL code from a group of predicates</p></td>
</tr>

<tr>
<td valign="top" ><p>getPredicate($a)</p></td>
<td valign="top" ><p>Method to construct SQL code from the $a received predicate</p></td>
</tr>

</tbody>
</table>
         <br>
<h1>Helper components</h1>

<p>There are helper components, the <b>debug</b> and <b>Timer,</b> in the Framework.</p>

<p>The <b>debug</b> component serves to collect and display the following debug information:</p>

<ul>
<li>Values of debug variables</li>
<li>Results of SQL queries’ execution</li>
<li>Calls of the <b>RequestHandler </b>and <b>EventHandler</b> methods</li>
<li>Initiated classes</li>
<li>Logging of specifications’ exporting</li>
</ul>

<p>Depending on settings, the <b>debug</b> component stores debug information in the “fgs_debug” system table of in arrays of the <b>Registry</b> component. </p>

<p>The <b>debug</b> component has got only static methods. Each kind of debug information is stored by a separate method of the <b>Registry</b>.</p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>method</p></td>
<td valign="top" ><p>comments</p></td>
</tr>

<tr>
<td valign="top" ><p>Write</p>

</td>
<td valign="top" ><p>To store values of a debug variable</p>

<p>parameters</p>

<p>$value –value of a debug variable</p>

<p>$var –name of a debug variable</p>

<p>$point – optional point of debugging</p>

<p>$error – optional sign of an error to mark it during output</p></td>
</tr>

<tr>
<td valign="top" ><p>writeSql</p></td>
<td valign="top" ><p>To store result of a SQL query’s execution</p>

<p>parameters</p>

<p>$q –SQL query</p>

<p>$result – result of execution</p>

<p>$type – type of a SQL query</p></td>
</tr>

<tr>
<td valign="top" ><p>writeListeners</p></td>
<td valign="top" ><p>To store a call of the <b>RequestHandler </b>or <b>EventHandler</b> method</p>

<p>parameters</p>

<p>$args –received array of arguments</p>

<p>$type – type of a call</p></td>
</tr>

<tr>
<td valign="top" ><p>writeClass</p></td>
<td valign="top" ><p>To store a initiated class</p>

<p>parameters</p>

<p>$class –class name</p>

<p>$path – path to a class’s file</p></td>
</tr>

<tr>
<td valign="top" ><p>writeExport</p></td>
<td valign="top" ><p>To store an error in a specification</p>

<p>parameters</p>

<p>$component – type of a exporting component</p>

<p>$sid – system id of a exporting component</p>

<p>$error – an error code код ошибки экспорта</p>

<p>$detail – optional type of child element</p>

<p>$detail_sid optional code of a child element</p></td>
</tr>

<tr>
<td valign="top" ><p>render</p></td>
<td valign="top" ><p>Method of debug information’s rendering</p></td>
</tr>

</tbody>
</table>

<p>To use the <b>debug</b> component debug mode has to be set. </p>

<p>The <b>Timer</b> component is developed with using <b>Singleton</b> design pattern and serves for time profiling of scripts’ execution. To get statistics of SQL queries’s execution, all methods of the database driver that manipulates data has to include program code of storing methods’ execution time.</p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody>
<tr>
<td valign="top" ><p>method</p></td>
<td valign="top" ><p>comments</p></td>
</tr>

<tr>
<td valign="top" ><p>start</p></td>
<td valign="top" ><p>To start the <b>Timer</b></p>

<p>parameter</p>

<p>$point–abbreviation of the starting point </p></td>
</tr>

<tr>
<td valign="top" ><p>mark</p></td>
<td valign="top" ><p>Adding of a profiling point</p>

<p>parameter</p>

<p>$point– abbreviation of a profiling point</p></td>
</tr>

<tr>
<td valign="top" ><p>addSql</p></td>
<td valign="top" ><p>Adding time of a SQL query’s execution</p>

<p>parameter</p>

<p>$time – time of a SQL query’s execution in microseconds</p></td>
</tr>

<tr>
<td valign="top" ><p>render</p></td>
<td valign="top" ><p>Method of time profiling rendering </p></td>
</tr>

</tbody>
</table>
 <br>
<h1>The Framework’s templates</h1>

<p>There are three templates in the Framework:</p>

<p>admin_crud.php- the template for <b>Crud</b> controllers</p>

<p>admin_md.php- the template for <b>MasterDetail</b> controllers </p>

<p>admin_universal.php- the template for <b>UnitSet</b> controllers</p>

<p>These templates have to be used with the application.php control scrip. These templates use the <b>svm</b> class to create a two level vertical menu.</p>

